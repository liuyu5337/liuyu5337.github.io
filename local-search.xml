<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>NAT模式Ubuntu Server下的Docker代理设置</title>
    <link href="/2025/09/26/NAT%E6%A8%A1%E5%BC%8FUbuntu-Server%E4%B8%8B%E7%9A%84Docker%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/"/>
    <url>/2025/09/26/NAT%E6%A8%A1%E5%BC%8FUbuntu-Server%E4%B8%8B%E7%9A%84Docker%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>VMWare或者VirtualBox安装Ubuntu Server后，如果ubuntuserver需要通过宿主机(windows/Mac)代理(clash)访问Docker 或者GitHub，需要在Ubuntu Server设置代理配置。</p><h4 id="宿主机配置">宿主机配置</h4><p>首先，宿主机(windows/Mac)首先需要打开"允许来自局域网的连接"</p><p>mac配置</p><p><img src="mac.png" /></p><p>windows配置</p><p><img src="windows.png" /></p><h4 id="虚拟机配置代理">虚拟机配置代理</h4><h5 id="普通代理">普通代理</h5><p>在ubuntu server配置代理:</p><p>~/.bashrc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">export https_proxy=http://192.168.132.1:7897  # 按照宿主机在虚拟网络的地址进行配置<br>export http_proxy=http://192.168.132.1:7897<br>export all_proxy=socks5://192.168.132.1:7897<br></code></pre></td></tr></table></figure><p>执行 source ~/.bashrc，这样系统启动之后，就可以自动使用代理。</p><h5 id="docker代理">docker代理</h5><p>如果不存在配置文件（/etc/systemd/system/docker.service.d/proxy.conf）就新建配置文件，然后编辑该配置文件,内容如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Service]<br>Environment=&quot;HTTP_PROXY=http://192.168.132.1:7897&quot;<br>Environment=&quot;HTTPS_PROXY=http://192.168.132.1:7897&quot;<br>Environment=&quot;NO_PROXY=localhost,127.0.0.1,192.168.0.0/16&quot;  # 忽略内网代理<br></code></pre></td></tr></table></figure><p>然后执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl daemon-reload<br>sudo systemctl restart docker  #重启docker <br></code></pre></td></tr></table></figure><p>测试docker拉取镜像是否成功</p><p><img src="docker-pull.png" /></p><p>拉取镜像成功。</p><p>总结：如果要在NAT网络模式下，实现虚拟机的代理上网，宿主机需要<strong>允许来自局域网的连接</strong>, 虚拟机 需要分别在 ~/.bashrc和docker对应的配置文件中添加对应的代理信息。</p>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>OS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu LVM（逻辑卷管理）使用</title>
    <link href="/2025/09/23/Ubuntu-LVM%EF%BC%88%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86%EF%BC%89%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/09/23/Ubuntu-LVM%EF%BC%88%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86%EF%BC%89%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>从Ubuntu 18.04LTS开始，安装程序在分区时默认提供“使用LVM”的选项，但并不是默认选中。用户需要手动选择使用LVM。在Ubuntu20.04LTS及更高版本中，安装程序提供了更高级的“高级分区”选项，其中可以明确设置分区大小和LVM配置。</p><ol type="1"><li>Ubuntu LVM使用时间线</li></ol><p>Ubuntu 18.04 LTS (2018) → 开始更广泛使用 LVM Ubuntu 20.04 LTS (2020)→ LVM 成为服务器版常见选择 Ubuntu 22.04 LTS (2022) → 在更多场景默认使用LVM</p><p><strong>LVM 普及趋势</strong>：从 Ubuntu 18.04开始越来越常见，<strong>服务器版更普遍</strong>：服务器安装更倾向于使用LVM。</p><blockquote><p>LVM是一种用于Linux的逻辑卷管理器，它允许你管理磁盘驱动器和其他大容量存储设备。使用LVM，你可以将多个物理磁盘或分区组合成一个卷组，然后从该卷组中创建逻辑卷。逻辑卷可以像普通分区一样使用，但它们具有更灵活的特性，例如可以动态调整大小、跨多个磁盘等。</p></blockquote><p>LVM结构如下图所示：</p><p>物理卷 (PV) → 卷组 (VG) → 逻辑卷 (LV) ↑ ↑ ↑ 磁盘分区 多个PV组合实际使用的卷</p><p>（后面用到的命令, PV、 VG、LV分别表示 对应查看磁盘对应的LVM命令信息）</p><ol start="2" type="1"><li><p>在服务器安装过程中（以 24.04服务版为例），LVM是默认选项。</p><p><img src="lvm.png" /></p></li></ol><p>在图片中可以看到，默认是"Set up this disk as an LVM group"</p><ol start="3" type="1"><li><p>系统安装成功后，可以查看磁盘信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"> <span class="hljs-comment">#查看磁盘使用信息</span><br><span class="hljs-built_in">df</span> -h<br></code></pre></td></tr></table></figure><p><img src="disk-1.png" /></p></li></ol><p>安装过程中，磁盘是50G， 但是看到磁盘的信息加起来不到50G，而且/dev/mapper/ubuntu–vg-ubuntu–lv只有24G。那剩余的磁盘去哪里了呢。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 查看磁盘</span><br><span class="hljs-attribute">fdisk</span> -l <br></code></pre></td></tr></table></figure><p><img src="disk-2.png" /></p><p>在图片中可以看到 /dev/sda3 有48G,磁盘50G是没有问题的。只是使用的只有24G（/dev/mapper/ubuntu–vg-ubuntu–lv）。</p><ol start="4" type="1"><li><p>查看LVM信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">扫描物理卷</span><br>sudo pvscan<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示物理卷详细信息</span><br>sudo pvdisplay<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示卷组</span><br>sudo vgdisplay<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示逻辑卷</span><br>sudo lvdisplay<br></code></pre></td></tr></table></figure><p>pvscan 可以看到磁盘信息</p><p><img src="pvscan.png" /></p></li></ol><p>​ pvdisplay 可以看到 total PE 是12287 , Free PE 6144, Allocate PE6143, 那么少的24G 就是 free PE</p><p>​ <img src="pvdisplay.png" /></p><p>vgdisplay 命令可以看的更清楚， Free PE 24GB, df -h 少的24G找到了。Alloc PE 24GB就是 df -h 看到的磁盘空间。</p><p><img src="vgdisplay.png" /></p><p>lvdisplay 可以看到 逻辑卷的具体信息，分配的空间是24G,逻辑卷的路径、名称、卷组的名称等等</p><p><img src="lvdisplay.png" /></p><ol start="5" type="1"><li><p>上面的命令可以加参数</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 查看 ubuntu-vg 卷信息</span><br>sudo vgdisplay ubuntu-vg<br><span class="hljs-comment"># 查看 /dev/sda3 的磁盘信息</span><br>sudo pvdisplay <span class="hljs-regexp">/dev/</span>sda3<br></code></pre></td></tr></table></figure></li><li><p>lsblk 和 blkid 是 Linux中用于查看块设备（如硬盘、分区等）信息的两个常用命令，可提供设备名称、大小、文件系统类型、挂载点等详细信息。</p><p>lsblk 命令结果</p></li></ol><p><img src="lsblk.png" /></p><p>blkid命令结果</p><p><img src="blkid.png" /></p><ol start="7" type="1"><li><p>已分配的磁盘空间用尽，<strong>系统不会自动扩展</strong>（不会自动把未分配的磁盘进行空间扩展），需要手动处理。</p><blockquote><p>不进行自动扩展的原因：</p><ol type="1"><li><strong>LVM 设计原则</strong>：LVM 需要明确的管理员操作确认</li><li><strong>文件系统独立性</strong>：逻辑卷扩展和文件系统调整是两个独立步骤</li><li><strong>风险控制</strong>：自动扩展可能导致数据损坏或系统不稳定</li></ol></blockquote></li><li><p>将未使用的空间进行扩展</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 检查当前空间状况（确认问题）</span><br><span class="hljs-built_in">df</span> -h<br>sudo vgdisplay ubuntu-vg<br><br><span class="hljs-comment"># 2. 扩展逻辑卷（使用部分或全部空闲空间）</span><br><span class="hljs-comment"># 扩展10G：</span><br>sudo lvextend -L +10G /dev/ubuntu-vg/ubuntu-lv<br><br><span class="hljs-comment"># 或者扩展所有空闲空间：</span><br>sudo lvextend -l +100%FREE /dev/ubuntu-vg/ubuntu-lv<br><br><span class="hljs-comment"># 3. 调整文件系统大小</span><br><span class="hljs-comment"># 对于ext4：</span><br>sudo resize2fs /dev/ubuntu-vg/ubuntu-lv<br><br><span class="hljs-comment"># 对于xfs：</span><br>sudo xfs_growfs /<br><br><span class="hljs-comment"># 4. 验证扩展结果</span><br><span class="hljs-built_in">df</span> -h<br></code></pre></td></tr></table></figure></li></ol><blockquote><p><strong>扩展逻辑卷后必须执行<code>sudo resize2fs /dev/ubuntu-vg/ubuntu-lv</code></strong></p><p>逻辑卷扩展和文件系统调整是 两个独立的操作：</p><ol type="1"><li>逻辑卷扩展 (lvextend) 只是扩大了"容器"的大小</li></ol><p>相当于给房子扩建了房间</p><p>但文件系统还不知道这个变化</p><ol start="2" type="1"><li>文件系统调整 (resize2fs) 让文件系统识别并使用新的空间</li></ol><p>相当于告诉家具可以摆放到新扩建的房间</p><p>必须执行才能实际使用新空间</p></blockquote><p>在执行 lvextend 和 resize2fs 命令时，后面的 路径就是 lvdisplay显示的<strong>LV Path</strong>。</p><p><img src="lvdisplay-1.png" /></p><p>空间扩展成功，并且 重新调整文件系统大小后，再用df -h或者 df-hT查看，就发现可用空间已经变大了。</p><p><img src="df-hT.png" /></p><p>综上，LVM的基本使用就没有什么问题了。</p>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>OS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mac环境python环境设置</title>
    <link href="/2025/09/17/Mac%E7%8E%AF%E5%A2%83python%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"/>
    <url>/2025/09/17/Mac%E7%8E%AF%E5%A2%83python%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>Mac 环境默认会有python：</p><p><img src="python.png" /></p><p>但是在开发环境中，有时候会用到不同版本的python，为了方便开发和管理，常用的python版本管理有pyenv, virtualenv/virtualenvwrapper。</p><p>本文介绍使用virtualenv/virtualenvwrapper 构建多版本的python管理。</p><h4 id="一条件准备">一、条件准备</h4><p>Mac 或者linux/Unix环境默认会带有python版本，如果较老的系统默认的python版本会比较低；另外，有时候想保留纯净的macpython版本，以上两种情况就需要另外安装新的python版本。</p><p>为了避免和系统中已有的版本区分，安装新版本的python建议安装在指定目录下，通过linux如ubuntu 等不支持通过系统命令(如aptinstall) 安装到指定目录，所以，需要通过源码安装python.</p><ol type="1"><li><p>下载源码 如到https://www.python.org/downloads/release/python-3137/ 下载3.13.7的源码包。</p></li><li><p>解压文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">如果是.tar.xz包<br>tar -xvf Python-3.13.7.tar.xz<br>如果是 .tgz包<br>tar -zxvf Python-3.13.7.tgz<br><br>注：.tgz (或 .tar.gz) 和 .tar.xz 的主要区别在于它们使用不同的压缩算法，其中 .tar.xz 使用更先进、压缩率更高的 xz 算法，而 .tgz 使用传统的 gzip 算法。这意味着 .tar.xz 文件通常比同等文件压缩的 .tgz 文件体积更小，尤其是在存储空间有限或需要传输大量数据时更有优势。然而，xz 压缩需要更长的时间和更多的计算资源，速度不如 gzip。<br></code></pre></td></tr></table></figure></li><li><p>编译，指定安装目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">./configure --prefix=/Users/yourname/my_python --enable-optimizations<br>如<br>./configure --prefix=/Users/xxxx/dev_env/python/python_env/3.13.7 --enable-optimizations #xxxx是你的登录用户名称<br>--prefix：指定安装根目录（核心参数）<br>--enable-optimizations：启用编译优化（可选，会慢一些但运行更快）<br><br>make -j4  # 多线程编译（4 核心，根据 CPU 调整）<br>make install<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装成功后，查看版本</span><br>/Users/xxxx/dev_env/python/python_env/3.13.7/bin/python3 --version<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看安装路径</span><br>ls /Users/xxxx/dev_env/python/python_env/3.13.7/bin/  # 包含 python3、pip3 等<br></code></pre></td></tr></table></figure></li><li><p>把安装的 python路径写入到 系统环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">如果是用zsh,可以在~/.zshrc写入环境变量，不用zsh,默认情况下，mac 写入 ~/.bash_profile, ubuntu或者其他linux可以写入 ~/.bashrc</span><br><br>export PATH=$HOME/dev_env/python/python_env/3.13.7/bin:$PATH<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后 执行 <span class="hljs-built_in">source</span> ~/.对应的配置配置文件</span><br>source ~/.zshrc  ## 或者 source ~/.bash_profile<br><br></code></pre></td></tr></table></figure></li><li><p>安装virtualenv 和virtualwrapper。为了保持系统的"纯净"，或者说便于管理，这里把virtualenv或者virtualenvwrapper安装在指定目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">把 virtualenv virtualenvwrapper 安装到<span class="hljs-variable">$HOME</span>/dev_env/python/python_env/virtualenv_bin</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">HOME/dev_env/python/python_env/3.13.7/bin/python3 -m pip install --prefix=<span class="hljs-variable">$HOME</span>/dev_env/python/python_env/virtualenv_bin virtualenv virtualenvwrapper</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果不想安装到指定目录 执行</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">HOME/dev_env/python/python_env/3.13.7/bin/python3 -m pip install --user virtualenv virtualenvwrapper <span class="hljs-comment"># --user 表示用户级安装</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查是否安装成功，如果有输出信息，就表示按照成功</span> <br><span class="hljs-meta prompt_">$</span><span class="language-bash">HOME/dev_env/python/python_env/3.13.7/bin/python3 -m pip show virtualenvwrapper</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">HOME/dev_env/python/python_env/3.13.7/bin/python3 -m pip show virtualenv</span><br></code></pre></td></tr></table></figure></li><li><p>设置virtualenv环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在~/.zshrc(Mac)或者其他的配置文件中进行如下配置</span> <br>export WORKON_HOME=$HOME/dev_env/python/virtualenvs<br>export VIRTUALENVWRAPPER_PYTHON=$HOME/dev_env/python/python_env/3.13.7/bin/python3<br>export VIRTUALENVWRAPPER_VIRTUALENV=$HOME/dev_env/python/python_env/virtualenv_bin/bin/virtualenv<br>export PATH=$HOME/dev_env/python/python_env/virtualenv_bin/bin:$PATH<br>source $HOME/dev_env/python/python_env/virtualenv_bin/bin/virtualenvwrapper.sh<br></code></pre></td></tr></table></figure><p>重新加载配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source ~/.zshrc # mac 环境<br></code></pre></td></tr></table></figure><p>如果上述命令 报错：'virtualenvwrapper.hook_loader'(ModuleNotFoundError: No module named 'virtualenvwrapper')virtualenvwrapper.sh: There was a problem running the initializationhooks.</p><p>这是因为 <strong>virtualenvwrapper 模块和 Python 环境不匹配</strong>问题, 使用 —prefix安装 virtualenv 、virtualenvwrapper后，要把 Pythonsite-packages 路径加入 <code>PYTHONPATH</code></p></li><li><p>设置 PYTHONPATH</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PYTHONPATH=$HOME/dev_env/python/python_env/virtualenv_bin/lib/python3.13/site-packages:$PYTHONPATH<br></code></pre></td></tr></table></figure><p>完整版配置信息如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PATH=$HOME/dev_env/python/python_env/3.13.7/bin:$PATH<br>export WORKON_HOME=$HOME/dev_env/python/virtualenvs<br>export VIRTUALENVWRAPPER_PYTHON=$HOME/dev_env/python/python_env/3.13.7/bin/python3<br>export VIRTUALENVWRAPPER_VIRTUALENV=$HOME/dev_env/python/python_env/virtualenv_bin/bin/virtualenv<br>export PATH=$HOME/dev_env/python/python_env/virtualenv_bin/bin:$PATH<br>export PYTHONPATH=$HOME/dev_env/python/python_env/virtualenv_bin/lib/python3.13/site-packages:$PYTHONPATH<br>source $HOME/dev_env/python/python_env/virtualenv_bin/bin/virtualenvwrapper.sh<br></code></pre></td></tr></table></figure></li><li><p>重新加载配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">环境变量写在哪个配置文件，就对哪个配置文件执行 <span class="hljs-built_in">source</span>命令</span><br>source ~/.zshrc #mac zsh 或者 source ~/.bash_profile<br><span class="hljs-meta prompt_">#</span><span class="language-bash">其他系统执行 如 <span class="hljs-built_in">source</span> ~/.bashrc 等</span><br><br></code></pre></td></tr></table></figure></li><li><p>检查效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 列出所有虚拟环境 lsvirtualenv 或 workon</span><br>workon <br>lsvirtualenv<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 进入指定虚拟环境env1</span><br>workon env1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 创建一个新的虚拟环境env2</span><br>mkvirtualenv env2<br><span class="hljs-meta prompt_"># </span><span class="language-bash">4. 退出当前的虚拟环境，回到全局环境</span><br>deactivate<br><span class="hljs-meta prompt_"># </span><span class="language-bash">5. 删除一个指定的虚拟环境</span><br>rmvirtualenv env2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">6. 指定python 版本 创建虚拟环境</span><br>mkvirtualenv --python=python3.6 venv<br><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>开发语言</category>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>本地制作docker镜像</title>
    <link href="/2025/09/08/%E6%9C%AC%E5%9C%B0%E5%88%B6%E4%BD%9Cdocker%E9%95%9C%E5%83%8F/"/>
    <url>/2025/09/08/%E6%9C%AC%E5%9C%B0%E5%88%B6%E4%BD%9Cdocker%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<p>国内使用 docker，如果不使用梯子，存在拉取docker镜像失败的情况。为了使用docker，需要自己构建镜像。</p><h4 id="遇到的问题">遇到的问题</h4><p>在拉取镜像的时候，如果不用梯子，经常遇到的错误是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Get https://registry-1.docker.io/v2/: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)<br></code></pre></td></tr></table></figure><p>这个时候，通常是<strong>使用国内镜像加速</strong>,可以用镜像加速器：</p><ul><li><p>编辑配置文件<code>/etc/docker/daemon.json</code>（如果没有就新建）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;https://mirror.ccs.tencentyun.com&quot;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><p>但是，通常情况下，这类方法都是无效的。</p></li></ul><h4 id="代理的方式">代理的方式</h4><p>如果你需要翻墙：</p><ul><li><p>确认环境变量中 <code>http_proxy</code> / <code>https_proxy</code>配置正确；</p></li><li><p>或者在<code>/etc/systemd/system/docker.service.d/http-proxy.conf</code>添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Service]<br>Environment=&quot;HTTP_PROXY=http://127.0.0.1:7890/&quot;<br>Environment=&quot;HTTPS_PROXY=http://127.0.0.1:7890/&quot;<br>Environment=&quot;NO_PROXY=localhost,127.0.0.1&quot;<br></code></pre></td></tr></table></figure></li></ul><p>然后执行</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">sudo systemctl daemon-reload<br>sudo systemctl <span class="hljs-built_in">restart</span> docker<br><br>或者<br>sudo service docker <span class="hljs-built_in">restart</span><br></code></pre></td></tr></table></figure><p>如果，你可以科学上网，那么使用上面的方法，就可以了。如果你的环境不允许你使用梯子，就请往下看。</p><p>下面通过脚本排查问题开始，一步一步实现自定义创建镜像。</p><h5 id="排查脚本">1 排查脚本</h5><p><strong>一键排查脚本</strong>，可以检测 DNS、Docker Hub访问、加速器配置、代理环境变量，帮助你定位到底卡在哪一步。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>echo &quot;====== Docker 网络排查脚本 ======&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 检查 DNS 解析</span><br>echo -e &quot;\n[1] 检查 DNS 解析 registry-1.docker.io ...&quot;<br>nslookup registry-1.docker.io 2&gt;/dev/null || dig registry-1.docker.io<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 检查能否访问 Docker Hub</span><br>echo -e &quot;\n[2] 测试 curl 访问 Docker Hub ...&quot;<br>curl -I --max-time 10 https://registry-1.docker.io/v2/ || echo &quot;❌ 无法访问 Docker Hub&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 检查 Docker Daemon 配置</span><br>echo -e &quot;\n[3] 检查 Docker 配置文件 /etc/docker/daemon.json ...&quot;<br>if [ -f /etc/docker/daemon.json ]; then<br>    cat /etc/docker/daemon.json<br>else<br>    echo &quot;⚠️ 配置文件不存在&quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4. 检查代理环境变量</span><br>echo -e &quot;\n[4] 检查代理环境变量 ...&quot;<br>echo &quot;HTTP_PROXY=$HTTP_PROXY&quot;<br>echo &quot;HTTPS_PROXY=$HTTPS_PROXY&quot;<br>echo &quot;NO_PROXY=$NO_PROXY&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">5. 检查 systemd 里的 Docker 代理配置</span><br>echo -e &quot;\n[5] 检查 systemd 中 Docker 的代理配置 ...&quot;<br>systemctl show --property=Environment docker | grep -i proxy<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">6. 测试 docker pull</span><br>echo -e &quot;\n[6] 测试 docker pull hello-world ...&quot;<br>docker pull hello-world<br><br>echo -e &quot;\n====== 排查结束 ======&quot;<br><br></code></pre></td></tr></table></figure><p>运行方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod +x check-docker.sh<br>./check-docker.sh<br></code></pre></td></tr></table></figure><p>执行结果会依次告诉你：</p><ol type="1"><li>DNS 是否能解析 <code>registry-1.docker.io</code></li><li>是否能直连访问 Docker Hub</li><li>Docker 是否配置了加速器</li><li>是否有代理环境变量</li><li>systemd 里是否有代理配置</li><li>拉取 <code>hello-world</code> 是否成功</li></ol><h5 id="自己制作镜像">2. 自己制作镜像</h5><p>通过上面的排查脚本，如果你不能直接访问docker hub,而且也没有配置代理，那么就需要自己制作镜像。首先是制作操作系统镜像，这里就用ubuntu为例。</p><p>制作Ubuntu镜像，可以采用的方式：</p><p>一、基于官方 Ubuntu 镜像定制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM ubuntu:20.04<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置时区（避免交互卡住）</span><br>ENV DEBIAN_FRONTEND=noninteractive TZ=Asia/Shanghai<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新软件源并安装常用工具</span><br>RUN apt-get update &amp;&amp; apt-get install -y \<br>    vim curl wget net-tools iputils-ping \<br>    &amp;&amp; rm -rf /var/lib/apt/lists/*<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置默认命令</span><br>CMD [&quot;/bin/bash&quot;]<br><br></code></pre></td></tr></table></figure><p>如果你无法连接docker hub, 那么这个方法就不能使用。</p><p>二、完全“裸做”一个 Ubuntu 根文件系统</p><p>如果你完全不想依赖官方 <code>ubuntu:20.04</code> 镜像，可以用<strong>debootstrap</strong> 自己生成 rootfs：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">1.安装工具：<br>sudo apt-get install debootstrap<br>2.创建一个 Ubuntu 根文件系统：<br>sudo debootstrap --arch=amd64 focal ./ubuntu-rootfs http://archive.ubuntu.com/ubuntu/<br>3.用这个根文件系统制作镜像：<br>cd ubuntu-rootfs<br>sudo tar -C . -c . | docker import - my-ubuntu:20.04<br>4. 运行容器：<br>docker run -it my-ubuntu:20.04 /bin/bash<br></code></pre></td></tr></table></figure><p>这种方式是真正“自己做”的 Ubuntu 镜像，完全不依赖 Docker Hub。</p><p>三、从 ISO 做镜像（更硬核）</p><p>你可以下载 Ubuntu 的 ISO，用 chroot 提取 rootfs，然后<code>docker import</code>。不过比 <code>debootstrap</code> 麻烦.</p><p>下面写一个 <strong>自动化脚本</strong>，用 <code>debootstrap</code>来一键构建 Ubuntu 根文件系统，并导入 Docker 成为镜像。</p><p>保存成 <code>build-ubuntu-image.sh</code>，执行就能得到一个新的Ubuntu 镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">set</span> -e<br><br><span class="hljs-comment"># 默认参数</span><br>UBUNTU_VERSION=focal      <span class="hljs-comment"># Ubuntu 20.04 (focal)，可改为 jammy(22.04) 等</span><br>ARCH=amd64<br>MIRROR=http://archive.ubuntu.com/ubuntu/<br>ROOTFS_DIR=ubuntu-rootfs<br>IMAGE_NAME=my-ubuntu<br>TAG=20.04<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;====== 构建 Ubuntu Docker 镜像 ======&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;版本: <span class="hljs-variable">$UBUNTU_VERSION</span>  架构: <span class="hljs-variable">$ARCH</span>  镜像名: <span class="hljs-variable">$IMAGE_NAME</span>:<span class="hljs-variable">$TAG</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;使用镜像源: <span class="hljs-variable">$MIRROR</span>&quot;</span><br><span class="hljs-built_in">echo</span><br><br><span class="hljs-comment"># 检查 debootstrap 是否安装</span><br><span class="hljs-keyword">if</span> ! <span class="hljs-built_in">command</span> -v debootstrap &gt;/dev/null 2&gt;&amp;1; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;⚠️ 未找到 debootstrap，正在安装...&quot;</span><br>    sudo apt-get update &amp;&amp; sudo apt-get install -y debootstrap<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 创建 rootfs</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 开始构建 rootfs...&quot;</span><br>sudo <span class="hljs-built_in">rm</span> -rf <span class="hljs-variable">$ROOTFS_DIR</span><br>sudo debootstrap --<span class="hljs-built_in">arch</span>=<span class="hljs-variable">$ARCH</span> <span class="hljs-variable">$UBUNTU_VERSION</span> <span class="hljs-variable">$ROOTFS_DIR</span> <span class="hljs-variable">$MIRROR</span><br><br><span class="hljs-comment"># 导入到 Docker</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 打包并导入 Docker...&quot;</span><br>sudo tar -C <span class="hljs-variable">$ROOTFS_DIR</span> -c . | docker import - <span class="hljs-variable">$IMAGE_NAME</span>:<span class="hljs-variable">$TAG</span><br><br><span class="hljs-comment"># 清理</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 清理临时文件...&quot;</span><br>sudo <span class="hljs-built_in">rm</span> -rf <span class="hljs-variable">$ROOTFS_DIR</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;✅ 镜像构建完成！&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;你现在可以运行: docker run -it <span class="hljs-variable">$IMAGE_NAME</span>:<span class="hljs-variable">$TAG</span> /bin/bash&quot;</span><br><br></code></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">1. chmod +x build-ubuntu-image.sh<br>2. ./build-ubuntu-image.sh<br>3. docker images<br>4. docker run -it my-ubuntu:20.04 /bin/bash<br></code></pre></td></tr></table></figure><p>如果你在国内，<code>archive.ubuntu.com</code>可能很慢，可以改成清华源：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">MIRROR=https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/ubuntu/</span><br></code></pre></td></tr></table></figure><p><code>UBUNTU_VERSION</code> 可以改成 <code>jammy</code>(22.04)，<code>noble</code> (24.04)</p><h5 id="升级一下脚本支持-可选参数">3.升级一下脚本，支持<strong>可选参数</strong></h5><ul><li>第 1 个参数：Ubuntu 代号（如<code>focal</code>、<code>jammy</code>、<code>noble</code>）</li><li>第 2 个参数：镜像 TAG（如<code>20.04</code>、<code>22.04</code>、<code>24.04</code>）</li></ul><p>如果不传参数，默认就是 Ubuntu 20.04（focal）。</p><p>脚本：<code>build-ubuntu-image.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>set -e<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">==============================</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">一键构建 Ubuntu Docker 镜像</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用: ./build-ubuntu-image.sh [release] [tag]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">例子: ./build-ubuntu-image.sh jammy 22.04</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">==============================</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">默认参数</span><br>DEFAULT_RELEASE=focal<br>DEFAULT_TAG=20.04<br>ARCH=amd64<br>MIRROR=https://mirrors.tuna.tsinghua.edu.cn/ubuntu/   # 清华源，国内快<br>ROOTFS_DIR=ubuntu-rootfs<br>IMAGE_NAME=my-ubuntu<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">读取用户参数</span><br>UBUNTU_RELEASE=$&#123;1:-$DEFAULT_RELEASE&#125;<br>TAG=$&#123;2:-$DEFAULT_TAG&#125;<br><br>echo &quot;====== 构建 Ubuntu Docker 镜像 ======&quot;<br>echo &quot;Ubuntu Release: $UBUNTU_RELEASE&quot;<br>echo &quot;Docker Tag: $TAG&quot;<br>echo &quot;架构: $ARCH&quot;<br>echo &quot;镜像源: $MIRROR&quot;<br>echo<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查 debootstrap 是否安装</span><br>if ! command -v debootstrap &gt;/dev/null 2&gt;&amp;1; then<br>    echo &quot;⚠️ 未找到 debootstrap，正在安装...&quot;<br>    sudo apt-get update &amp;&amp; sudo apt-get install -y debootstrap<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 rootfs</span><br>echo &quot;👉 开始构建 rootfs...&quot;<br>sudo rm -rf $ROOTFS_DIR<br>sudo debootstrap --arch=$ARCH $UBUNTU_RELEASE $ROOTFS_DIR $MIRROR<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">导入到 Docker</span><br>echo &quot;👉 打包并导入 Docker...&quot;<br>sudo tar -C $ROOTFS_DIR -c . | docker import - $IMAGE_NAME:$TAG<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">清理</span><br>echo &quot;👉 清理临时文件...&quot;<br>sudo rm -rf $ROOTFS_DIR<br><br>echo &quot;✅ 镜像构建完成！&quot;<br>echo &quot;你现在可以运行: docker run -it $IMAGE_NAME:$TAG /bin/bash&quot;<br><br></code></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 构建默认 Ubuntu 20.04：<br>./build-ubuntu-image.sh<br><span class="hljs-bullet">2.</span> 构建 Ubuntu 22.04：<br>./build-ubuntu-image.sh jammy 22.04<br><span class="hljs-bullet">3.</span> 构建 Ubuntu 24.04：<br>./build-ubuntu-image.sh noble 24.04<br><span class="hljs-bullet">4.</span> 查看镜像：<br>docker images<br></code></pre></td></tr></table></figure><p>这样安装的镜像，没有常用工具，把脚本升级成<strong>带常用工具预装版</strong>，这样你构建的 Ubuntu镜像启动后就能直接用<code>vim</code>、<code>curl</code>、<code>ping</code>、<code>netstat</code>等，不用再每次手动安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>set -e<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">==============================</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">一键构建 Ubuntu Docker 镜像 (预装常用工具)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用: ./build-ubuntu-image.sh [release] [tag]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">例子: ./build-ubuntu-image.sh jammy 22.04</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">==============================</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">默认参数</span><br>DEFAULT_RELEASE=focal<br>DEFAULT_TAG=20.04<br>ARCH=amd64<br>MIRROR=https://mirrors.tuna.tsinghua.edu.cn/ubuntu/   # 清华源，国内快<br>ROOTFS_DIR=ubuntu-rootfs<br>IMAGE_NAME=my-ubuntu<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">读取用户参数</span><br>UBUNTU_RELEASE=$&#123;1:-$DEFAULT_RELEASE&#125;<br>TAG=$&#123;2:-$DEFAULT_TAG&#125;<br><br>echo &quot;====== 构建 Ubuntu Docker 镜像 ======&quot;<br>echo &quot;Ubuntu Release: $UBUNTU_RELEASE&quot;<br>echo &quot;Docker Tag: $TAG&quot;<br>echo &quot;架构: $ARCH&quot;<br>echo &quot;镜像源: $MIRROR&quot;<br>echo<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查 debootstrap 是否安装</span><br>if ! command -v debootstrap &gt;/dev/null 2&gt;&amp;1; then<br>    echo &quot;⚠️ 未找到 debootstrap，正在安装...&quot;<br>    sudo apt-get update &amp;&amp; sudo apt-get install -y debootstrap<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 rootfs</span><br>echo &quot;👉 开始构建 rootfs...&quot;<br>sudo rm -rf $ROOTFS_DIR<br>sudo debootstrap --arch=$ARCH $UBUNTU_RELEASE $ROOTFS_DIR $MIRROR<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打包 rootfs 并导入临时镜像</span><br>echo &quot;👉 打包 rootfs...&quot;<br>sudo tar -C $ROOTFS_DIR -c . | docker import - $&#123;IMAGE_NAME&#125;-base:$TAG<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">构建最终镜像 (预装常用工具)</span><br>echo &quot;👉 创建 Dockerfile 并安装常用工具...&quot;<br>cat &gt; Dockerfile &lt;&lt;EOF<br>FROM $&#123;IMAGE_NAME&#125;-base:$TAG<br><br>ENV DEBIAN_FRONTEND=noninteractive TZ=Asia/Shanghai<br><br>RUN apt-get update &amp;&amp; apt-get install -y \\<br>    vim curl wget net-tools iputils-ping less lsb-release ca-certificates \\<br>    &amp;&amp; rm -rf /var/lib/apt/lists/*<br><br>CMD [&quot;/bin/bash&quot;]<br>EOF<br><br>docker build -t $IMAGE_NAME:$TAG .<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">清理</span><br>echo &quot;👉 清理临时文件...&quot;<br>rm -rf $ROOTFS_DIR Dockerfile<br>docker rmi $&#123;IMAGE_NAME&#125;-base:$TAG &gt;/dev/null 2&gt;&amp;1 || true<br><br>echo &quot;✅ 镜像构建完成！&quot;<br>echo &quot;你现在可以运行: docker run -it $IMAGE_NAME:$TAG /bin/bash&quot;<br><br></code></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>. 构建默认 Ubuntu <span class="hljs-number">20.04</span>：<br>./build-ubuntu-image.<span class="hljs-keyword">sh</span><br><span class="hljs-number">2</span>. 构建 Ubuntu <span class="hljs-number">22.04</span>：<br>./build-ubuntu-image.<span class="hljs-keyword">sh</span> jammy <span class="hljs-number">22.04</span><br><span class="hljs-number">3</span>. 构建 Ubuntu <span class="hljs-number">24.04</span>：<br>./build-ubuntu-image.<span class="hljs-keyword">sh</span> noble <span class="hljs-number">24.04</span><br><span class="hljs-number">4</span>. 查看镜像：<br>docker images<br><span class="hljs-number">5</span>. 启动容器并测试：<br>docker run -it my-ubuntu:<span class="hljs-number">22.04</span><br><br>在容器里 可以直接用：<br><span class="hljs-keyword">vim</span><br>curl https://www.google.<span class="hljs-keyword">com</span><br>ping baidu.<span class="hljs-keyword">com</span><br>netstat -tulnp<br></code></pre></td></tr></table></figure><h5 id="把脚本再升级一下加上-模式参数">4. 把脚本再升级一下，加上<strong>模式参数</strong></h5><ul><li><code>--minimal</code> ：只生成纯净的 Ubuntu 镜像</li><li><code>--full</code>：在镜像中预装常用工具（<code>vim curl wget iputils-ping net-tools</code>等）</li></ul><p>build-ubuntu-image.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">set</span> -e<br><br><span class="hljs-comment"># ==============================</span><br><span class="hljs-comment"># 一键构建 Ubuntu Docker 镜像</span><br><span class="hljs-comment"># 使用:</span><br><span class="hljs-comment">#   ./build-ubuntu-image.sh [release] [tag] [mode]</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 示例:</span><br><span class="hljs-comment">#   ./build-ubuntu-image.sh focal 20.04 --minimal</span><br><span class="hljs-comment">#   ./build-ubuntu-image.sh jammy 22.04 --full</span><br><span class="hljs-comment"># ==============================</span><br><br><span class="hljs-comment"># 默认参数</span><br>DEFAULT_RELEASE=focal<br>DEFAULT_TAG=20.04<br>DEFAULT_MODE=--full<br>ARCH=amd64<br>MIRROR=https://mirrors.tuna.tsinghua.edu.cn/ubuntu/   <span class="hljs-comment"># 清华源，国内快</span><br>ROOTFS_DIR=ubuntu-rootfs<br>IMAGE_NAME=my-ubuntu<br><br><span class="hljs-comment"># 读取用户输入</span><br>UBUNTU_RELEASE=<span class="hljs-variable">$&#123;1:-<span class="hljs-variable">$DEFAULT_RELEASE</span>&#125;</span><br>TAG=<span class="hljs-variable">$&#123;2:-<span class="hljs-variable">$DEFAULT_TAG</span>&#125;</span><br>MODE=<span class="hljs-variable">$&#123;3:-<span class="hljs-variable">$DEFAULT_MODE</span>&#125;</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;====== 构建 Ubuntu Docker 镜像 ======&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Ubuntu Release: <span class="hljs-variable">$UBUNTU_RELEASE</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Docker Tag: <span class="hljs-variable">$TAG</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;架构: <span class="hljs-variable">$ARCH</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;镜像源: <span class="hljs-variable">$MIRROR</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;模式: <span class="hljs-variable">$MODE</span>&quot;</span><br><span class="hljs-built_in">echo</span><br><br><span class="hljs-comment"># 检查 debootstrap 是否安装</span><br><span class="hljs-keyword">if</span> ! <span class="hljs-built_in">command</span> -v debootstrap &gt;/dev/null 2&gt;&amp;1; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;⚠️ 未找到 debootstrap，正在安装...&quot;</span><br>    sudo apt-get update &amp;&amp; sudo apt-get install -y debootstrap<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 创建 rootfs</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 开始构建 rootfs...&quot;</span><br>sudo <span class="hljs-built_in">rm</span> -rf <span class="hljs-variable">$ROOTFS_DIR</span><br>sudo debootstrap --<span class="hljs-built_in">arch</span>=<span class="hljs-variable">$ARCH</span> <span class="hljs-variable">$UBUNTU_RELEASE</span> <span class="hljs-variable">$ROOTFS_DIR</span> <span class="hljs-variable">$MIRROR</span><br><br><span class="hljs-comment"># 打包 rootfs 并导入临时镜像</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 打包 rootfs...&quot;</span><br>sudo tar -C <span class="hljs-variable">$ROOTFS_DIR</span> -c . | docker import - <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>-base:<span class="hljs-variable">$TAG</span><br><br><span class="hljs-comment"># 根据模式决定是否安装工具</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$MODE</span>&quot;</span> = <span class="hljs-string">&quot;--full&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 构建 FULL 模式镜像，安装常用工具...&quot;</span><br>    <span class="hljs-built_in">cat</span> &gt; Dockerfile &lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">FROM $&#123;IMAGE_NAME&#125;-base:$TAG</span><br><span class="hljs-string"></span><br><span class="hljs-string">ENV DEBIAN_FRONTEND=noninteractive TZ=Asia/Shanghai</span><br><span class="hljs-string"></span><br><span class="hljs-string">RUN apt-get update &amp;&amp; apt-get install -y \\</span><br><span class="hljs-string">    vim curl wget net-tools iputils-ping less lsb-release ca-certificates \\</span><br><span class="hljs-string">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="hljs-string"></span><br><span class="hljs-string">CMD [&quot;/bin/bash&quot;]</span><br><span class="hljs-string">EOF</span><br><br>    docker build -t <span class="hljs-variable">$IMAGE_NAME</span>:<span class="hljs-variable">$TAG</span> .<br>    <span class="hljs-built_in">rm</span> -f Dockerfile<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 构建 MINIMAL 模式镜像...&quot;</span><br>    docker tag <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>-base:<span class="hljs-variable">$TAG</span> <span class="hljs-variable">$IMAGE_NAME</span>:<span class="hljs-variable">$TAG</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 清理</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 清理临时文件...&quot;</span><br><span class="hljs-built_in">rm</span> -rf <span class="hljs-variable">$ROOTFS_DIR</span><br>docker rmi <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>-base:<span class="hljs-variable">$TAG</span> &gt;/dev/null 2&gt;&amp;1 || <span class="hljs-literal">true</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;✅ 镜像构建完成！&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;你现在可以运行: docker run -it <span class="hljs-variable">$IMAGE_NAME</span>:<span class="hljs-variable">$TAG</span> /bin/bash&quot;</span><br><br></code></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">1. 构建 Ubuntu 20.04 纯净版：<br>./build-ubuntu-image.sh focal 20.04 --minimal<br><br>2. 构建 Ubuntu 22.04 工具增强版：<br>./build-ubuntu-image.sh jammy 22.04 --full<br><br>3. 构建 Ubuntu 24.04（默认 FULL 模式）：<br>./build-ubuntu-image.sh noble 24.04<br><br>4. 查看镜像：<br>docker images<br>5. 启动容器并测试：<br>docker run -it my-ubuntu:22.04 /bin/bash<br><br></code></pre></td></tr></table></figure><h5 id="再升级脚本增加-自定义镜像名参数">4.1 再升级脚本，增加<strong>自定义镜像名参数</strong>。</h5><p>现在脚本支持四个参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">./build-ubuntu-image.sh [release] [tag] [mode] [imagename]<br><br></code></pre></td></tr></table></figure><p><code>release</code> ：Ubuntu 代号（默认 <code>focal</code>）</p><p><code>tag</code> ：镜像 tag（默认 <code>20.04</code>）</p><p><code>mode</code> ：<code>--minimal</code> 或<code>--full</code>（默认 <code>--full</code>）</p><p><code>imagename</code> ：自定义镜像名（默认<code>my-ubuntu</code>）</p><p>build-ubuntu-image.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">set</span> -e<br><br><span class="hljs-comment"># ==============================</span><br><span class="hljs-comment"># 一键构建 Ubuntu Docker 镜像</span><br><span class="hljs-comment"># 使用:</span><br><span class="hljs-comment">#   ./build-ubuntu-image.sh [release] [tag] [mode] [imagename]</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 示例:</span><br><span class="hljs-comment">#   ./build-ubuntu-image.sh focal 20.04 --minimal</span><br><span class="hljs-comment">#   ./build-ubuntu-image.sh jammy 22.04 --full my-ubuntu-dev</span><br><span class="hljs-comment"># ==============================</span><br><br><span class="hljs-comment"># 默认参数</span><br>DEFAULT_RELEASE=focal<br>DEFAULT_TAG=20.04<br>DEFAULT_MODE=--full<br>DEFAULT_IMAGE=my-ubuntu<br>ARCH=amd64<br>MIRROR=https://mirrors.tuna.tsinghua.edu.cn/ubuntu/   <span class="hljs-comment"># 清华源，国内快</span><br>ROOTFS_DIR=ubuntu-rootfs<br><br><span class="hljs-comment"># 读取用户输入</span><br>UBUNTU_RELEASE=<span class="hljs-variable">$&#123;1:-<span class="hljs-variable">$DEFAULT_RELEASE</span>&#125;</span><br>TAG=<span class="hljs-variable">$&#123;2:-<span class="hljs-variable">$DEFAULT_TAG</span>&#125;</span><br>MODE=<span class="hljs-variable">$&#123;3:-<span class="hljs-variable">$DEFAULT_MODE</span>&#125;</span><br>IMAGE_NAME=<span class="hljs-variable">$&#123;4:-<span class="hljs-variable">$DEFAULT_IMAGE</span>&#125;</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;====== 构建 Ubuntu Docker 镜像 ======&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Ubuntu Release : <span class="hljs-variable">$UBUNTU_RELEASE</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Docker Tag     : <span class="hljs-variable">$TAG</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;模式           : <span class="hljs-variable">$MODE</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;镜像名         : <span class="hljs-variable">$IMAGE_NAME</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;架构           : <span class="hljs-variable">$ARCH</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;镜像源         : <span class="hljs-variable">$MIRROR</span>&quot;</span><br><span class="hljs-built_in">echo</span><br><br><span class="hljs-comment"># 检查 debootstrap 是否安装</span><br><span class="hljs-keyword">if</span> ! <span class="hljs-built_in">command</span> -v debootstrap &gt;/dev/null 2&gt;&amp;1; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;⚠️ 未找到 debootstrap，正在安装...&quot;</span><br>    sudo apt-get update &amp;&amp; sudo apt-get install -y debootstrap<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 创建 rootfs</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 开始构建 rootfs...&quot;</span><br>sudo <span class="hljs-built_in">rm</span> -rf <span class="hljs-variable">$ROOTFS_DIR</span><br>sudo debootstrap --<span class="hljs-built_in">arch</span>=<span class="hljs-variable">$ARCH</span> <span class="hljs-variable">$UBUNTU_RELEASE</span> <span class="hljs-variable">$ROOTFS_DIR</span> <span class="hljs-variable">$MIRROR</span><br><br><span class="hljs-comment"># 打包 rootfs 并导入临时镜像</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 打包 rootfs...&quot;</span><br>sudo tar -C <span class="hljs-variable">$ROOTFS_DIR</span> -c . | docker import - <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>-base:<span class="hljs-variable">$TAG</span><br><br><span class="hljs-comment"># 根据模式决定是否安装工具</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$MODE</span>&quot;</span> = <span class="hljs-string">&quot;--full&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 构建 FULL 模式镜像，安装常用工具...&quot;</span><br>    <span class="hljs-built_in">cat</span> &gt; Dockerfile &lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">FROM $&#123;IMAGE_NAME&#125;-base:$TAG</span><br><span class="hljs-string"></span><br><span class="hljs-string">ENV DEBIAN_FRONTEND=noninteractive TZ=Asia/Shanghai</span><br><span class="hljs-string"></span><br><span class="hljs-string">RUN apt-get update &amp;&amp; apt-get install -y \\</span><br><span class="hljs-string">    vim curl wget net-tools iputils-ping less lsb-release ca-certificates \\</span><br><span class="hljs-string">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="hljs-string"></span><br><span class="hljs-string">CMD [&quot;/bin/bash&quot;]</span><br><span class="hljs-string">EOF</span><br><br>    docker build -t <span class="hljs-variable">$IMAGE_NAME</span>:<span class="hljs-variable">$TAG</span> .<br>    <span class="hljs-built_in">rm</span> -f Dockerfile<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 构建 MINIMAL 模式镜像...&quot;</span><br>    docker tag <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>-base:<span class="hljs-variable">$TAG</span> <span class="hljs-variable">$IMAGE_NAME</span>:<span class="hljs-variable">$TAG</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 清理</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 清理临时文件...&quot;</span><br><span class="hljs-built_in">rm</span> -rf <span class="hljs-variable">$ROOTFS_DIR</span><br>docker rmi <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>-base:<span class="hljs-variable">$TAG</span> &gt;/dev/null 2&gt;&amp;1 || <span class="hljs-literal">true</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;✅ 镜像构建完成！&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;你现在可以运行: docker run -it <span class="hljs-variable">$IMAGE_NAME</span>:<span class="hljs-variable">$TAG</span> /bin/bash&quot;</span><br><br></code></pre></td></tr></table></figure><p>使用方法:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1.</span> 构建 Ubuntu <span class="hljs-number">20.04</span> 纯净版（默认镜像名 <span class="hljs-keyword">my</span>-ubuntu）：<br>./build-ubuntu-image.sh focal <span class="hljs-number">20.04</span> <span class="hljs-comment">--minimal</span><br><br><span class="hljs-number">2.</span> 构建 Ubuntu <span class="hljs-number">22.04</span> 工具增强版，镜像名自定义为 <span class="hljs-keyword">my</span>-ubuntu-dev：<br>./build-ubuntu-image.sh jammy <span class="hljs-number">22.04</span> <span class="hljs-comment">--full my-ubuntu-dev</span><br><br><span class="hljs-number">3.</span> 构建 Ubuntu <span class="hljs-number">24.04</span>，保持默认（full 模式，镜像名 <span class="hljs-keyword">my</span>-ubuntu）：<br>./build-ubuntu-image.sh noble <span class="hljs-number">24.04</span><br><br><span class="hljs-number">4.</span> 查看镜像：<br>docker images<br><span class="hljs-number">5.</span> 启动容器并测试：<br>docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-keyword">my</span>-ubuntu-dev:<span class="hljs-number">22.04</span> /bin/bash<br></code></pre></td></tr></table></figure><h5 id="全自动化脚本一键生成-ubuntu-docker-镜像支持">5.<strong>全自动化脚本</strong>，一键生成 Ubuntu Docker 镜像，支持：</h5><ul><li>选择 Ubuntu 版本（focal / jammy / noble）</li><li>选择模式：<code>--minimal</code> 或<code>--full</code>（是否预装常用工具）</li><li>自定义 Docker 镜像名称</li><li>可自定义 apt 镜像源（国内/官方）</li></ul><p>build-ubuntu-image.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>set -e<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">==============================</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">一键构建 Ubuntu Docker 镜像</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  ./build-ubuntu-image.sh [release] [tag] [mode] [imagename] [mirror]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  ./build-ubuntu-image.sh jammy 22.04 --full my-ubuntu-dev https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">==============================</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">默认参数</span><br>DEFAULT_RELEASE=focal<br>DEFAULT_TAG=20.04<br>DEFAULT_MODE=--full<br>DEFAULT_IMAGE=my-ubuntu<br>DEFAULT_MIRROR=https://mirrors.tuna.tsinghua.edu.cn/ubuntu/<br>ARCH=amd64<br>ROOTFS_DIR=ubuntu-rootfs<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">读取参数</span><br>UBUNTU_RELEASE=$&#123;1:-$DEFAULT_RELEASE&#125;<br>TAG=$&#123;2:-$DEFAULT_TAG&#125;<br>MODE=$&#123;3:-$DEFAULT_MODE&#125;<br>IMAGE_NAME=$&#123;4:-$DEFAULT_IMAGE&#125;<br>MIRROR=$&#123;5:-$DEFAULT_MIRROR&#125;<br><br>echo &quot;====== 构建 Ubuntu Docker 镜像 ======&quot;<br>echo &quot;Ubuntu Release : $UBUNTU_RELEASE&quot;<br>echo &quot;Docker Tag     : $TAG&quot;<br>echo &quot;模式           : $MODE&quot;<br>echo &quot;镜像名         : $IMAGE_NAME&quot;<br>echo &quot;APT 镜像源     : $MIRROR&quot;<br>echo &quot;架构           : $ARCH&quot;<br>echo<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查 debootstrap 是否安装</span><br>if ! command -v debootstrap &gt;/dev/null 2&gt;&amp;1; then<br>    echo &quot;⚠️ 未找到 debootstrap，正在安装...&quot;<br>    sudo apt-get update &amp;&amp; sudo apt-get install -y debootstrap<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 rootfs</span><br>echo &quot;👉 开始构建 rootfs...&quot;<br>sudo rm -rf $ROOTFS_DIR<br>sudo debootstrap --arch=$ARCH $UBUNTU_RELEASE $ROOTFS_DIR $MIRROR<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打包 rootfs 并导入临时镜像</span><br>echo &quot;👉 打包 rootfs...&quot;<br>sudo tar -C $ROOTFS_DIR -c . | docker import - $&#123;IMAGE_NAME&#125;-base:$TAG<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">根据模式决定是否安装工具</span><br>if [ &quot;$MODE&quot; = &quot;--full&quot; ]; then<br>    echo &quot;👉 构建 FULL 模式镜像，安装常用工具...&quot;<br>    cat &gt; Dockerfile &lt;&lt;EOF<br>FROM $&#123;IMAGE_NAME&#125;-base:$TAG<br><br>ENV DEBIAN_FRONTEND=noninteractive TZ=Asia/Shanghai<br><br>RUN apt-get update &amp;&amp; apt-get install -y \\<br>    vim curl wget net-tools iputils-ping less lsb-release ca-certificates \\<br>    &amp;&amp; rm -rf /var/lib/apt/lists/*<br><br>CMD [&quot;/bin/bash&quot;]<br>EOF<br><br>    docker build -t $IMAGE_NAME:$TAG .<br>    rm -f Dockerfile<br>else<br>    echo &quot;👉 构建 MINIMAL 模式镜像...&quot;<br>    docker tag $&#123;IMAGE_NAME&#125;-base:$TAG $IMAGE_NAME:$TAG<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">清理</span><br>echo &quot;👉 清理临时文件...&quot;<br>rm -rf $ROOTFS_DIR<br>docker rmi $&#123;IMAGE_NAME&#125;-base:$TAG &gt;/dev/null 2&gt;&amp;1 || true<br><br>echo &quot;✅ 镜像构建完成！&quot;<br>echo &quot;你现在可以运行: docker run -it $IMAGE_NAME:$TAG /bin/bash&quot;<br><br></code></pre></td></tr></table></figure><p>使用方法:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">构建 Ubuntu 20.04 最小版：<br><br><span class="hljs-string">./build-ubuntu-image.sh</span> focal 20.04 <span class="hljs-params">--minimal</span><br><br><br>构建 Ubuntu 22.04 工具增强版，自定义镜像名 my-ubuntu-dev：<br><br><span class="hljs-string">./build-ubuntu-image.sh</span> jammy 22.04 <span class="hljs-params">--full</span> my-ubuntu-dev<br><br><br>构建 Ubuntu 24.04，使用阿里云镜像源：<br><br><span class="hljs-string">./build-ubuntu-image.sh</span> noble 24.04 <span class="hljs-params">--full</span> my-ubuntu-24 https:<span class="hljs-string">//mirrors.aliyun.com/ubuntu/</span><br><br><br>查看镜像：<br><br>docker images<br><br><br>启动容器：<br><br>docker run -it my-ubuntu-dev<span class="hljs-function">:22.04</span> <span class="hljs-string">/bin/bash</span><br></code></pre></td></tr></table></figure><h4 id="问题排查">问题排查</h4><p>如果你在执行脚本过程中，遇到 E: No such script:/usr/share/debootstrap/scripts/focal 这个错误。 说明<strong>你的系统里debootstrap 没有 focal 的脚本</strong>。这是 debootstrap的常见问题，尤其在一些老版本或非 Ubuntu 系统上。可以这样解决：</p><ol type="1"><li><p>解决方法一：安装最新版 debootstrap</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> update<br>sudo apt-<span class="hljs-built_in">get</span> install -y debootstrap<br><br></code></pre></td></tr></table></figure></li><li><p>解决方法二：使用现有脚本代替</p><p>如果你没有 <code>focal</code>，可以使用类似版本（例如<code>jammy</code> 或 <code>bionic</code>）来代替：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo debootstrap --<span class="hljs-built_in">arch</span>=amd64 jammy ./ubuntu-rootfs https://mirrors.tuna.tsinghua.edu.cn/ubuntu/<br></code></pre></td></tr></table></figure><blockquote><p>注：Jammy = 22.04，Bionic = 18.04</p></blockquote></li><li><p>解决方法三：手动下载脚本</p><p>如果非 Ubuntu 系统，也可以手动下载 debootstrap 脚本：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo wget https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/debootstrap/</span>debootstrap<span class="hljs-regexp">/master/</span>scripts<span class="hljs-regexp">/focal -O /u</span>sr<span class="hljs-regexp">/share/</span>debootstrap<span class="hljs-regexp">/scripts/</span>focal<br></code></pre></td></tr></table></figure><p>然后就可以用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo debootstrap --<span class="hljs-built_in">arch</span>=amd64 focal ./ubuntu-rootfs http://archive.ubuntu.com/ubuntu/<br></code></pre></td></tr></table></figure></li></ol><h4 id="改进1">改进1</h4><p>升级脚本，让它 <strong>即使系统 debootstrap没有指定版本</strong>，也能自动下载对应的脚本来构建 rootfs，从而支持任意Ubuntu 版本。</p><p>build-ubuntu-image.sh（支持自动下载 debootstrap 脚本）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">set</span> -e<br><br><span class="hljs-comment"># ==============================</span><br><span class="hljs-comment"># 一键构建 Ubuntu Docker 镜像（自动下载缺失 debootstrap 脚本）</span><br><span class="hljs-comment"># 使用:</span><br><span class="hljs-comment">#   ./build-ubuntu-image.sh [release] [tag] [mode] [imagename] [mirror]</span><br><span class="hljs-comment"># 示例:</span><br><span class="hljs-comment">#   ./build-ubuntu-image.sh jammy 22.04 --full my-ubuntu-dev</span><br><span class="hljs-comment"># ==============================</span><br><br><span class="hljs-comment"># 默认参数</span><br>DEFAULT_RELEASE=focal<br>DEFAULT_TAG=20.04<br>DEFAULT_MODE=--full<br>DEFAULT_IMAGE=my-ubuntu<br>DEFAULT_MIRROR=https://mirrors.tuna.tsinghua.edu.cn/ubuntu/<br>ARCH=amd64<br>ROOTFS_DIR=ubuntu-rootfs<br>SCRIPTS_DIR=/usr/share/debootstrap/scripts<br>DEBOOTSTRAP_GIT=https://raw.githubusercontent.com/debootstrap/debootstrap/master/scripts<br><br><span class="hljs-comment"># 读取参数</span><br>USER_RELEASE=<span class="hljs-variable">$&#123;1:-<span class="hljs-variable">$DEFAULT_RELEASE</span>&#125;</span><br>TAG=<span class="hljs-variable">$&#123;2:-<span class="hljs-variable">$DEFAULT_TAG</span>&#125;</span><br>MODE=<span class="hljs-variable">$&#123;3:-<span class="hljs-variable">$DEFAULT_MODE</span>&#125;</span><br>IMAGE_NAME=<span class="hljs-variable">$&#123;4:-<span class="hljs-variable">$DEFAULT_IMAGE</span>&#125;</span><br>MIRROR=<span class="hljs-variable">$&#123;5:-<span class="hljs-variable">$DEFAULT_MIRROR</span>&#125;</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;====== 构建 Ubuntu Docker 镜像 ======&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;用户输入版本 : <span class="hljs-variable">$USER_RELEASE</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Docker Tag    : <span class="hljs-variable">$TAG</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;模式          : <span class="hljs-variable">$MODE</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;镜像名        : <span class="hljs-variable">$IMAGE_NAME</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;APT 镜像源    : <span class="hljs-variable">$MIRROR</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;架构          : <span class="hljs-variable">$ARCH</span>&quot;</span><br><span class="hljs-built_in">echo</span><br><br><span class="hljs-comment"># 检查 debootstrap 是否安装</span><br><span class="hljs-keyword">if</span> ! <span class="hljs-built_in">command</span> -v debootstrap &gt;/dev/null 2&gt;&amp;1; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;⚠️ 未找到 debootstrap，正在安装...&quot;</span><br>    sudo apt-get update &amp;&amp; sudo apt-get install -y debootstrap wget<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 检查脚本是否存在</span><br><span class="hljs-keyword">if</span> [ ! -f <span class="hljs-string">&quot;<span class="hljs-variable">$SCRIPTS_DIR</span>/<span class="hljs-variable">$USER_RELEASE</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;⚠️ debootstrap 脚本 <span class="hljs-variable">$USER_RELEASE</span> 不存在，自动下载...&quot;</span><br>    sudo wget -O <span class="hljs-string">&quot;<span class="hljs-variable">$SCRIPTS_DIR</span>/<span class="hljs-variable">$USER_RELEASE</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$DEBOOTSTRAP_GIT</span>/<span class="hljs-variable">$USER_RELEASE</span>&quot;</span><br>    <span class="hljs-keyword">if</span> [ $? -ne 0 ]; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;❌ 下载失败，请检查网络或版本名是否正确。&quot;</span><br>        <span class="hljs-built_in">exit</span> 1<br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 创建 rootfs</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 开始构建 rootfs...&quot;</span><br>sudo <span class="hljs-built_in">rm</span> -rf <span class="hljs-variable">$ROOTFS_DIR</span><br>sudo debootstrap --<span class="hljs-built_in">arch</span>=<span class="hljs-variable">$ARCH</span> <span class="hljs-variable">$USER_RELEASE</span> <span class="hljs-variable">$ROOTFS_DIR</span> <span class="hljs-variable">$MIRROR</span><br><br><span class="hljs-comment"># 打包 rootfs 并导入临时镜像</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 打包 rootfs...&quot;</span><br>sudo tar -C <span class="hljs-variable">$ROOTFS_DIR</span> -c . | docker import - <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>-base:<span class="hljs-variable">$TAG</span><br><br><span class="hljs-comment"># 根据模式决定是否安装工具</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$MODE</span>&quot;</span> = <span class="hljs-string">&quot;--full&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 构建 FULL 模式镜像，安装常用工具...&quot;</span><br>    <span class="hljs-built_in">cat</span> &gt; Dockerfile &lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">FROM $&#123;IMAGE_NAME&#125;-base:$TAG</span><br><span class="hljs-string"></span><br><span class="hljs-string">ENV DEBIAN_FRONTEND=noninteractive TZ=Asia/Shanghai</span><br><span class="hljs-string"></span><br><span class="hljs-string">RUN apt-get update &amp;&amp; apt-get install -y \\</span><br><span class="hljs-string">    vim curl wget net-tools iputils-ping less lsb-release ca-certificates \\</span><br><span class="hljs-string">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="hljs-string"></span><br><span class="hljs-string">CMD [&quot;/bin/bash&quot;]</span><br><span class="hljs-string">EOF</span><br><br>    docker build -t <span class="hljs-variable">$IMAGE_NAME</span>:<span class="hljs-variable">$TAG</span> .<br>    <span class="hljs-built_in">rm</span> -f Dockerfile<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 构建 MINIMAL 模式镜像...&quot;</span><br>    docker tag <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>-base:<span class="hljs-variable">$TAG</span> <span class="hljs-variable">$IMAGE_NAME</span>:<span class="hljs-variable">$TAG</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 清理</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 清理临时文件...&quot;</span><br><span class="hljs-built_in">rm</span> -rf <span class="hljs-variable">$ROOTFS_DIR</span><br>docker rmi <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>-base:<span class="hljs-variable">$TAG</span> &gt;/dev/null 2&gt;&amp;1 || <span class="hljs-literal">true</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;✅ 镜像构建完成！&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;你现在可以运行: docker run -it <span class="hljs-variable">$IMAGE_NAME</span>:<span class="hljs-variable">$TAG</span> /bin/bash&quot;</span><br><br></code></pre></td></tr></table></figure><p>使用实例</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">构建 Ubuntu 20.04 FULL 模式：<br><br><span class="hljs-string">./build-ubuntu-image.sh</span> focal 20.04 <span class="hljs-params">--full</span> my-ubuntu-dev<br><br><br>构建 Ubuntu 22.04 MINIMAL 模式：<br><br><span class="hljs-string">./build-ubuntu-image.sh</span> jammy 22.04 <span class="hljs-params">--minimal</span> my-ubuntu-22<br><br><br>构建 Ubuntu 24.04，使用阿里云镜像源：<br><br><span class="hljs-string">./build-ubuntu-image.sh</span> noble 24.04 <span class="hljs-params">--full</span> my-ubuntu-24 https:<span class="hljs-string">//mirrors.aliyun.com/ubuntu/</span><br></code></pre></td></tr></table></figure><p>自动检测 debootstrap 脚本是否存在</p><p>不存在时自动从 GitHub 下载最新脚本</p><p>支持自定义 Ubuntu 版本、镜像名、模式（minimal/full）</p><p>支持自定义 apt 镜像源</p><p>FULL 模式会安装常用工具</p><p>执行上述脚本出现https://raw.githubusercontent.com/debootstrap/debootstrap/master/scripts404 由于 Ubuntu 官方的 debootstrap 脚本已不再维护 Ubuntu Focal（20.04LTS），导致 <code>/usr/share/debootstrap/scripts/focal</code>文件缺失。因此，无法直接使用 debootstrap 构建 Ubuntu 20.04 的rootfs。</p><h4 id="改进2">改进2</h4><p>面临的问题：</p><ul><li>debootstrap 默认脚本可能缺失</li><li><strong>无法访问 Docker Hub</strong>，所以不能直接<code>docker pull ubuntu:20.04</code></li><li>目标是 <strong>构建可用的 Ubuntu 镜像</strong></li></ul><p>在这种情况下，可以通过 <strong>离线方式</strong> 构建 Ubuntu Docker镜像</p><p>使用官方 Ubuntu 根文件系统 tar 包（推荐）</p><p>Ubuntu 官方提供 <strong>rootfs tarball</strong>，可以离线下载：</p><ul><li>官网地址（可在可访问网络的机器下载，再传到目标机）：<ul><li>https://partner-images.canonical.com/core/focal/current/</li><li>文件示例：<code>ubuntu-20.04-core-cloudimg-amd64-root.tar.gz</code></li></ul></li></ul><p>构建流程</p><ol type="1"><li><p>下载 tar 包到目标机（通过 U 盘、内网服务器等方式传输）。</p></li><li><p>导入 Docker：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> import ubuntu-<span class="hljs-number">20</span>.<span class="hljs-number">04</span>-core-cloudimg-amd64-root.tar.gz my-ubuntu:<span class="hljs-number">20</span>.<span class="hljs-number">04</span><br></code></pre></td></tr></table></figure></li><li><p>验证：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-keyword">my</span>-ubuntu:<span class="hljs-number">20.04</span> /bin/bash<br></code></pre></td></tr></table></figure></li><li><p>可选：在 Dockerfile 中基于此镜像安装常用工具：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> my-ubuntu:<span class="hljs-number">20.04</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y vim curl wget iputils-ping net-tools &amp;&amp; <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/bash&quot;</span>]</span><br></code></pre></td></tr></table></figure></li></ol><p>✅ 优点：完全离线、可控、官方支持 ⚠️ 缺点：需要先下载 tar 包</p><p>2️⃣ 使用 <code>debootstrap</code> 离线构建（非 Ubuntu 系统）</p><p>即使你的系统不是 Ubuntu，也可以：</p><ol type="1"><li><p>在可联网的 Ubuntu 系统上运行 <code>debootstrap</code> 构建rootfs：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo debootstrap --<span class="hljs-built_in">arch</span>=amd64 focal ./ubuntu-rootfs http://archive.ubuntu.com/ubuntu/<br></code></pre></td></tr></table></figure></li><li><p>打包 rootfs：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">sudo tar -C ./ubuntu-rootfs -c . <span class="hljs-string">| gzip &gt; ubuntu-focal-rootfs.tar.gz</span><br></code></pre></td></tr></table></figure></li><li><p>复制 tar 包到目标系统。</p></li><li><p>导入 Docker：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cat</span> ubuntu-focal-rootfs.tar.gz | docker import - my-ubuntu:<span class="hljs-number">20</span>.<span class="hljs-number">04</span><br></code></pre></td></tr></table></figure></li></ol><p>✅ 优点：完全离线，支持任意系统 ⚠️ 缺点：需要额外的 Ubuntu 环境生成rootfs</p><p>3️⃣ 使用现有 ISO 离线构建</p><ol type="1"><li><p>下载 Ubuntu Server ISO（例如<code>ubuntu-20.04-live-server-amd64.iso</code>）</p></li><li><p>挂载 ISO：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> mount -o loop ubuntu-<span class="hljs-number">20</span>.<span class="hljs-number">04</span>.iso /mnt<br></code></pre></td></tr></table></figure></li><li><p>提取 squashfs 文件系统：</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nsis">sudo unsquashfs -d ubuntu-rootfs /mnt/casper/<span class="hljs-keyword">file</span><span class="hljs-params">system</span>.squashfs<br></code></pre></td></tr></table></figure></li><li><p>打包 rootfs：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> tar -C ubuntu-rootfs -c . | docker import - my-ubuntu:<span class="hljs-number">20</span>.<span class="hljs-number">04</span><br></code></pre></td></tr></table></figure></li></ol><p>✅ 优点：完全离线，不依赖 Docker Hub ⚠️ 缺点：ISO提取可能比较复杂</p><p>💡 总结</p><table><thead><tr><th>方法</th><th>是否可离线</th><th>是否官方支持</th><th>难易度</th></tr></thead><tbody><tr><td>官方 rootfs tar</td><td>✅</td><td>✅</td><td>简单</td></tr><tr><td>debootstrap 离线</td><td>✅</td><td>✅</td><td>中等，需要 Ubuntu 环境</td></tr><tr><td>ISO 提取</td><td>✅</td><td>✅</td><td>较复杂</td></tr></tbody></table><p>完整脚本（带本机缓存管理）offline-ubuntu-docker-auto-v4.sh</p><p>每次构建镜像时，会在 <code>$HOME/.offline-ubuntu-cache</code> 保存rootfs</p><p>下次同版本同架构直接使用缓存</p><p>自动删除超过 N 天的老缓存（避免占用过多磁盘空间）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">set</span> -e<br><br><span class="hljs-comment"># ==============================</span><br><span class="hljs-comment"># 离线构建 Ubuntu Docker 镜像（自动检测版本/架构，FULL 模式安装工具，本机缓存管理）</span><br><span class="hljs-comment"># 使用:</span><br><span class="hljs-comment">#   ./offline-ubuntu-docker-auto-v4.sh &lt;source&gt; &lt;type&gt; &lt;tag&gt; &lt;mode&gt; &lt;imagename&gt;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 参数:</span><br><span class="hljs-comment">#   source    : rootfs tar 文件路径 或 ISO 文件路径</span><br><span class="hljs-comment">#   type      : tar 或 iso</span><br><span class="hljs-comment">#   tag       : Docker 镜像 tag (如 20.04)</span><br><span class="hljs-comment">#   mode      : --minimal 或 --full</span><br><span class="hljs-comment">#   imagename : Docker 镜像名 (默认 my-ubuntu)</span><br><span class="hljs-comment"># ==============================</span><br><br>SOURCE_FILE=<span class="hljs-variable">$1</span><br>TYPE=<span class="hljs-variable">$2</span><br>TAG=<span class="hljs-variable">$&#123;3:-latest&#125;</span><br>MODE=<span class="hljs-variable">$&#123;4:---full&#125;</span><br>IMAGE_NAME=<span class="hljs-variable">$&#123;5:-my-ubuntu&#125;</span><br>CACHE_DIR=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.offline-ubuntu-cache&quot;</span><br>ROOTFS_DIR=<span class="hljs-string">&quot;<span class="hljs-variable">$CACHE_DIR</span>/rootfs-<span class="hljs-variable">$TAG</span>&quot;</span><br>CACHE_MAX_DAYS=30   <span class="hljs-comment"># 自动清理超过30天的缓存</span><br><br><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$SOURCE_FILE</span>&quot;</span> ] || [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$TYPE</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;❌ 参数错误！请提供 source 文件路径和类型 (tar/iso)&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$CACHE_DIR</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;====== 离线构建 Ubuntu Docker 镜像 ======&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;源文件       : <span class="hljs-variable">$SOURCE_FILE</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;类型         : <span class="hljs-variable">$TYPE</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Docker Tag   : <span class="hljs-variable">$TAG</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;模式         : <span class="hljs-variable">$MODE</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;镜像名       : <span class="hljs-variable">$IMAGE_NAME</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;缓存目录     : <span class="hljs-variable">$CACHE_DIR</span>&quot;</span><br><span class="hljs-built_in">echo</span><br><br><span class="hljs-comment"># 清理过期缓存</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 清理超过 <span class="hljs-variable">$CACHE_MAX_DAYS</span> 天的缓存...&quot;</span><br>find <span class="hljs-variable">$CACHE_DIR</span> -maxdepth 1 -<span class="hljs-built_in">type</span> d -name <span class="hljs-string">&quot;rootfs-*&quot;</span> -mtime +<span class="hljs-variable">$CACHE_MAX_DAYS</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">rm</span> -rf &#123;&#125; \;<br><br><span class="hljs-comment"># 检查缓存</span><br><span class="hljs-keyword">if</span> [ -d <span class="hljs-string">&quot;<span class="hljs-variable">$ROOTFS_DIR</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;✅ 检测到缓存 rootfs，直接使用缓存...&quot;</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment"># 清理旧 rootfs</span><br>    <span class="hljs-built_in">rm</span> -rf <span class="hljs-variable">$ROOTFS_DIR</span><br>    <span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$ROOTFS_DIR</span><br><br>    <span class="hljs-comment"># 提取 rootfs</span><br>    <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$TYPE</span>&quot;</span> = <span class="hljs-string">&quot;tar&quot;</span> ]; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 导入 rootfs tar...&quot;</span><br>        sudo tar -C <span class="hljs-variable">$ROOTFS_DIR</span> -xf <span class="hljs-variable">$SOURCE_FILE</span><br>    <span class="hljs-keyword">elif</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$TYPE</span>&quot;</span> = <span class="hljs-string">&quot;iso&quot;</span> ]; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 挂载 ISO 提取 squashfs...&quot;</span><br>        MOUNT_DIR=<span class="hljs-string">&quot;<span class="hljs-variable">$CACHE_DIR</span>/iso-mount-<span class="hljs-variable">$TAG</span>&quot;</span><br>        <span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$MOUNT_DIR</span><br>        sudo mount -o loop <span class="hljs-variable">$SOURCE_FILE</span> <span class="hljs-variable">$MOUNT_DIR</span><br>        <span class="hljs-keyword">if</span> [ ! -f <span class="hljs-string">&quot;<span class="hljs-variable">$MOUNT_DIR</span>/casper/filesystem.squashfs&quot;</span> ]; <span class="hljs-keyword">then</span><br>            <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;❌ ISO 中未找到 casper/filesystem.squashfs&quot;</span><br>            <span class="hljs-built_in">exit</span> 1<br>        <span class="hljs-keyword">fi</span><br>        sudo unsquashfs -d <span class="hljs-variable">$ROOTFS_DIR</span> <span class="hljs-variable">$MOUNT_DIR</span>/casper/filesystem.squashfs<br>        sudo umount <span class="hljs-variable">$MOUNT_DIR</span><br>        <span class="hljs-built_in">rm</span> -rf <span class="hljs-variable">$MOUNT_DIR</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;❌ 类型必须是 tar 或 iso&quot;</span><br>        <span class="hljs-built_in">exit</span> 1<br>    <span class="hljs-keyword">fi</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;✅ rootfs 已缓存到 <span class="hljs-variable">$ROOTFS_DIR</span>&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 自动检测 Ubuntu 版本</span><br><span class="hljs-keyword">if</span> [ -f <span class="hljs-string">&quot;<span class="hljs-variable">$ROOTFS_DIR</span>/etc/os-release&quot;</span> ]; <span class="hljs-keyword">then</span><br>    UBUNTU_VERSION=$(grep <span class="hljs-string">&#x27;VERSION_ID=&#x27;</span> <span class="hljs-variable">$ROOTFS_DIR</span>/etc/os-release | <span class="hljs-built_in">cut</span> -d <span class="hljs-string">&#x27;&quot;&#x27;</span> -f2)<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 检测到 Ubuntu 版本: <span class="hljs-variable">$UBUNTU_VERSION</span>&quot;</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;⚠️ 无法检测 Ubuntu 版本，使用默认 tag: <span class="hljs-variable">$TAG</span>&quot;</span><br>    UBUNTU_VERSION=<span class="hljs-variable">$TAG</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 自动检测架构</span><br><span class="hljs-keyword">if</span> [ -f <span class="hljs-string">&quot;<span class="hljs-variable">$ROOTFS_DIR</span>/usr/bin/file&quot;</span> ]; <span class="hljs-keyword">then</span><br>    ARCH=$(file -bL <span class="hljs-variable">$ROOTFS_DIR</span>/bin/bash | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>)<br><span class="hljs-keyword">else</span><br>    ARCH=<span class="hljs-string">&quot;amd64&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 检测到架构: <span class="hljs-variable">$ARCH</span>&quot;</span><br><br><span class="hljs-comment"># 导入临时 Docker 镜像</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 导入 Docker 临时镜像...&quot;</span><br>sudo tar -C <span class="hljs-variable">$ROOTFS_DIR</span> -c . | docker import - <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>-base:<span class="hljs-variable">$UBUNTU_VERSION</span><br><br><span class="hljs-comment"># FULL 模式安装常用工具</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$MODE</span>&quot;</span> = <span class="hljs-string">&quot;--full&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 FULL 模式: 安装常用工具...&quot;</span><br>    <span class="hljs-built_in">cat</span> &gt; Dockerfile &lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">FROM $&#123;IMAGE_NAME&#125;-base:$UBUNTU_VERSION</span><br><span class="hljs-string">ENV DEBIAN_FRONTEND=noninteractive TZ=Asia/Shanghai</span><br><span class="hljs-string">RUN dpkg --add-architecture $ARCH || true</span><br><span class="hljs-string">RUN apt-get update &amp;&amp; apt-get install -y \\</span><br><span class="hljs-string">    vim curl wget net-tools iputils-ping less lsb-release ca-certificates \\</span><br><span class="hljs-string">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="hljs-string">CMD [&quot;/bin/bash&quot;]</span><br><span class="hljs-string">EOF</span><br><br>    docker build -t <span class="hljs-variable">$IMAGE_NAME</span>:<span class="hljs-variable">$UBUNTU_VERSION</span> .<br>    <span class="hljs-built_in">rm</span> -f Dockerfile<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 MINIMAL 模式: 不安装额外工具&quot;</span><br>    docker tag <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>-base:<span class="hljs-variable">$UBUNTU_VERSION</span> <span class="hljs-variable">$IMAGE_NAME</span>:<span class="hljs-variable">$UBUNTU_VERSION</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 清理临时镜像</span><br>docker rmi <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>-base:<span class="hljs-variable">$UBUNTU_VERSION</span> &gt;/dev/null 2&gt;&amp;1 || <span class="hljs-literal">true</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;✅ 镜像构建完成！&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;运行示例: docker run -it <span class="hljs-variable">$IMAGE_NAME</span>:<span class="hljs-variable">$UBUNTU_VERSION</span> /bin/bash&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;缓存 rootfs 路径: <span class="hljs-variable">$ROOTFS_DIR</span>&quot;</span><br><br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus">使用 tar 构建 FULL 模式<br><br>./offline-ubuntu-docker-auto-v4<span class="hljs-selector-class">.sh</span> ubuntu-<span class="hljs-number">20.04</span>-core-rootfs<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> tar <span class="hljs-number">20.04</span> <span class="hljs-attr">--full</span> my-ubuntu<br><br><br>使用 ISO 构建 MINIMAL 模式<br><br>./offline-ubuntu-docker-auto-v4<span class="hljs-selector-class">.sh</span> ubuntu-<span class="hljs-number">22.04</span>-live-server-amd64<span class="hljs-selector-class">.iso</span> iso <span class="hljs-number">22.04</span> <span class="hljs-attr">--minimal</span> my-ubuntu<br><br><br>运行容器<br><br>docker run -it my-ubuntu:<span class="hljs-number">20.04</span> /bin/bash<br><br></code></pre></td></tr></table></figure><p>新增功能</p><ul><li><strong>本机缓存管理</strong>：<code>$HOME/.offline-ubuntu-cache</code></li><li>自动清理 <strong>超过 30 天的旧 rootfs</strong></li><li>下次构建同版本直接使用缓存，速度极快</li><li>FULL 模式自动安装工具，并支持自动检测架构</li></ul><h4 id="改进3">改进3</h4><p>执行上述脚本 出现 “container_linux.go:247: starting container processcaused "exec: "/bin/sh": stat /bin/sh: no such file or directory" ociruntime error: container_linux.go:247: starting container process caused"exec: "/bin/sh": stat /bin/sh: no such file or directory"” 错误。</p><p>说明 <strong>Docker 容器里没有 <code>/bin/sh</code>或者路径不对</strong>。常见原因和解决方法如下：</p><p>1.<strong>rootfs 或 ISO 不是完整的 Ubuntu 根文件系统</strong></p><ul><li>有些 ISO（比如 LiveISO）里面的根文件系统不是标准路径，或者是只读压缩系统（squashfs）未正确解压。</li><li>导入 Docker 后 <code>/bin/sh</code>可能不存在，导致容器无法启动。</li></ul><p>2.<strong>解压或导入过程出错</strong></p><ul><li>可能你导入了部分文件夹，缺少 <code>/bin/bash</code> 或<code>/bin/sh</code>。</li><li>使用 tar 导入时，需要确保 <code>tar -C &lt;dir&gt; -c .</code>的路径是 <strong>完整 rootfs</strong> 根目录。</li></ul><p>3.<strong>架构不匹配</strong></p><ul><li>比如你导入了 <code>arm64</code> rootfs，在 x86_64 Docker上运行，容器无法启动。</li></ul><p>把脚本升级，保证导入 Docker 的 rootfs <strong>一定包含<code>/bin/bash</code> 或 <code>/bin/sh</code></strong>，并在 FULL模式下自动验证架构和 shell。</p><p>同时，如果 shell 不存在，脚本会自动提示并停止，避免容器启动失败。</p><p>offline-ubuntu-docker-safe.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>set -e<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">==============================</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">离线构建 Ubuntu Docker 镜像（保证 /bin/sh 或 /bin/bash 存在）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">自动检测版本/架构，FULL 模式安装工具，本机缓存管理</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  ./offline-ubuntu-docker-safe.sh &lt;<span class="hljs-built_in">source</span>&gt; &lt;<span class="hljs-built_in">type</span>&gt; &lt;tag&gt; &lt;mode&gt; &lt;imagename&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">==============================</span><br><br>SOURCE_FILE=$1<br>TYPE=$2<br>TAG=$&#123;3:-latest&#125;<br>MODE=$&#123;4:---full&#125;<br>IMAGE_NAME=$&#123;5:-my-ubuntu&#125;<br>CACHE_DIR=&quot;$HOME/.offline-ubuntu-cache&quot;<br>ROOTFS_DIR=&quot;$CACHE_DIR/rootfs-$TAG&quot;<br>CACHE_MAX_DAYS=30   # 自动清理超过30天的缓存<br><br>if [ -z &quot;$SOURCE_FILE&quot; ] || [ -z &quot;$TYPE&quot; ]; then<br>    echo &quot;❌ 参数错误！请提供 source 文件路径和类型 (tar/iso)&quot;<br>    exit 1<br>fi<br><br>mkdir -p $CACHE_DIR<br><br>echo &quot;====== 离线构建 Ubuntu Docker 镜像 ======&quot;<br>echo &quot;源文件       : $SOURCE_FILE&quot;<br>echo &quot;类型         : $TYPE&quot;<br>echo &quot;Docker Tag   : $TAG&quot;<br>echo &quot;模式         : $MODE&quot;<br>echo &quot;镜像名       : $IMAGE_NAME&quot;<br>echo &quot;缓存目录     : $CACHE_DIR&quot;<br>echo<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">清理过期缓存</span><br>echo &quot;👉 清理超过 $CACHE_MAX_DAYS 天的缓存...&quot;<br>find $CACHE_DIR -maxdepth 1 -type d -name &quot;rootfs-*&quot; -mtime +$CACHE_MAX_DAYS -exec rm -rf &#123;&#125; \;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查缓存</span><br>if [ -d &quot;$ROOTFS_DIR&quot; ]; then<br>    echo &quot;✅ 检测到缓存 rootfs，直接使用缓存...&quot;<br>else<br>    rm -rf $ROOTFS_DIR<br>    mkdir -p $ROOTFS_DIR<br><br>    # 提取 rootfs<br>    if [ &quot;$TYPE&quot; = &quot;tar&quot; ]; then<br>        echo &quot;👉 导入 rootfs tar...&quot;<br>        sudo tar -C $ROOTFS_DIR -xf $SOURCE_FILE<br>    elif [ &quot;$TYPE&quot; = &quot;iso&quot; ]; then<br>        echo &quot;👉 挂载 ISO 提取 squashfs...&quot;<br>        MOUNT_DIR=&quot;$CACHE_DIR/iso-mount-$TAG&quot;<br>        mkdir -p $MOUNT_DIR<br>        sudo mount -o loop $SOURCE_FILE $MOUNT_DIR<br>        if [ ! -f &quot;$MOUNT_DIR/casper/filesystem.squashfs&quot; ]; then<br>            echo &quot;❌ ISO 中未找到 casper/filesystem.squashfs&quot;<br>            exit 1<br>        fi<br>        sudo unsquashfs -d $ROOTFS_DIR $MOUNT_DIR/casper/filesystem.squashfs<br>        sudo umount $MOUNT_DIR<br>        rm -rf $MOUNT_DIR<br>    else<br>        echo &quot;❌ 类型必须是 tar 或 iso&quot;<br>        exit 1<br>    fi<br>    echo &quot;✅ rootfs 已缓存到 $ROOTFS_DIR&quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">自动检测 Ubuntu 版本</span><br>if [ -f &quot;$ROOTFS_DIR/etc/os-release&quot; ]; then<br>    UBUNTU_VERSION=$(grep &#x27;VERSION_ID=&#x27; $ROOTFS_DIR/etc/os-release | cut -d &#x27;&quot;&#x27; -f2)<br>    echo &quot;👉 检测到 Ubuntu 版本: $UBUNTU_VERSION&quot;<br>else<br>    echo &quot;⚠️ 无法检测 Ubuntu 版本，使用默认 tag: $TAG&quot;<br>    UBUNTU_VERSION=$TAG<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">自动检测架构</span><br>if [ -f &quot;$ROOTFS_DIR/bin/bash&quot; ]; then<br>    ARCH=$(file -bL $ROOTFS_DIR/bin/bash | awk &#x27;&#123;print $2&#125;&#x27;)<br>elif [ -f &quot;$ROOTFS_DIR/bin/sh&quot; ]; then<br>    ARCH=$(file -bL $ROOTFS_DIR/bin/sh | awk &#x27;&#123;print $2&#125;&#x27;)<br>else<br>    echo &quot;❌ rootfs 缺少 /bin/sh 或 /bin/bash，无法构建 Docker 镜像！&quot;<br>    exit 1<br>fi<br>echo &quot;👉 检测到架构: $ARCH&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">导入临时 Docker 镜像</span><br>echo &quot;👉 导入 Docker 临时镜像...&quot;<br>sudo tar -C $ROOTFS_DIR -c . | docker import - $&#123;IMAGE_NAME&#125;-base:$UBUNTU_VERSION<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">FULL 模式安装常用工具</span><br>if [ &quot;$MODE&quot; = &quot;--full&quot; ]; then<br>    echo &quot;👉 FULL 模式: 安装常用工具...&quot;<br>    cat &gt; Dockerfile &lt;&lt;EOF<br>FROM $&#123;IMAGE_NAME&#125;-base:$UBUNTU_VERSION<br>ENV DEBIAN_FRONTEND=noninteractive TZ=Asia/Shanghai<br>RUN dpkg --add-architecture $ARCH || true<br>RUN apt-get update &amp;&amp; apt-get install -y \\<br>    vim curl wget net-tools iputils-ping less lsb-release ca-certificates \\<br>    &amp;&amp; rm -rf /var/lib/apt/lists/*<br>CMD [&quot;/bin/bash&quot;]<br>EOF<br><br>    docker build -t $IMAGE_NAME:$UBUNTU_VERSION .<br>    rm -f Dockerfile<br>else<br>    echo &quot;👉 MINIMAL 模式: 不安装额外工具&quot;<br>    docker tag $&#123;IMAGE_NAME&#125;-base:$UBUNTU_VERSION $IMAGE_NAME:$UBUNTU_VERSION<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">清理临时镜像</span><br>docker rmi $&#123;IMAGE_NAME&#125;-base:$UBUNTU_VERSION &gt;/dev/null 2&gt;&amp;1 || true<br><br>echo &quot;✅ 镜像构建完成！&quot;<br>echo &quot;运行示例: docker run -it $IMAGE_NAME:$UBUNTU_VERSION /bin/bash&quot;<br>echo &quot;缓存 rootfs 路径: $ROOTFS_DIR&quot;<br><br></code></pre></td></tr></table></figure><p><strong>确保 <code>/bin/bash</code> 或 <code>/bin/sh</code>存在</strong></p><ul><li>如果缺失，构建会停止并提示错误。</li></ul><p><strong>自动检测 Ubuntu 版本与架构</strong></p><ul><li>FULL 模式自动安装工具时会考虑架构。</li></ul><p><strong>本机缓存管理</strong></p><ul><li><code>$HOME/.offline-ubuntu-cache</code> 保存 rootfs</li><li>自动清理超过 30 天的缓存</li></ul><p><strong>支持 tar / ISO</strong></p><ul><li>ISO 会解压 squashfs 到完整 rootfs</li></ul><p><strong>FULL / MINIMAL 模式</strong></p><ul><li>FULL 模式自动安装 vim、curl、wget、ping 等常用工具</li><li>MINIMAL 模式保持干净 rootfs</li></ul><h4 id="改进4">改进4</h4><p>实现 <strong>直接使用 Ubuntu Live ISO 一键生成 Docker镜像</strong>，无需 debootstrap，自动处理 squashfs 并保证<code>/bin/bash</code> 或 <code>/bin/sh</code> 存在。</p><p>offline-ubuntu-docker-liveiso.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>set -e<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">==============================</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">离线构建 Ubuntu Docker 镜像（支持 Live ISO 一键构建）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">自动检测版本/架构，FULL 模式安装工具，本机缓存管理</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  ./offline-ubuntu-docker-liveiso.sh &lt;<span class="hljs-built_in">source</span>&gt; &lt;<span class="hljs-built_in">type</span>&gt; &lt;tag&gt; &lt;mode&gt; &lt;imagename&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">参数:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  <span class="hljs-built_in">source</span>    : rootfs tar 文件路径 或 ISO 文件路径</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  <span class="hljs-built_in">type</span>      : tar 或 iso</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  tag       : Docker 镜像 tag (如 20.04)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  mode      : --minimal 或 --full</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  imagename : Docker 镜像名 (默认 my-ubuntu)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">==============================</span><br><br>SOURCE_FILE=$1<br>TYPE=$2<br>TAG=$&#123;3:-latest&#125;<br>MODE=$&#123;4:---full&#125;<br>IMAGE_NAME=$&#123;5:-my-ubuntu&#125;<br>CACHE_DIR=&quot;$HOME/.offline-ubuntu-cache&quot;<br>ROOTFS_DIR=&quot;$CACHE_DIR/rootfs-$TAG&quot;<br>CACHE_MAX_DAYS=30<br><br>if [ -z &quot;$SOURCE_FILE&quot; ] || [ -z &quot;$TYPE&quot; ]; then<br>    echo &quot;❌ 参数错误！请提供 source 文件路径和类型 (tar/iso)&quot;<br>    exit 1<br>fi<br><br>mkdir -p $CACHE_DIR<br><br>echo &quot;====== 离线构建 Ubuntu Docker 镜像 ======&quot;<br>echo &quot;源文件       : $SOURCE_FILE&quot;<br>echo &quot;类型         : $TYPE&quot;<br>echo &quot;Docker Tag   : $TAG&quot;<br>echo &quot;模式         : $MODE&quot;<br>echo &quot;镜像名       : $IMAGE_NAME&quot;<br>echo &quot;缓存目录     : $CACHE_DIR&quot;<br>echo<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">清理过期缓存</span><br>echo &quot;👉 清理超过 $CACHE_MAX_DAYS 天的缓存...&quot;<br>find $CACHE_DIR -maxdepth 1 -type d -name &quot;rootfs-*&quot; -mtime +$CACHE_MAX_DAYS -exec rm -rf &#123;&#125; \;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查缓存</span><br>if [ -d &quot;$ROOTFS_DIR&quot; ]; then<br>    echo &quot;✅ 检测到缓存 rootfs，直接使用缓存...&quot;<br>else<br>    rm -rf $ROOTFS_DIR<br>    mkdir -p $ROOTFS_DIR<br><br>    if [ &quot;$TYPE&quot; = &quot;tar&quot; ]; then<br>        echo &quot;👉 导入 rootfs tar...&quot;<br>        sudo tar -C $ROOTFS_DIR -xf $SOURCE_FILE<br>    elif [ &quot;$TYPE&quot; = &quot;iso&quot; ]; then<br>        echo &quot;👉 挂载 ISO 提取 squashfs...&quot;<br>        MOUNT_DIR=&quot;$CACHE_DIR/iso-mount-$TAG&quot;<br>        mkdir -p $MOUNT_DIR<br>        sudo mount -o loop $SOURCE_FILE $MOUNT_DIR<br><br>        # 检查 squashfs<br>        SQUASHFS_PATH=$(find $MOUNT_DIR -name &quot;filesystem.squashfs&quot; | head -n1)<br>        if [ -z &quot;$SQUASHFS_PATH&quot; ]; then<br>            echo &quot;❌ ISO 中未找到 filesystem.squashfs&quot;<br>            exit 1<br>        fi<br><br>        echo &quot;👉 解压 squashfs 到 rootfs...&quot;<br>        sudo unsquashfs -d $ROOTFS_DIR $SQUASHFS_PATH<br>        sudo umount $MOUNT_DIR<br>        rm -rf $MOUNT_DIR<br>    else<br>        echo &quot;❌ 类型必须是 tar 或 iso&quot;<br>        exit 1<br>    fi<br>    echo &quot;✅ rootfs 已缓存到 $ROOTFS_DIR&quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查 shell</span><br>if [ -f &quot;$ROOTFS_DIR/bin/bash&quot; ]; then<br>    SHELL_PATH=&quot;/bin/bash&quot;<br>elif [ -f &quot;$ROOTFS_DIR/bin/sh&quot; ]; then<br>    SHELL_PATH=&quot;/bin/sh&quot;<br>else<br>    echo &quot;❌ rootfs 缺少 /bin/sh 或 /bin/bash，无法构建 Docker 镜像！&quot;<br>    exit 1<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检测 Ubuntu 版本</span><br>if [ -f &quot;$ROOTFS_DIR/etc/os-release&quot; ]; then<br>    UBUNTU_VERSION=$(grep &#x27;VERSION_ID=&#x27; $ROOTFS_DIR/etc/os-release | cut -d &#x27;&quot;&#x27; -f2)<br>    echo &quot;👉 检测到 Ubuntu 版本: $UBUNTU_VERSION&quot;<br>else<br>    echo &quot;⚠️ 无法检测 Ubuntu 版本，使用默认 tag: $TAG&quot;<br>    UBUNTU_VERSION=$TAG<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">自动检测架构</span><br>ARCH=$(file -bL $ROOTFS_DIR$SHELL_PATH | awk &#x27;&#123;print $2&#125;&#x27;)<br>echo &quot;👉 检测到架构: $ARCH&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">导入 Docker 临时镜像</span><br>echo &quot;👉 导入 Docker 临时镜像...&quot;<br>sudo tar -C $ROOTFS_DIR -c . | docker import - $&#123;IMAGE_NAME&#125;-base:$UBUNTU_VERSION<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">FULL 模式安装常用工具</span><br>if [ &quot;$MODE&quot; = &quot;--full&quot; ]; then<br>    echo &quot;👉 FULL 模式: 安装常用工具...&quot;<br>    cat &gt; Dockerfile &lt;&lt;EOF<br>FROM $&#123;IMAGE_NAME&#125;-base:$UBUNTU_VERSION<br>ENV DEBIAN_FRONTEND=noninteractive TZ=Asia/Shanghai<br>RUN dpkg --add-architecture $ARCH || true<br>RUN apt-get update &amp;&amp; apt-get install -y \\<br>    vim curl wget net-tools iputils-ping less lsb-release ca-certificates \\<br>    &amp;&amp; rm -rf /var/lib/apt/lists/*<br>CMD [&quot;$SHELL_PATH&quot;]<br>EOF<br><br>    docker build -t $IMAGE_NAME:$UBUNTU_VERSION .<br>    rm -f Dockerfile<br>else<br>    echo &quot;👉 MINIMAL 模式: 不安装额外工具&quot;<br>    docker tag $&#123;IMAGE_NAME&#125;-base:$UBUNTU_VERSION $IMAGE_NAME:$UBUNTU_VERSION<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">清理临时镜像</span><br>docker rmi $&#123;IMAGE_NAME&#125;-base:$UBUNTU_VERSION &gt;/dev/null 2&gt;&amp;1 || true<br><br>echo &quot;✅ 镜像构建完成！&quot;<br>echo &quot;运行示例: docker run -it $IMAGE_NAME:$UBUNTU_VERSION $SHELL_PATH&quot;<br>echo &quot;缓存 rootfs 路径: $ROOTFS_DIR&quot;<br><br></code></pre></td></tr></table></figure><ol type="1"><li><strong>直接支持 Live ISO</strong>，无需 debootstrap</li><li><strong>自动解压 squashfs</strong>，生成完整 rootfs</li><li><strong>自动检测 shell</strong> (<code>/bin/bash</code> 或<code>/bin/sh</code>)</li><li><strong>自动检测 Ubuntu 版本和架构</strong></li><li><strong>FULL / MINIMAL 模式</strong></li><li><strong>本机缓存管理</strong>，自动清理过期缓存</li></ol><p>🔹 使用示例</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># FULL 模式构建 ISO</span><br>./offline-ubuntu-docker-liveiso.sh ubuntu<span class="hljs-number">-22.04</span>-live-server-amd64.iso iso <span class="hljs-number">22.04</span> <span class="hljs-comment">--full my-ubuntu</span><br><br><span class="hljs-comment"># MINIMAL 模式构建 tar</span><br>./offline-ubuntu-docker-liveiso.sh ubuntu<span class="hljs-number">-20.04</span>-core-rootfs.tar.gz tar <span class="hljs-number">20.04</span> <span class="hljs-comment">--minimal my-ubuntu</span><br><br><span class="hljs-comment"># 运行容器</span><br>docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-keyword">my</span>-ubuntu:<span class="hljs-number">22.04</span> /bin/bash<br></code></pre></td></tr></table></figure><hr /><p>这个脚本可以保证 <strong>容器一定有可用 shell</strong>，Live ISO也能直接构建 Docker 镜像，无需额外网络或 debootstrap。</p><h4 id="改进5">改进5</h4><p>官网只有 ubuntu-focal-core-cloudimg-amd64-root.tar.gz 没有ubuntu-20.04-core-rootfs.tar.gz。把脚本改成 <strong>直接兼容官方 cloudimage 命名</strong>，不用改名字就能直接构建 Docker 镜像，同时保留 LiveISO 支持和 shell 检测功能。</p><p>offline-ubuntu-docker-auto-cloud.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>set -e<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">==============================</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">离线构建 Ubuntu Docker 镜像（兼容 cloud image 命名）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">自动检测版本/架构，FULL 模式安装工具，本机缓存管理</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  ./offline-ubuntu-docker-auto-cloud.sh &lt;<span class="hljs-built_in">source</span>&gt; &lt;<span class="hljs-built_in">type</span>&gt; &lt;mode&gt; &lt;imagename&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">参数:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  <span class="hljs-built_in">source</span>    : rootfs tar 文件路径 或 ISO 文件路径</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  <span class="hljs-built_in">type</span>      : tar 或 iso</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  mode      : --minimal 或 --full</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  imagename : Docker 镜像名 (默认 my-ubuntu)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">==============================</span><br><br>SOURCE_FILE=$1<br>TYPE=$2<br>MODE=$&#123;3:---full&#125;<br>IMAGE_NAME=$&#123;4:-my-ubuntu&#125;<br>CACHE_DIR=&quot;$HOME/.offline-ubuntu-cache&quot;<br>CACHE_MAX_DAYS=30<br><br>if [ -z &quot;$SOURCE_FILE&quot; ] || [ -z &quot;$TYPE&quot; ]; then<br>    echo &quot;❌ 参数错误！请提供 source 文件路径和类型 (tar/iso)&quot;<br>    exit 1<br>fi<br><br>mkdir -p $CACHE_DIR<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">自动解析版本号</span><br>BASENAME=$(basename &quot;$SOURCE_FILE&quot;)<br>if [[ &quot;$BASENAME&quot; =~ ubuntu-([a-z]+)-core ]]; then<br>    UBUNTU_CODENAME=&quot;$&#123;BASH_REMATCH[1]&#125;&quot;<br>    case &quot;$UBUNTU_CODENAME&quot; in<br>        focal) UBUNTU_VERSION=&quot;20.04&quot; ;;<br>        jammy) UBUNTU_VERSION=&quot;22.04&quot; ;;<br>        bionic) UBUNTU_VERSION=&quot;18.04&quot; ;;<br>        *) UBUNTU_VERSION=&quot;latest&quot; ;;<br>    esac<br>else<br>    UBUNTU_VERSION=&quot;latest&quot;<br>fi<br><br>ROOTFS_DIR=&quot;$CACHE_DIR/rootfs-$UBUNTU_VERSION&quot;<br><br>echo &quot;====== 离线构建 Ubuntu Docker 镜像 ======&quot;<br>echo &quot;源文件       : $SOURCE_FILE&quot;<br>echo &quot;类型         : $TYPE&quot;<br>echo &quot;Docker Tag   : $UBUNTU_VERSION&quot;<br>echo &quot;模式         : $MODE&quot;<br>echo &quot;镜像名       : $IMAGE_NAME&quot;<br>echo &quot;缓存目录     : $CACHE_DIR&quot;<br>echo<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">清理过期缓存</span><br>echo &quot;👉 清理超过 $CACHE_MAX_DAYS 天的缓存...&quot;<br>find $CACHE_DIR -maxdepth 1 -type d -name &quot;rootfs-*&quot; -mtime +$CACHE_MAX_DAYS -exec rm -rf &#123;&#125; \;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查缓存</span><br>if [ -d &quot;$ROOTFS_DIR&quot; ]; then<br>    echo &quot;✅ 检测到缓存 rootfs，直接使用缓存...&quot;<br>else<br>    rm -rf $ROOTFS_DIR<br>    mkdir -p $ROOTFS_DIR<br><br>    if [ &quot;$TYPE&quot; = &quot;tar&quot; ]; then<br>        echo &quot;👉 导入 rootfs tar...&quot;<br>        sudo tar -C $ROOTFS_DIR -xf $SOURCE_FILE<br>    elif [ &quot;$TYPE&quot; = &quot;iso&quot; ]; then<br>        echo &quot;👉 挂载 ISO 提取 squashfs...&quot;<br>        MOUNT_DIR=&quot;$CACHE_DIR/iso-mount-$UBUNTU_VERSION&quot;<br>        mkdir -p $MOUNT_DIR<br>        sudo mount -o loop $SOURCE_FILE $MOUNT_DIR<br><br>        SQUASHFS_PATH=$(find $MOUNT_DIR -name &quot;filesystem.squashfs&quot; | head -n1)<br>        if [ -z &quot;$SQUASHFS_PATH&quot; ]; then<br>            echo &quot;❌ ISO 中未找到 filesystem.squashfs&quot;<br>            exit 1<br>        fi<br><br>        echo &quot;👉 解压 squashfs 到 rootfs...&quot;<br>        sudo unsquashfs -d $ROOTFS_DIR $SQUASHFS_PATH<br>        sudo umount $MOUNT_DIR<br>        rm -rf $MOUNT_DIR<br>    else<br>        echo &quot;❌ 类型必须是 tar 或 iso&quot;<br>        exit 1<br>    fi<br>    echo &quot;✅ rootfs 已缓存到 $ROOTFS_DIR&quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查 shell</span><br>if [ -f &quot;$ROOTFS_DIR/bin/bash&quot; ]; then<br>    SHELL_PATH=&quot;/bin/bash&quot;<br>elif [ -f &quot;$ROOTFS_DIR/bin/sh&quot; ]; then<br>    SHELL_PATH=&quot;/bin/sh&quot;<br>else<br>    echo &quot;❌ rootfs 缺少 /bin/sh 或 /bin/bash，无法构建 Docker 镜像！&quot;<br>    exit 1<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">自动检测架构</span><br>ARCH=$(file -bL $ROOTFS_DIR$SHELL_PATH | awk &#x27;&#123;print $2&#125;&#x27;)<br>echo &quot;👉 检测到架构: $ARCH&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">导入 Docker 临时镜像</span><br>echo &quot;👉 导入 Docker 临时镜像...&quot;<br>sudo tar -C $ROOTFS_DIR -c . | docker import - $&#123;IMAGE_NAME&#125;-base:$UBUNTU_VERSION<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">FULL 模式安装常用工具</span><br>if [ &quot;$MODE&quot; = &quot;--full&quot; ]; then<br>    echo &quot;👉 FULL 模式: 安装常用工具...&quot;<br>    cat &gt; Dockerfile &lt;&lt;EOF<br>FROM $&#123;IMAGE_NAME&#125;-base:$UBUNTU_VERSION<br>ENV DEBIAN_FRONTEND=noninteractive TZ=Asia/Shanghai<br>RUN dpkg --add-architecture $ARCH || true<br>RUN apt-get update &amp;&amp; apt-get install -y \\<br>    vim curl wget net-tools iputils-ping less lsb-release ca-certificates \\<br>    &amp;&amp; rm -rf /var/lib/apt/lists/*<br>CMD [&quot;$SHELL_PATH&quot;]<br>EOF<br><br>    docker build -t $IMAGE_NAME:$UBUNTU_VERSION .<br>    rm -f Dockerfile<br>else<br>    echo &quot;👉 MINIMAL 模式: 不安装额外工具&quot;<br>    docker tag $&#123;IMAGE_NAME&#125;-base:$UBUNTU_VERSION $IMAGE_NAME:$UBUNTU_VERSION<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">清理临时镜像</span><br>docker rmi $&#123;IMAGE_NAME&#125;-base:$UBUNTU_VERSION &gt;/dev/null 2&gt;&amp;1 || true<br><br>echo &quot;✅ 镜像构建完成！&quot;<br>echo &quot;运行示例: docker run -it $IMAGE_NAME:$UBUNTU_VERSION $SHELL_PATH&quot;<br>echo &quot;缓存 rootfs 路径: $ROOTFS_DIR&quot;<br><br></code></pre></td></tr></table></figure><ol type="1"><li><strong>兼容官方 cloud image tar 文件命名</strong><ul><li>自动解析 focal/jammy/bionic 并映射到 20.04/22.04/18.04</li></ul></li><li><strong>支持 Live ISO</strong>，自动解压 squashfs</li><li><strong>确保容器有可用 shell</strong> (<code>/bin/bash</code> 或<code>/bin/sh</code>)</li><li><strong>FULL / MINIMAL 模式</strong>，自动安装工具</li><li><strong>本机缓存管理</strong>，自动清理过期 rootfs</li></ol><p>🔹 使用示例</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 使用官方 cloud image tar 构建 FULL 镜像</span><br>./offline-ubuntu-docker-auto-cloud.sh ubuntu-focal-core-cloudimg-amd64-root.tar.gz tar <span class="hljs-comment">--full my-ubuntu</span><br><br><span class="hljs-comment"># 使用 Live ISO 构建 MINIMAL 镜像</span><br>./offline-ubuntu-docker-auto-cloud.sh ubuntu<span class="hljs-number">-22.04</span>-live-server-amd64.iso iso <span class="hljs-comment">--minimal my-ubuntu</span><br><br><span class="hljs-comment"># 运行容器</span><br>docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-keyword">my</span>-ubuntu:<span class="hljs-number">20.04</span> /bin/bash<br></code></pre></td></tr></table></figure><hr /><p>这个脚本可以直接兼容 <strong>官方 cloud image命名</strong>，不用改名字就能构建 Docker 镜像，并支持 ISO 一键构建。</p><h4 id="改进6">改进6</h4><p>执行上面的脚本出现 offline-ubuntu-docker-auto-cloud.sh: 32:offline-ubuntu-docker-auto-cloud.sh: Syntax error: "(" unexpected(expecting "then")错误。</p><p>通常 <strong>出现在 <code>/bin/sh</code> 执行 Bash脚本时</strong>，而脚本使用了 <strong>Bash 特有语法</strong>（如<code>[[ ... =~ ... ]]</code> 或数组、括号扩展）。</p><p>原因分析</p><ol type="1"><li>你可能用 <code>sh offline-ubuntu-docker-auto-cloud.sh</code>执行，而不是 <code>bash</code>。<ul><li><code>/bin/sh</code> 在大多数系统上是 dash，不支持<code>[[ ... =~ ... ]]</code> 正则匹配语法。</li></ul></li><li>脚本第一行是：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br></code></pre></td></tr></table></figure><ul><li>表示必须用 <strong>bash</strong> 运行。</li></ul><p>解决方法</p><p>方法 1：用 bash 执行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">bash offline-ubuntu-docker-auto-cloud<span class="hljs-selector-class">.sh</span> ubuntu-focal-core-cloudimg-amd64-root<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> tar <span class="hljs-attr">--full</span> my-ubuntu<br></code></pre></td></tr></table></figure><p>方法 2：给脚本可执行权限并直接运行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">chmod +x offline-ubuntu-docker-auto-cloud<span class="hljs-selector-class">.sh</span><br>./offline-ubuntu-docker-auto-cloud<span class="hljs-selector-class">.sh</span> ubuntu-focal-core-cloudimg-amd64-root<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> tar <span class="hljs-attr">--full</span> my-ubuntu<br></code></pre></td></tr></table></figure><p>✅ 这样就不会出现 <code>Syntax error: "(" unexpected</code>的问题。</p><p>注意</p><ul><li><p><strong>不要用 <code>sh script.sh</code></strong>，因为<code>/bin/sh</code> 不同于 bash，很多语法不兼容。</p></li><li><p>脚本里用到了：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-string">[[ &quot;$BASENAME&quot; =~ ubuntu-([a-z]+)-core ]]</span><br></code></pre></td></tr></table></figure><p>这是 Bash 特有正则匹配语法，必须用 bash。</p></li></ul><p>如果出现，ubuntu-focal-core-cloudimg-amd64-root.tar.gz rootfs 缺少/bin/sh 或 /bin/bash，无法构建 Docker 镜像！官方的<code>ubuntu-focal-core-cloudimg-amd64-root.tar.gz</code><strong>是最小化 rootfs</strong>，里面可能只包含 <code>/bin/dash</code>或 <code>/usr/bin/sh</code>，没有 <code>/bin/bash</code>。minimal rootfs默认只有 <code>/bin/sh</code>（dash），没有 bash</p><p><strong>解决方案</strong>：</p><ol type="1"><li>使用 <code>/bin/sh</code> 启动容器即可</li><li>FULL 模式下安装 bash 和常用工具</li></ol><p>让它 <strong>兼容 minimal rootfs</strong>，自动处理<code>/bin/sh</code> 或 <code>/bin/bash</code>：</p><ul><li><strong>如果 rootfs 没有 bash</strong>，CMD 就用<code>/bin/sh</code>，避免报错</li><li><strong>FULL 模式</strong> 下自动安装 bash 和常用工具</li></ul><p>offline-ubuntu-docker-auto-cloud-fixed.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>set -e<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">离线构建 Ubuntu Docker 镜像（支持 cloud image minimal rootfs）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">FULL 模式会安装 bash 和常用工具</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">./offline-ubuntu-docker-auto-cloud-fixed.sh &lt;<span class="hljs-built_in">source</span>&gt; &lt;<span class="hljs-built_in">type</span>&gt; &lt;mode&gt; &lt;imagename&gt;</span><br><br>SOURCE_FILE=$1<br>TYPE=$2<br>MODE=$&#123;3:---full&#125;<br>IMAGE_NAME=$&#123;4:-my-ubuntu&#125;<br>CACHE_DIR=&quot;$HOME/.offline-ubuntu-cache&quot;<br>CACHE_MAX_DAYS=30<br><br>if [ -z &quot;$SOURCE_FILE&quot; ] || [ -z &quot;$TYPE&quot; ]; then<br>    echo &quot;❌ 参数错误！请提供 source 文件路径和类型 (tar/iso)&quot;<br>    exit 1<br>fi<br><br>mkdir -p $CACHE_DIR<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">自动解析版本号</span><br>BASENAME=$(basename &quot;$SOURCE_FILE&quot;)<br>if [[ &quot;$BASENAME&quot; =~ ubuntu-([a-z]+)-core ]]; then<br>    UBUNTU_CODENAME=&quot;$&#123;BASH_REMATCH[1]&#125;&quot;<br>    case &quot;$UBUNTU_CODENAME&quot; in<br>        focal) UBUNTU_VERSION=&quot;20.04&quot; ;;<br>        jammy) UBUNTU_VERSION=&quot;22.04&quot; ;;<br>        bionic) UBUNTU_VERSION=&quot;18.04&quot; ;;<br>        *) UBUNTU_VERSION=&quot;latest&quot; ;;<br>    esac<br>else<br>    UBUNTU_VERSION=&quot;latest&quot;<br>fi<br><br>ROOTFS_DIR=&quot;$CACHE_DIR/rootfs-$UBUNTU_VERSION&quot;<br><br>echo &quot;====== 离线构建 Ubuntu Docker 镜像 ======&quot;<br>echo &quot;源文件       : $SOURCE_FILE&quot;<br>echo &quot;类型         : $TYPE&quot;<br>echo &quot;Docker Tag   : $UBUNTU_VERSION&quot;<br>echo &quot;模式         : $MODE&quot;<br>echo &quot;镜像名       : $IMAGE_NAME&quot;<br>echo &quot;缓存目录     : $CACHE_DIR&quot;<br>echo<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">清理过期缓存</span><br>echo &quot;👉 清理超过 $CACHE_MAX_DAYS 天的缓存...&quot;<br>find $CACHE_DIR -maxdepth 1 -type d -name &quot;rootfs-*&quot; -mtime +$CACHE_MAX_DAYS -exec rm -rf &#123;&#125; \;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查缓存</span><br>if [ -d &quot;$ROOTFS_DIR&quot; ]; then<br>    echo &quot;✅ 检测到缓存 rootfs，直接使用缓存...&quot;<br>else<br>    rm -rf $ROOTFS_DIR<br>    mkdir -p $ROOTFS_DIR<br><br>    if [ &quot;$TYPE&quot; = &quot;tar&quot; ]; then<br>        echo &quot;👉 导入 rootfs tar...&quot;<br>        sudo tar -C $ROOTFS_DIR -xf $SOURCE_FILE<br>    elif [ &quot;$TYPE&quot; = &quot;iso&quot; ]; then<br>        echo &quot;👉 挂载 ISO 提取 squashfs...&quot;<br>        MOUNT_DIR=&quot;$CACHE_DIR/iso-mount-$UBUNTU_VERSION&quot;<br>        mkdir -p $MOUNT_DIR<br>        sudo mount -o loop $SOURCE_FILE $MOUNT_DIR<br><br>        SQUASHFS_PATH=$(find $MOUNT_DIR -name &quot;filesystem.squashfs&quot; | head -n1)<br>        if [ -z &quot;$SQUASHFS_PATH&quot; ]; then<br>            echo &quot;❌ ISO 中未找到 filesystem.squashfs&quot;<br>            exit 1<br>        fi<br><br>        echo &quot;👉 解压 squashfs 到 rootfs...&quot;<br>        sudo unsquashfs -d $ROOTFS_DIR $SQUASHFS_PATH<br>        sudo umount $MOUNT_DIR<br>        rm -rf $MOUNT_DIR<br>    else<br>        echo &quot;❌ 类型必须是 tar 或 iso&quot;<br>        exit 1<br>    fi<br>    echo &quot;✅ rootfs 已缓存到 $ROOTFS_DIR&quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查 shell</span><br>if [ -f &quot;$ROOTFS_DIR/bin/bash&quot; ]; then<br>    SHELL_PATH=&quot;/bin/bash&quot;<br>elif [ -f &quot;$ROOTFS_DIR/bin/sh&quot; ]; then<br>    SHELL_PATH=&quot;/bin/sh&quot;<br>else<br>    echo &quot;⚠️ rootfs 没有 shell，使用 dash 代替&quot;<br>    SHELL_PATH=&quot;/bin/dash&quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检测架构</span><br>ARCH=$(file -bL $ROOTFS_DIR$SHELL_PATH | awk &#x27;&#123;print $2&#125;&#x27;)<br>echo &quot;👉 检测到架构: $ARCH&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">导入 Docker 临时镜像</span><br>echo &quot;👉 导入 Docker 临时镜像...&quot;<br>sudo tar -C $ROOTFS_DIR -c . | docker import - $&#123;IMAGE_NAME&#125;-base:$UBUNTU_VERSION<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">FULL 模式安装常用工具</span><br>if [ &quot;$MODE&quot; = &quot;--full&quot; ]; then<br>    echo &quot;👉 FULL 模式: 安装 bash 和常用工具...&quot;<br>    cat &gt; Dockerfile &lt;&lt;EOF<br>FROM $&#123;IMAGE_NAME&#125;-base:$UBUNTU_VERSION<br>ENV DEBIAN_FRONTEND=noninteractive TZ=Asia/Shanghai<br>RUN apt-get update &amp;&amp; apt-get install -y \\<br>    bash vim curl wget net-tools iputils-ping less lsb-release ca-certificates \\<br>    &amp;&amp; rm -rf /var/lib/apt/lists/*<br>CMD [&quot;/bin/bash&quot;]<br>EOF<br><br>    docker build -t $IMAGE_NAME:$UBUNTU_VERSION .<br>    rm -f Dockerfile<br>else<br>    echo &quot;👉 MINIMAL 模式: 不安装额外工具，使用 $SHELL_PATH&quot;<br>    docker tag $&#123;IMAGE_NAME&#125;-base:$UBUNTU_VERSION $IMAGE_NAME:$UBUNTU_VERSION<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">清理临时镜像</span><br>docker rmi $&#123;IMAGE_NAME&#125;-base:$UBUNTU_VERSION &gt;/dev/null 2&gt;&amp;1 || true<br><br>echo &quot;✅ 镜像构建完成！&quot;<br>echo &quot;运行示例: docker run -it $IMAGE_NAME:$UBUNTU_VERSION $SHELL_PATH&quot;<br>echo &quot;缓存 rootfs 路径: $ROOTFS_DIR&quot;<br><br></code></pre></td></tr></table></figure><p>使用说明</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># FULL 模式（安装 bash 和工具）</span><br>./offline-ubuntu-docker-auto-cloud-fixed.sh ubuntu-focal-core-cloudimg-amd64-root.tar.gz tar <span class="hljs-comment">--full my-ubuntu</span><br><br><span class="hljs-comment"># MINIMAL 模式（保留 minimal rootfs）</span><br>./offline-ubuntu-docker-auto-cloud-fixed.sh ubuntu-focal-core-cloudimg-amd64-root.tar.gz tar <span class="hljs-comment">--minimal my-ubuntu</span><br><br><span class="hljs-comment"># 运行容器</span><br>docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-keyword">my</span>-ubuntu:<span class="hljs-number">20.04</span> /bin/bash   <span class="hljs-comment"># FULL 模式</span><br>docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-keyword">my</span>-ubuntu:<span class="hljs-number">20.04</span> /bin/sh     <span class="hljs-comment"># MINIMAL 模式</span><br><br></code></pre></td></tr></table></figure><h4 id="改进7">改进7</h4><p>执行上面的脚本出现错误 ./offline-ubuntu-docker-auto-cloud-fixed.sh:25: ./offline-ubuntu-docker-auto-cloud-fixed.sh: Syntax error: "("unexpected (expecting "then")</p><p>和之前提到的原因完全一样：系统在 <strong>用 <code>/bin/sh</code>执行脚本</strong>，而脚本使用了 <strong>Bash 特有语法</strong>（如<code>[[ ... =~ ... ]]</code> 的正则匹配）。</p><p>在你的脚本里，出错的位置是：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> <span class="hljs-string">[[ &quot;$BASENAME&quot; =~ ubuntu-([a-z]+)-core ]]</span>; <span class="hljs-keyword">then</span><br></code></pre></td></tr></table></figure><ul><li><code>[[ ... =~ ... ]]</code> 是 <strong>bash</strong> 专用</li><li><code>/bin/sh</code>（dash）不支持这个语法，会报<code>Syntax error: "(" unexpected</code></li></ul><p><strong>解决方法</strong></p><p>1️⃣ <strong>用 bash 执行</strong></p><p>不要用 <code>sh script.sh</code>，一定要用：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">bash offline-ubuntu-docker-auto-cloud-fixed<span class="hljs-selector-class">.sh</span> ubuntu-focal-core-cloudimg-amd64-root<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> tar <span class="hljs-attr">--full</span> my-ubuntu<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">chmod +x offline-ubuntu-docker-auto-cloud-fixed<span class="hljs-selector-class">.sh</span><br>./offline-ubuntu-docker-auto-cloud-fixed<span class="hljs-selector-class">.sh</span> ubuntu-focal-core-cloudimg-amd64-root<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> tar <span class="hljs-attr">--full</span> my-ubuntu<br></code></pre></td></tr></table></figure><blockquote><p>这样 <code>/bin/bash</code> 会执行脚本，<code>[[ ... =~ ... ]]</code>就可以工作。</p></blockquote><p>2️⃣ <strong>修改脚本兼容 sh（可选）</strong></p><p>如果你希望脚本完全兼容 <code>/bin/sh</code>，需要把：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> <span class="hljs-string">[[ &quot;$BASENAME&quot; =~ ubuntu-([a-z]+)-core ]]</span>; <span class="hljs-keyword">then</span><br>    UBUNTU_CODENAME=<span class="hljs-string">&quot;$&#123;BASH_REMATCH[1]&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>改成 POSIX sh 兼容写法，例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">UBUNTU_CODENAME</span>=$(echo <span class="hljs-string">&quot;<span class="hljs-variable">$BASENAME</span>&quot;</span> | sed -n <span class="hljs-string">&#x27;s/ubuntu-\([a-z]\+\)-core.*/\1/p&#x27;</span>)<br></code></pre></td></tr></table></figure><p>然后根据 UBUNTU_CODENAME 设置 UBUNTU_VERSION。</p><p>这种方式完全兼容<code>/bin/sh</code>，不会再报语法错误，但脚本语法会更冗长。</p><hr /><p>💡 <strong>推荐做法</strong>：</p><ul><li>脚本开头声明 <code>#!/bin/bash</code></li><li>执行时一定用 <code>bash script.sh</code> 或<code>./script.sh</code></li><li>不要用 <code>sh script.sh</code>，否则 minimal cloud image的构建和正则匹配都会报错</li></ul><p>改写一版 <strong>完全兼容 <code>/bin/sh</code> 的离线 Ubuntu Docker构建脚本</strong>，特点如下：</p><ul><li><strong>不依赖 Bash</strong>，可用 <code>sh script.sh</code>直接运行</li><li><strong>兼容官方 cloud image minimal rootfs</strong></li><li><strong>FULL 模式自动安装 bash 和常用工具</strong></li><li><strong>MINIMAL 模式直接使用 <code>/bin/sh</code> 或<code>/bin/dash</code></strong></li><li><strong>支持 tar 和 ISO 两种类型</strong></li></ul><p>offline-ubuntu-docker-sh.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-built_in">set</span> -e<br><br><span class="hljs-comment"># 离线构建 Ubuntu Docker 镜像（完全兼容 sh）</span><br><span class="hljs-comment"># 使用：</span><br><span class="hljs-comment"># sh offline-ubuntu-docker-sh.sh &lt;source&gt; &lt;type&gt; &lt;mode&gt; &lt;imagename&gt;</span><br><br>SOURCE_FILE=<span class="hljs-variable">$1</span><br>TYPE=<span class="hljs-variable">$2</span><br>MODE=<span class="hljs-variable">$&#123;3:=--full&#125;</span><br>IMAGE_NAME=<span class="hljs-variable">$&#123;4:=my-ubuntu&#125;</span><br>CACHE_DIR=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.offline-ubuntu-cache&quot;</span><br>CACHE_MAX_DAYS=30<br><br><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$SOURCE_FILE</span>&quot;</span> ] || [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$TYPE</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;❌ 参数错误！请提供 source 文件路径和类型 (tar/iso)&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$CACHE_DIR</span>&quot;</span><br><br><span class="hljs-comment"># 提取 Ubuntu 版本（sh 兼容）</span><br>BASENAME=$(<span class="hljs-built_in">basename</span> <span class="hljs-string">&quot;<span class="hljs-variable">$SOURCE_FILE</span>&quot;</span>)<br>UBUNTU_CODENAME=$(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$BASENAME</span>&quot;</span> | sed -n <span class="hljs-string">&#x27;s/ubuntu-\([a-z]\+\)-core.*/\1/p&#x27;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$UBUNTU_CODENAME</span>&quot;</span> <span class="hljs-keyword">in</span><br>    focal) UBUNTU_VERSION=<span class="hljs-string">&quot;20.04&quot;</span> ;;<br>    jammy) UBUNTU_VERSION=<span class="hljs-string">&quot;22.04&quot;</span> ;;<br>    bionic) UBUNTU_VERSION=<span class="hljs-string">&quot;18.04&quot;</span> ;;<br>    *) UBUNTU_VERSION=<span class="hljs-string">&quot;latest&quot;</span> ;;<br><span class="hljs-keyword">esac</span><br><br>ROOTFS_DIR=<span class="hljs-string">&quot;<span class="hljs-variable">$CACHE_DIR</span>/rootfs-<span class="hljs-variable">$UBUNTU_VERSION</span>&quot;</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;====== 离线构建 Ubuntu Docker 镜像 ======&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;源文件       : <span class="hljs-variable">$SOURCE_FILE</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;类型         : <span class="hljs-variable">$TYPE</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Docker Tag   : <span class="hljs-variable">$UBUNTU_VERSION</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;模式         : <span class="hljs-variable">$MODE</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;镜像名       : <span class="hljs-variable">$IMAGE_NAME</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;缓存目录     : <span class="hljs-variable">$CACHE_DIR</span>&quot;</span><br><span class="hljs-built_in">echo</span><br><br><span class="hljs-comment"># 清理过期缓存</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 清理超过 <span class="hljs-variable">$CACHE_MAX_DAYS</span> 天的缓存...&quot;</span><br>find <span class="hljs-string">&quot;<span class="hljs-variable">$CACHE_DIR</span>&quot;</span> -maxdepth 1 -<span class="hljs-built_in">type</span> d -name <span class="hljs-string">&quot;rootfs-*&quot;</span> -mtime +<span class="hljs-string">&quot;<span class="hljs-variable">$CACHE_MAX_DAYS</span>&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">rm</span> -rf &#123;&#125; \;<br><br><span class="hljs-comment"># 导入 rootfs</span><br><span class="hljs-keyword">if</span> [ -d <span class="hljs-string">&quot;<span class="hljs-variable">$ROOTFS_DIR</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;✅ 检测到缓存 rootfs，直接使用缓存...&quot;</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">rm</span> -rf <span class="hljs-string">&quot;<span class="hljs-variable">$ROOTFS_DIR</span>&quot;</span><br>    <span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$ROOTFS_DIR</span>&quot;</span><br><br>    <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$TYPE</span>&quot;</span> = <span class="hljs-string">&quot;tar&quot;</span> ]; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 导入 rootfs tar...&quot;</span><br>        sudo tar -C <span class="hljs-string">&quot;<span class="hljs-variable">$ROOTFS_DIR</span>&quot;</span> -xf <span class="hljs-string">&quot;<span class="hljs-variable">$SOURCE_FILE</span>&quot;</span><br>    <span class="hljs-keyword">elif</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$TYPE</span>&quot;</span> = <span class="hljs-string">&quot;iso&quot;</span> ]; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 挂载 ISO 提取 squashfs...&quot;</span><br>        MOUNT_DIR=<span class="hljs-string">&quot;<span class="hljs-variable">$CACHE_DIR</span>/iso-mount-<span class="hljs-variable">$UBUNTU_VERSION</span>&quot;</span><br>        <span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$MOUNT_DIR</span>&quot;</span><br>        sudo mount -o loop <span class="hljs-string">&quot;<span class="hljs-variable">$SOURCE_FILE</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$MOUNT_DIR</span>&quot;</span><br><br>        SQUASHFS_PATH=$(find <span class="hljs-string">&quot;<span class="hljs-variable">$MOUNT_DIR</span>&quot;</span> -name <span class="hljs-string">&quot;filesystem.squashfs&quot;</span> | <span class="hljs-built_in">head</span> -n1)<br>        <span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$SQUASHFS_PATH</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>            <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;❌ ISO 中未找到 filesystem.squashfs&quot;</span><br>            <span class="hljs-built_in">exit</span> 1<br>        <span class="hljs-keyword">fi</span><br><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 解压 squashfs 到 rootfs...&quot;</span><br>        sudo unsquashfs -d <span class="hljs-string">&quot;<span class="hljs-variable">$ROOTFS_DIR</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$SQUASHFS_PATH</span>&quot;</span><br>        sudo umount <span class="hljs-string">&quot;<span class="hljs-variable">$MOUNT_DIR</span>&quot;</span><br>        <span class="hljs-built_in">rm</span> -rf <span class="hljs-string">&quot;<span class="hljs-variable">$MOUNT_DIR</span>&quot;</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;❌ 类型必须是 tar 或 iso&quot;</span><br>        <span class="hljs-built_in">exit</span> 1<br>    <span class="hljs-keyword">fi</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;✅ rootfs 已缓存到 <span class="hljs-variable">$ROOTFS_DIR</span>&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 检查 shell</span><br><span class="hljs-keyword">if</span> [ -f <span class="hljs-string">&quot;<span class="hljs-variable">$ROOTFS_DIR</span>/bin/bash&quot;</span> ]; <span class="hljs-keyword">then</span><br>    SHELL_PATH=<span class="hljs-string">&quot;/bin/bash&quot;</span><br><span class="hljs-keyword">elif</span> [ -f <span class="hljs-string">&quot;<span class="hljs-variable">$ROOTFS_DIR</span>/bin/sh&quot;</span> ]; <span class="hljs-keyword">then</span><br>    SHELL_PATH=<span class="hljs-string">&quot;/bin/sh&quot;</span><br><span class="hljs-keyword">elif</span> [ -f <span class="hljs-string">&quot;<span class="hljs-variable">$ROOTFS_DIR</span>/bin/dash&quot;</span> ]; <span class="hljs-keyword">then</span><br>    SHELL_PATH=<span class="hljs-string">&quot;/bin/dash&quot;</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;⚠️ rootfs 没有 shell，使用 /bin/sh&quot;</span><br>    SHELL_PATH=<span class="hljs-string">&quot;/bin/sh&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 导入 Docker 临时镜像</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 导入 Docker 临时镜像...&quot;</span><br>sudo tar -C <span class="hljs-string">&quot;<span class="hljs-variable">$ROOTFS_DIR</span>&quot;</span> -c . | docker import - <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>-base:<span class="hljs-variable">$UBUNTU_VERSION</span>&quot;</span><br><br><span class="hljs-comment"># FULL 模式安装工具</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$MODE</span>&quot;</span> = <span class="hljs-string">&quot;--full&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 FULL 模式: 安装 bash 和常用工具...&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;FROM <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>-base:<span class="hljs-variable">$UBUNTU_VERSION</span></span><br><span class="hljs-string">ENV DEBIAN_FRONTEND=noninteractive TZ=Asia/Shanghai</span><br><span class="hljs-string">RUN apt-get update &amp;&amp; apt-get install -y bash vim curl wget net-tools iputils-ping less lsb-release ca-certificates &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="hljs-string">CMD [\&quot;/bin/bash\&quot;]&quot;</span> &gt; Dockerfile<br><br>    docker build -t <span class="hljs-string">&quot;<span class="hljs-variable">$IMAGE_NAME</span>:<span class="hljs-variable">$UBUNTU_VERSION</span>&quot;</span> .<br>    <span class="hljs-built_in">rm</span> -f Dockerfile<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;👉 MINIMAL 模式: 使用 <span class="hljs-variable">$SHELL_PATH</span>&quot;</span><br>    docker tag <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>-base:<span class="hljs-variable">$UBUNTU_VERSION</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$IMAGE_NAME</span>:<span class="hljs-variable">$UBUNTU_VERSION</span>&quot;</span><br><span class="hljs-keyword">fi</span><br><br>docker rmi <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>-base:<span class="hljs-variable">$UBUNTU_VERSION</span>&quot;</span> &gt;/dev/null 2&gt;&amp;1 || <span class="hljs-literal">true</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;✅ 镜像构建完成！&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;运行示例: docker run -it <span class="hljs-variable">$IMAGE_NAME</span>:<span class="hljs-variable">$UBUNTU_VERSION</span> <span class="hljs-variable">$SHELL_PATH</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;缓存 rootfs 路径: <span class="hljs-variable">$ROOTFS_DIR</span>&quot;</span><br><br></code></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># FULL 模式</span><br>sh offline-ubuntu-docker-sh.sh ubuntu-focal-core-cloudimg-amd64-root.tar.gz tar <span class="hljs-comment">--full my-ubuntu</span><br><br><span class="hljs-comment"># MINIMAL 模式</span><br>sh offline-ubuntu-docker-sh.sh ubuntu-focal-core-cloudimg-amd64-root.tar.gz tar <span class="hljs-comment">--minimal my-ubuntu</span><br><br><span class="hljs-comment"># 运行容器</span><br>docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-keyword">my</span>-ubuntu:<span class="hljs-number">20.04</span> /bin/bash   <span class="hljs-comment"># FULL 模式</span><br>docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-keyword">my</span>-ubuntu:<span class="hljs-number">20.04</span> /bin/sh     <span class="hljs-comment"># MINIMAL 模式</span><br><br></code></pre></td></tr></table></figure><h4 id="改进8">改进8</h4><p>container_linux.go:247: starting container process caused "exec:"/bin/sh": stat /bin/sh: no such file or directory" oci runtime error:container_linux.go:247: starting container process caused "exec:"/bin/sh": stat /bin/sh: no such file or directory"</p><p>这说明 <strong>你导入的 rootfs 本身没有<code>/bin/sh</code></strong>，这是最小化 cloud image 的正常现象。官方minimal rootfs 通常只包含：</p><ul><li><code>/bin/dash</code> 或 <code>/usr/bin/sh</code></li><li>没有 <code>/bin/bash</code></li><li>有时 <code>/bin/sh</code> 是符号链接，可能缺失</li></ul><p>所以直接用 <code>/bin/sh</code> 启动容器会报错。</p><p>🔹 解决方案</p><p>方法 1️⃣ 使用 FULL 模式安装 bash</p><ol type="1"><li>FULL 模式构建 Docker 镜像时，脚本会安装 bash：</li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">apt-<span class="hljs-built_in">get</span> <span class="hljs-keyword">update</span><br>apt-<span class="hljs-built_in">get</span> install -<span class="hljs-keyword">y</span> bash <span class="hljs-keyword">vim</span> curl wget net-tools iputils-ping less lsb-release <span class="hljs-keyword">ca</span>-certificates<br></code></pre></td></tr></table></figure><ol type="1"><li>构建完成后，容器可以直接用 <code>/bin/bash</code> 启动：</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-keyword">my</span>-ubuntu:<span class="hljs-number">20.04</span> /bin/bash<br></code></pre></td></tr></table></figure><p>✅ 这是最简单可靠的方法。</p><p>方法 2️⃣ 手动检查 rootfs 并创建 <code>/bin/sh</code> 符号链接</p><p>如果你希望 MINIMAL 模式也能用 <code>/bin/sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 进入 rootfs</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$ROOTFS_DIR</span><br><br><span class="hljs-comment"># 查看现有 shell</span><br><span class="hljs-built_in">ls</span> -l bin/ dash sh bash<br><br><span class="hljs-comment"># 如果只有 /bin/dash，可以创建符号链接</span><br>sudo <span class="hljs-built_in">ln</span> -s dash /bin/sh<br></code></pre></td></tr></table></figure><p>然后再导入 Docker：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">sudo tar -C <span class="hljs-string">&quot;<span class="hljs-subst">$ROOTFS_DIR</span>&quot;</span> -c . | docker <span class="hljs-keyword">import</span> - my-ubuntu:minimal<br></code></pre></td></tr></table></figure><p>再运行：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-keyword">my</span>-ubuntu:minimal /bin/sh<br></code></pre></td></tr></table></figure><p>方法 3️⃣ 直接在 Dockerfile 里安装 bash</p><p>在脚本里 MINIMAL 模式也可以做：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">FROM</span> my-ubuntu-base:20.04<br><span class="hljs-built_in">RUN</span> apt-<span class="hljs-built_in">get</span> update &amp;&amp; apt-<span class="hljs-built_in">get</span> install -y bash<br>CMD [<span class="hljs-string">&quot;/bin/bash&quot;</span>]<br></code></pre></td></tr></table></figure><p>这样无论 minimal rootfs 原本有没有 shell，都能启动。</p><hr /><p>💡 <strong>结论</strong>：</p><ul><li>Minimal cloud image 本身可能没有 <code>/bin/sh</code>，这是官方最小rootfs 的正常现象</li><li><strong>可靠方法</strong>：FULL 模式安装 bash，然后用<code>/bin/bash</code> 启动</li><li><strong>可选方法</strong>：手动用 <code>/bin/dash</code> 创建<code>/bin/sh</code> 符号链接</li></ul><hr /><p>改写 <strong>完全兼容 minimal rootfs 的离线 Docker构建脚本</strong>，特点如下：</p><ul><li>FULL 模式：安装 bash 和常用工具</li><li>MINIMAL 模式：如果 rootfs 没有 <code>/bin/sh</code> 或<code>/bin/bash</code>，自动创建 <code>/bin/sh</code> 指向<code>/bin/dash</code>，保证容器可用</li><li>完全兼容 <code>/bin/sh</code> 执行，不依赖 bash</li><li>支持 tar 和 ISO 两种类型</li></ul><p>offline-ubuntu-docker-sh-auto.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br>set -e<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">离线构建 Ubuntu Docker 镜像，自动处理 minimal rootfs</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">sh offline-ubuntu-docker-sh-auto.sh &lt;<span class="hljs-built_in">source</span>&gt; &lt;<span class="hljs-built_in">type</span>&gt; &lt;mode&gt; &lt;imagename&gt;</span><br><br>SOURCE_FILE=$1<br>TYPE=$2<br>MODE=$&#123;3:=--full&#125;<br>IMAGE_NAME=$&#123;4:=my-ubuntu&#125;<br>CACHE_DIR=&quot;$HOME/.offline-ubuntu-cache&quot;<br>CACHE_MAX_DAYS=30<br><br>if [ -z &quot;$SOURCE_FILE&quot; ] || [ -z &quot;$TYPE&quot; ]; then<br>    echo &quot;❌ 参数错误！请提供 source 文件路径和类型 (tar/iso)&quot;<br>    exit 1<br>fi<br><br>mkdir -p &quot;$CACHE_DIR&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">提取 Ubuntu 版本</span><br>BASENAME=$(basename &quot;$SOURCE_FILE&quot;)<br>UBUNTU_CODENAME=$(echo &quot;$BASENAME&quot; | sed -n &#x27;s/ubuntu-\([a-z]\+\)-core.*/\1/p&#x27;)<br>case &quot;$UBUNTU_CODENAME&quot; in<br>    focal) UBUNTU_VERSION=&quot;20.04&quot; ;;<br>    jammy) UBUNTU_VERSION=&quot;22.04&quot; ;;<br>    bionic) UBUNTU_VERSION=&quot;18.04&quot; ;;<br>    *) UBUNTU_VERSION=&quot;latest&quot; ;;<br>esac<br><br>ROOTFS_DIR=&quot;$CACHE_DIR/rootfs-$UBUNTU_VERSION&quot;<br><br>echo &quot;====== 离线构建 Ubuntu Docker 镜像 ======&quot;<br>echo &quot;源文件       : $SOURCE_FILE&quot;<br>echo &quot;类型         : $TYPE&quot;<br>echo &quot;Docker Tag   : $UBUNTU_VERSION&quot;<br>echo &quot;模式         : $MODE&quot;<br>echo &quot;镜像名       : $IMAGE_NAME&quot;<br>echo &quot;缓存目录     : $CACHE_DIR&quot;<br>echo<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">清理过期缓存</span><br>echo &quot;👉 清理超过 $CACHE_MAX_DAYS 天的缓存...&quot;<br>find &quot;$CACHE_DIR&quot; -maxdepth 1 -type d -name &quot;rootfs-*&quot; -mtime +&quot;$CACHE_MAX_DAYS&quot; -exec rm -rf &#123;&#125; \;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">导入 rootfs</span><br>if [ -d &quot;$ROOTFS_DIR&quot; ]; then<br>    echo &quot;✅ 检测到缓存 rootfs，直接使用缓存...&quot;<br>else<br>    rm -rf &quot;$ROOTFS_DIR&quot;<br>    mkdir -p &quot;$ROOTFS_DIR&quot;<br><br>    if [ &quot;$TYPE&quot; = &quot;tar&quot; ]; then<br>        echo &quot;👉 导入 rootfs tar...&quot;<br>        sudo tar -C &quot;$ROOTFS_DIR&quot; -xf &quot;$SOURCE_FILE&quot;<br>    elif [ &quot;$TYPE&quot; = &quot;iso&quot; ]; then<br>        echo &quot;👉 挂载 ISO 提取 squashfs...&quot;<br>        MOUNT_DIR=&quot;$CACHE_DIR/iso-mount-$UBUNTU_VERSION&quot;<br>        mkdir -p &quot;$MOUNT_DIR&quot;<br>        sudo mount -o loop &quot;$SOURCE_FILE&quot; &quot;$MOUNT_DIR&quot;<br><br>        SQUASHFS_PATH=$(find &quot;$MOUNT_DIR&quot; -name &quot;filesystem.squashfs&quot; | head -n1)<br>        if [ -z &quot;$SQUASHFS_PATH&quot; ]; then<br>            echo &quot;❌ ISO 中未找到 filesystem.squashfs&quot;<br>            exit 1<br>        fi<br><br>        echo &quot;👉 解压 squashfs 到 rootfs...&quot;<br>        sudo unsquashfs -d &quot;$ROOTFS_DIR&quot; &quot;$SQUASHFS_PATH&quot;<br>        sudo umount &quot;$MOUNT_DIR&quot;<br>        rm -rf &quot;$MOUNT_DIR&quot;<br>    else<br>        echo &quot;❌ 类型必须是 tar 或 iso&quot;<br>        exit 1<br>    fi<br>    echo &quot;✅ rootfs 已缓存到 $ROOTFS_DIR&quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查 shell，MINIMAL 模式处理</span><br>if [ -f &quot;$ROOTFS_DIR/bin/bash&quot; ]; then<br>    SHELL_PATH=&quot;/bin/bash&quot;<br>elif [ -f &quot;$ROOTFS_DIR/bin/sh&quot; ]; then<br>    SHELL_PATH=&quot;/bin/sh&quot;<br>elif [ -f &quot;$ROOTFS_DIR/bin/dash&quot; ]; then<br>    SHELL_PATH=&quot;/bin/sh&quot;<br>    # 创建 /bin/sh 符号链接指向 dash<br>    sudo ln -sf dash &quot;$ROOTFS_DIR/bin/sh&quot;<br>else<br>    echo &quot;⚠️ rootfs 没有 shell，尝试安装 dash&quot;<br>    sudo chroot &quot;$ROOTFS_DIR&quot; apt-get update<br>    sudo chroot &quot;$ROOTFS_DIR&quot; apt-get install -y dash<br>    SHELL_PATH=&quot;/bin/sh&quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">导入 Docker 临时镜像</span><br>echo &quot;👉 导入 Docker 临时镜像...&quot;<br>sudo tar -C &quot;$ROOTFS_DIR&quot; -c . | docker import - &quot;$&#123;IMAGE_NAME&#125;-base:$UBUNTU_VERSION&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">FULL 模式安装工具</span><br>if [ &quot;$MODE&quot; = &quot;--full&quot; ]; then<br>    echo &quot;👉 FULL 模式: 安装 bash 和常用工具...&quot;<br>    echo &quot;FROM $&#123;IMAGE_NAME&#125;-base:$UBUNTU_VERSION<br>ENV DEBIAN_FRONTEND=noninteractive TZ=Asia/Shanghai<br>RUN apt-get update &amp;&amp; apt-get install -y bash vim curl wget net-tools iputils-ping less lsb-release ca-certificates &amp;&amp; rm -rf /var/lib/apt/lists/*<br>CMD [\&quot;/bin/bash\&quot;]&quot; &gt; Dockerfile<br><br>    docker build -t &quot;$IMAGE_NAME:$UBUNTU_VERSION&quot; .<br>    rm -f Dockerfile<br>else<br>    echo &quot;👉 MINIMAL 模式: 使用 $SHELL_PATH&quot;<br>    docker tag &quot;$&#123;IMAGE_NAME&#125;-base:$UBUNTU_VERSION&quot; &quot;$IMAGE_NAME:$UBUNTU_VERSION&quot;<br>fi<br><br>docker rmi &quot;$&#123;IMAGE_NAME&#125;-base:$UBUNTU_VERSION&quot; &gt;/dev/null 2&gt;&amp;1 || true<br><br>echo &quot;✅ 镜像构建完成！&quot;<br>echo &quot;运行示例: docker run -it $IMAGE_NAME:$UBUNTU_VERSION $SHELL_PATH&quot;<br>echo &quot;缓存 rootfs 路径: $ROOTFS_DIR&quot;<br><br></code></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># FULL 模式（安装 bash 和常用工具）</span><br>sh offline-ubuntu-docker-sh-auto.sh ubuntu-focal-core-cloudimg-amd64-root.tar.gz tar <span class="hljs-comment">--full my-ubuntu</span><br><br><span class="hljs-comment"># MINIMAL 模式（自动创建 /bin/sh 符号链接保证可用）</span><br>sh offline-ubuntu-docker-sh-auto.sh ubuntu-focal-core-cloudimg-amd64-root.tar.gz tar <span class="hljs-comment">--minimal my-ubuntu</span><br><br><span class="hljs-comment"># 运行容器</span><br>docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-keyword">my</span>-ubuntu:<span class="hljs-number">20.04</span> /bin/bash   <span class="hljs-comment"># FULL 模式</span><br>docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-keyword">my</span>-ubuntu:<span class="hljs-number">20.04</span> /bin/sh     <span class="hljs-comment"># MINIMAL 模式</span><br><br></code></pre></td></tr></table></figure><h4 id="最终版本">最终版本</h4><p>增加 <strong>批量构建多版本 Ubuntu 离线 Docker 镜像</strong>的功能，特点如下：</p><ul><li>支持 18.04（bionic）、20.04（focal）、22.04（jammy）</li><li>自动下载对应 cloud image（如果本地没有）</li><li>FULL 模式：安装 bash 和常用工具</li><li>MINIMAL 模式：自动创建 <code>/bin/sh</code> 指向<code>/bin/dash</code> 符号链接，保证容器可用</li><li>完全兼容 <code>/bin/sh</code> 执行，不依赖 bash</li></ul><p>offline-ubuntu-docker-multi.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br>set -e<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">批量离线构建 Ubuntu Docker 镜像</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">sh offline-ubuntu-docker-multi.sh &lt;模式: --full/--minimal&gt; &lt;镜像前缀&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">sh offline-ubuntu-docker-multi.sh --full my-ubuntu</span><br><br>MODE=$&#123;1:=--full&#125;<br>IMAGE_PREFIX=$&#123;2:=my-ubuntu&#125;<br>CACHE_DIR=&quot;$HOME/.offline-ubuntu-cache&quot;<br>CACHE_MAX_DAYS=30<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">支持版本列表</span><br>VERSIONS=&quot;bionic focal jammy&quot;<br><br>echo &quot;====== 批量离线构建 Ubuntu Docker 镜像 ======&quot;<br>echo &quot;模式         : $MODE&quot;<br>echo &quot;镜像前缀     : $IMAGE_PREFIX&quot;<br>echo &quot;缓存目录     : $CACHE_DIR&quot;<br>echo<br><br>mkdir -p &quot;$CACHE_DIR&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">清理过期缓存</span><br>echo &quot;👉 清理超过 $CACHE_MAX_DAYS 天的缓存...&quot;<br>find &quot;$CACHE_DIR&quot; -maxdepth 1 -type d -name &quot;rootfs-*&quot; -mtime +&quot;$CACHE_MAX_DAYS&quot; -exec rm -rf &#123;&#125; \;<br><br>for codename in $VERSIONS; do<br>    case &quot;$codename&quot; in<br>        bionic) VERSION=&quot;18.04&quot;;;<br>        focal)  VERSION=&quot;20.04&quot;;;<br>        jammy)  VERSION=&quot;22.04&quot;;;<br>        *) VERSION=&quot;latest&quot;;;<br>    esac<br><br>    ROOTFS_DIR=&quot;$CACHE_DIR/rootfs-$VERSION&quot;<br>    TAR_FILE=&quot;$CACHE_DIR/ubuntu-$codename-core-cloudimg-amd64-root.tar.gz&quot;<br><br>    echo &quot;====== 构建 Ubuntu $VERSION ======&quot;<br><br>    # 如果本地没有 tar 文件，尝试提示用户自行下载<br>    if [ ! -f &quot;$TAR_FILE&quot; ]; then<br>        echo &quot;⚠️ 缺少 $TAR_FILE，请从 Ubuntu 官方下载 cloud image rootfs 并放置到缓存目录&quot;<br>        continue<br>    fi<br><br>    # 导入 rootfs<br>    if [ -d &quot;$ROOTFS_DIR&quot; ]; then<br>        echo &quot;✅ 检测到缓存 rootfs，直接使用缓存...&quot;<br>    else<br>        rm -rf &quot;$ROOTFS_DIR&quot;<br>        mkdir -p &quot;$ROOTFS_DIR&quot;<br>        echo &quot;👉 解压 $TAR_FILE 到 rootfs...&quot;<br>        sudo tar -C &quot;$ROOTFS_DIR&quot; -xf &quot;$TAR_FILE&quot;<br>        echo &quot;✅ rootfs 已缓存到 $ROOTFS_DIR&quot;<br>    fi<br><br>    # 检查 shell<br>    if [ -f &quot;$ROOTFS_DIR/bin/bash&quot; ]; then<br>        SHELL_PATH=&quot;/bin/bash&quot;<br>    elif [ -f &quot;$ROOTFS_DIR/bin/sh&quot; ]; then<br>        SHELL_PATH=&quot;/bin/sh&quot;<br>    elif [ -f &quot;$ROOTFS_DIR/bin/dash&quot; ]; then<br>        SHELL_PATH=&quot;/bin/sh&quot;<br>        sudo ln -sf dash &quot;$ROOTFS_DIR/bin/sh&quot;<br>    else<br>        echo &quot;⚠️ rootfs 没有 shell，尝试安装 dash&quot;<br>        sudo chroot &quot;$ROOTFS_DIR&quot; apt-get update<br>        sudo chroot &quot;$ROOTFS_DIR&quot; apt-get install -y dash<br>        SHELL_PATH=&quot;/bin/sh&quot;<br>    fi<br><br>    # 导入 Docker 临时镜像<br>    BASE_IMAGE=&quot;$&#123;IMAGE_PREFIX&#125;-base:$VERSION&quot;<br>    echo &quot;👉 导入 Docker 临时镜像: $BASE_IMAGE ...&quot;<br>    sudo tar -C &quot;$ROOTFS_DIR&quot; -c . | docker import - &quot;$BASE_IMAGE&quot;<br><br>    # FULL 模式安装工具<br>    if [ &quot;$MODE&quot; = &quot;--full&quot; ]; then<br>        echo &quot;👉 FULL 模式: 安装 bash 和常用工具...&quot;<br>        echo &quot;FROM $BASE_IMAGE<br>ENV DEBIAN_FRONTEND=noninteractive TZ=Asia/Shanghai<br>RUN apt-get update &amp;&amp; apt-get install -y bash vim curl wget net-tools iputils-ping less lsb-release ca-certificates &amp;&amp; rm -rf /var/lib/apt/lists/*<br>CMD [\&quot;/bin/bash\&quot;]&quot; &gt; Dockerfile<br><br>        docker build -t &quot;$&#123;IMAGE_PREFIX&#125;:$VERSION&quot; .<br>        rm -f Dockerfile<br>    else<br>        echo &quot;👉 MINIMAL 模式: 使用 $SHELL_PATH&quot;<br>        docker tag &quot;$BASE_IMAGE&quot; &quot;$&#123;IMAGE_PREFIX&#125;:$VERSION&quot;<br>    fi<br><br>    # 清理临时镜像<br>    docker rmi &quot;$BASE_IMAGE&quot; &gt;/dev/null 2&gt;&amp;1 || true<br>    echo &quot;✅ Ubuntu $VERSION 镜像构建完成！&quot;<br>done<br><br>echo &quot;🎉 所有版本构建完成！&quot;<br>echo &quot;运行示例: docker run -it $&#123;IMAGE_PREFIX&#125;:20.04 /bin/bash  # FULL 模式&quot;<br>echo &quot;或 docker run -it $&#123;IMAGE_PREFIX&#125;:20.04 /bin/sh         # MINIMAL 模式&quot;<br><br></code></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">FULL 模式（安装 bash 和工具）</span><br>sh offline-ubuntu-docker-multi.sh --full my-ubuntu<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">MINIMAL 模式（保留 minimal rootfs）</span><br>sh offline-ubuntu-docker-multi.sh --minimal my-ubuntu<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行容器</span><br>docker run -it my-ubuntu:20.04 /bin/bash   # FULL 模式<br>docker run -it my-ubuntu:20.04 /bin/sh     # MINIMAL 模式<br><br></code></pre></td></tr></table></figure><p>功能总结：</p><ol type="1"><li>支持批量构建 18.04/20.04/22.04</li><li>FULL 模式自动安装 bash 和常用工具</li><li>MINIMAL 模式自动创建 <code>/bin/sh</code> 符号链接保证容器可用</li><li>完全兼容 <code>/bin/sh</code> 执行，不依赖 bash</li><li>提示用户下载缺失的 cloud image rootfs</li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu代码与版本对应关系</title>
    <link href="/2025/09/08/ubuntu%E4%BB%A3%E7%A0%81%E4%B8%8E%E7%89%88%E6%9C%AC%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/"/>
    <url>/2025/09/08/ubuntu%E4%BB%A3%E7%A0%81%E4%B8%8E%E7%89%88%E6%9C%AC%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>Ubuntu 系统的版本号与代码名称（CodeName）遵循固定的命名规则，通常由两个英文单词组成（首字母均为大写），且这两个单词分别对应一种动物和一种形容词（或相反）。</p><p>以下是 Ubuntu 主要版本与代码名称的对应关系（包含长期支持版 LTS和普通版）：</p><table><thead><tr><th>版本号</th><th>代码名称（Code Name）</th><th>发布时间</th><th>支持周期</th></tr></thead><tbody><tr><td>Ubuntu 4.10</td><td>Warty Warthog（多疣的疣猪）</td><td>2004.10</td><td>18 个月</td></tr><tr><td>Ubuntu 5.04</td><td>Hoary Hedgehog（灰白的刺猬）</td><td>2005.04</td><td>18 个月</td></tr><tr><td>Ubuntu 5.10</td><td>Breezy Badger（活泼的獾）</td><td>2005.10</td><td>18 个月</td></tr><tr><td>Ubuntu 6.06 LTS</td><td>Dapper Drake（整洁的公鸭）</td><td>2006.06</td><td>5 年（桌面）/7 年（服务器）</td></tr><tr><td>Ubuntu 6.10</td><td>Edgy Eft（急躁的小蜥蜴）</td><td>2006.10</td><td>18 个月</td></tr><tr><td>Ubuntu 7.04</td><td>Feisty Fawn（暴躁的小鹿）</td><td>2007.04</td><td>18 个月</td></tr><tr><td>Ubuntu 7.10</td><td>Gutsy Gibbon（勇敢的长臂猿）</td><td>2007.10</td><td>18 个月</td></tr><tr><td>Ubuntu 8.04 LTS</td><td>Hardy Heron（强壮的苍鹭）</td><td>2008.04</td><td>5 年（桌面）/7 年（服务器）</td></tr><tr><td>Ubuntu 8.10</td><td>Intrepid Ibex（无畏的野山羊）</td><td>2008.10</td><td>18 个月</td></tr><tr><td>Ubuntu 9.04</td><td>Jaunty Jackalope（活泼的怀俄明野兔）</td><td>2009.04</td><td>18 个月</td></tr><tr><td>Ubuntu 9.10</td><td>Karmic Koala（幸运的树袋熊）</td><td>2009.10</td><td>18 个月</td></tr><tr><td>Ubuntu 10.04 LTS</td><td>Lucid Lynx（清醒的猞猁）</td><td>2010.04</td><td>5 年（桌面）/7 年（服务器）</td></tr><tr><td>Ubuntu 10.10</td><td>Maverick Meerkat（特立独行的猫鼬）</td><td>2010.10</td><td>18 个月</td></tr><tr><td>Ubuntu 11.04</td><td>Natty Narwhal（整洁的独角鲸）</td><td>2011.04</td><td>18 个月</td></tr><tr><td>Ubuntu 11.10</td><td>Oneiric Ocelot（梦幻的豹猫）</td><td>2011.10</td><td>18 个月</td></tr><tr><td>Ubuntu 12.04 LTS</td><td>Precise Pangolin（精确的穿山甲）</td><td>2012.04</td><td>5 年（桌面）/7 年（服务器）</td></tr><tr><td>Ubuntu 12.10</td><td>Quantal Quetzal（量子的绿咬鹃）</td><td>2012.10</td><td>18 个月</td></tr><tr><td>Ubuntu 13.04</td><td>Raring Ringtail（渴望的环尾猫）</td><td>2013.04</td><td>18 个月</td></tr><tr><td>Ubuntu 13.10</td><td>Saucy Salamander（莽撞的火蜥蜴）</td><td>2013.10</td><td>18 个月</td></tr><tr><td>Ubuntu 14.04 LTS</td><td>Trusty Tahr（可靠的塔尔羊）</td><td>2014.04</td><td>5 年（桌面）/10 年（服务器）</td></tr><tr><td>Ubuntu 14.10</td><td>Utopic Unicorn（乌托邦的独角兽）</td><td>2014.10</td><td>9 个月</td></tr><tr><td>Ubuntu 15.04</td><td>Vivid Vervet（活泼的长尾猴）</td><td>2015.04</td><td>9 个月</td></tr><tr><td>Ubuntu 15.10</td><td>Wily Werewolf（狡猾的狼人）</td><td>2015.10</td><td>9 个月</td></tr><tr><td>Ubuntu 16.04 LTS</td><td>Xenial Xerus（好客的非洲地松鼠）</td><td>2016.04</td><td>5 年（桌面）/10 年（服务器）</td></tr><tr><td>Ubuntu 16.10</td><td>Yakkety Yak（喋喋不休的牦牛）</td><td>2016.10</td><td>9 个月</td></tr><tr><td>Ubuntu 17.04</td><td>Zesty Zapus（热情的跳鼠）</td><td>2017.04</td><td>9 个月</td></tr><tr><td>Ubuntu 17.10</td><td>Artful Aardvark（巧妙的土豚）</td><td>2017.10</td><td>9 个月</td></tr><tr><td>Ubuntu 18.04 LTS</td><td>Bionic Beaver（仿生海狸）</td><td>2018.04</td><td>5 年（桌面）/10 年（服务器）</td></tr><tr><td>Ubuntu 18.10</td><td>Cosmic Cuttlefish（宇宙的乌贼）</td><td>2018.10</td><td>9 个月</td></tr><tr><td>Ubuntu 19.04</td><td>Disco Dingo（迪斯科的澳洲野狗）</td><td>2019.04</td><td>9 个月</td></tr><tr><td>Ubuntu 19.10</td><td>Eoan Ermine（伊奥安的白鼬）</td><td>2019.10</td><td>9 个月</td></tr><tr><td>Ubuntu 20.04 LTS</td><td>Focal Fossa（焦点的马达加斯加狸猫）</td><td>2020.04</td><td>5 年（桌面）/10 年（服务器）</td></tr><tr><td>Ubuntu 20.10</td><td>Groovy Gorilla（欢快的大猩猩）</td><td>2020.10</td><td>9 个月</td></tr><tr><td>Ubuntu 21.04</td><td>Hirsute Hippo（多毛的河马）</td><td>2021.04</td><td>9 个月</td></tr><tr><td>Ubuntu 21.10</td><td>Impish Indri（顽皮的大狐猴）</td><td>2021.10</td><td>9 个月</td></tr><tr><td>Ubuntu 22.04 LTS</td><td>Jammy Jellyfish（欢乐的水母）</td><td>2022.04</td><td>5 年（桌面）/10 年（服务器）</td></tr><tr><td>Ubuntu 22.10</td><td>Kinetic Kudu（运动的捻角羚）</td><td>2022.10</td><td>9 个月</td></tr><tr><td>Ubuntu 23.04</td><td>Lunar Lobster（月神的龙虾）</td><td>2023.04</td><td>9 个月</td></tr><tr><td>Ubuntu 23.10</td><td>Mantic Minotaur（预言的弥诺陶洛斯）</td><td>2023.10</td><td>9 个月</td></tr><tr><td>Ubuntu 24.04 LTS</td><td>Noble Numbat（高贵的袋食蚁兽）</td><td>2024.04</td><td>5 年（桌面）/10 年（服务器）</td></tr></tbody></table><h3 id="命名规律说明">命名规律说明：</h3><ol type="1"><li><p>版本号格式为 <code>年份.月份</code>（如 24.04 表示 2024 年 4月发布）。</p></li><li><p>每两年发布一个长期支持版（LTS，4 月份发布），支持周期长（桌面 5年，服务器 10 年），适合生产环境。</p></li><li><p>普通版本每 6 个月发布一次（4 月和 10 月），仅支持 9个月，适合尝鲜新特性。</p></li><li><p>代码名称按字母顺序依次递增（从 Ubuntu 4.10 的 W 开始，循环A-Z），便于记忆和区分版本。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s初体验</title>
    <link href="/2024/10/06/k8s%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/2024/10/06/k8s%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>zshrc command not found</title>
    <link href="/2024/10/06/zshrc-command-not-found/"/>
    <url>/2024/10/06/zshrc-command-not-found/</url>
    
    <content type="html"><![CDATA[<h3 id="起因">起因</h3><p>安装了itern后，shell出现了有点问题， 安装后的node命令无法执行，提示 “zshrc command not found”</p><h3 id="解决">解决</h3><p>因为明确知道已经安装了node.js，出现这个问题，应该是由于itern的shell的有问题。</p><p>查看 ~/.nvm/ 目录，有node.js安装的文件。</p><p>执行 如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source ~/.nvm/nvm.sh<br></code></pre></td></tr></table></figure><p>再执行 nvm npm 等命令就发现已经可以了。</p>]]></content>
    
    
    <categories>
      
      <category>工具技巧</category>
      
      <category>shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu 设置代理</title>
    <link href="/2024/10/06/ubuntu-%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
    <url>/2024/10/06/ubuntu-%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="背景介绍">背景介绍</h3><p>宿主机是Mac OS ，使用parallels Desktop 安装了ubuntu desktop24.04.01。<img src="1.png" alt="网络设置" /></p><p>网络设置如图所示。宿主机Mac有VPN，在Ubuntu上也想使用宿主机的VPN代理，该如何设置呢。</p><h3 id="设置代理">设置代理</h3><p>设置代理有多种方式</p><ol type="1"><li><p>临时设置</p><p>通过命令行设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">export HTTP_PROXY=[proxy-web-or-IP-address]:[port-number]<br>export HTTPS_PROXY=[proxy-web-or-IP-address]:[port-number]<br>export FTP_PROXY=[proxy-web-or-IP-address]:[port-number]<br>export NO_PROXY=localhost,127.0.0.1,::1<br></code></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">export HTTP_PROXY=http://192.xxx.xxx.xxx:1234<br>export HTTPS_PROXY=http://192.xxx.xxx.xxx:1234<br>export FTP_PROXY=http://192.xxx.xxx.xxx:1234<br>export NO_PROXY=localhost,127.0.0.1,::1<br></code></pre></td></tr></table></figure><p>注意 HTTPS_PROXY，也需要设置为和HTTP_PROXY一样。因为宿主机Mac没有https.</p><p>同样 NO_PROXY除了 localhost127.0.0.1,::1以外，如果Ubuntu还有其他本地的IP不需要走代理，比如如果还要在Ubuntu上装了k8s后，k8s本地的IP也需要加上，不能走代理。</p></li><li><p>永久设置</p><p>编辑 ~/.bashrc</p><p>在文件里添加 内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">export HTTP_PROXY=[proxy-web-or-IP-address]:[port-number]<br>export HTTPS_PROXY=[proxy-web-or-IP-address]:[port-number]<br>export FTP_PROXY=[proxy-web-or-IP-address]:[port-number]<br>export NO_PROXY=localhost,127.0.0.1,::1<br></code></pre></td></tr></table></figure><p>其实就是把第一种方式的内容放在了 .bashrc里。</p><p>添加之后，记得执行 source ~/.bashrc</p></li><li><p>为 所有用户都能使用代理</p><p>编辑/etc/environment</p><p>在文件里添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">export HTTP_PROXY=[proxy-web-or-IP-address]:[port-number]<br>export HTTPS_PROXY=[proxy-web-or-IP-address]:[port-number]<br>export FTP_PROXY=[proxy-web-or-IP-address]:[port-number]<br>export NO_PROXY=localhost,127.0.0.1,::1<br></code></pre></td></tr></table></figure></li><li><p>为apt设置代理</p><p>新建或者编辑（如果文件存在）/etc/apt/apt.conf在文件里添加如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">export HTTP_PROXY=[proxy-web-or-IP-address]:[port-number]<br>export HTTPS_PROXY=[proxy-web-or-IP-address]:[port-number]<br>export FTP_PROXY=[proxy-web-or-IP-address]:[port-number]<br>export NO_PROXY=localhost,127.0.0.1,::1<br></code></pre></td></tr></table></figure></li><li><p>为wget设置代理</p><p>新建或者编辑（如果文件存在）~/.wgetrc ,在文件里添加如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">export HTTP_PROXY=[proxy-web-or-IP-address]:[port-number]<br>export HTTPS_PROXY=[proxy-web-or-IP-address]:[port-number]<br>export FTP_PROXY=[proxy-web-or-IP-address]:[port-number]<br>export NO_PROXY=localhost,127.0.0.1,::1<br></code></pre></td></tr></table></figure></li><li><p>为docker设置代理</p><p>创建（如果目录不存在） docker.service.d目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /etc/systemd/system/docker.service.d<br></code></pre></td></tr></table></figure></li></ol><p>​ 创建或者编辑 http-proxy.conf 代理文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Service]<br>Environment=&quot;HTTP_PROXY=https://web-proxy.corp.xxxxxx.com:8080/&quot;<br>Environment=&quot;HTTPS_PROXY=http://web-proxy.corp.xxxxxx.com:8080/&quot;<br>Environment=&quot;NO_PROXY=localhost,127.0.0.1,localaddress,.localdomain.com&quot;<br>Environment=&quot;ALL_PROXY=socks5://web-proxy.corp.xxxxxx.com:8080&quot;<br></code></pre></td></tr></table></figure><p>配置后之后，执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl daemon-reload<br><br>systemctl restart docker<br></code></pre></td></tr></table></figure><p>查看<ahref="https://docs.docker.com/engine/daemon/proxy/#httphttps-proxy">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>OS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>matplotlib中的中文字体设置</title>
    <link href="/2024/08/15/matplotlib%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE/"/>
    <url>/2024/08/15/matplotlib%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>在机器学习或者深度学习中，可视化是一个非常重要的事情，一般使用图表呈现结果，在呈现结果的时候，出现中文乱码是经常遇见的事情。</p><p>本文是在python虚拟环境下的中文乱码处理。</p><h4id="查看字体路径配置当前支持的字体字体缓存">查看字体路径、配置、当前支持的字体、字体缓存</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> matplotlib<br>a=<span class="hljs-built_in">sorted</span>([f.name <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> matplotlib.font_manager.fontManager.ttflist]) <span class="hljs-comment"># 当前支持的字体</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a:<br>    <span class="hljs-built_in">print</span>(i) <span class="hljs-comment">#输出字体</span><br><span class="hljs-built_in">print</span>(matplotlib.get_data_path()) <span class="hljs-comment">#字体路径</span><br><span class="hljs-built_in">print</span>(matplotlib.matplotlib_fname()) <span class="hljs-comment">#matplotlib 字体配置文件</span><br><span class="hljs-built_in">print</span>(matplotlib.get_cachedir()) <span class="hljs-comment"># 字体缓存路径</span><br></code></pre></td></tr></table></figure><h4 id="下载宋体字体">下载宋体字体</h4><p>宋体字体<ahref="https://github.com/SparksFly8/Stylify-Me/blob/master/.fonts/SimSun.ttf">下载</a></p><h4 id="字体配置">字体配置</h4><p>将下载的字体文件复制到 上文中输出的<code>字体路径</code>下面的fonts/ttf目录下。如:/root/.virtualenvs/venv3.9/lib/python3.9/site-packages/matplotlib/mpl-data/<strong>fonts/ttf</strong>下面</p><h4 id="修改matplotlibrc文件">修改matplotlibrc文件</h4><p>打开上文输出的matplotlib的字体配置文件matplotlibrc，修改内容如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">font.family         :</span> <span class="hljs-string">sans-serif</span>   <br><span class="hljs-comment"># 去掉前面的#     </span><br><span class="hljs-attr">font.sans-serif     :</span> <span class="hljs-string">SimSun,</span> <span class="hljs-string">DejaVu</span> <span class="hljs-string">Sans,</span> <span class="hljs-string">Bitstream</span> <span class="hljs-string">Vera</span> <span class="hljs-string">Sans,</span> <span class="hljs-string">Computer</span> <span class="hljs-string">Modern</span> <span class="hljs-string">Sans</span> <span class="hljs-string">Serif,</span> <span class="hljs-string">Lucida</span> <span class="hljs-string">Grande,</span> <span class="hljs-string">Verdana,</span> <span class="hljs-string">Geneva,</span> <span class="hljs-string">Lucid,</span> <span class="hljs-string">Arial,</span> <span class="hljs-string">Helvetica,</span> <span class="hljs-string">Avant</span> <span class="hljs-string">Garde,</span> <span class="hljs-string">sans-serif</span> <br><span class="hljs-comment"># 去掉前面的#，并在冒号后面添加SimSun, 显示的字体可能不尽相同，只需要加上需要的字体即可，如SimSun.</span><br><span class="hljs-attr">axes.unicode_minus  :</span> <span class="hljs-literal">False</span><br><span class="hljs-comment"># 去掉前面的#，并将True改为False</span><br></code></pre></td></tr></table></figure><h4 id="清除字体缓存">清除字体缓存</h4><p>打开上文输出的字体缓存路径， 执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd 字体缓存目录<br>rm -fr *<br><br>如 <br>cd /root/.cache/matplotlib<br>rm -fr *<br></code></pre></td></tr></table></figure><h4 id="最后">最后</h4><p>如果是虚拟环境，使用jupyter的话，重启内核就可以。如果是pycharm，重启软件，或者重启系统即可。</p><h4 id="设置字体">设置字体</h4><p>设置字体，总体来说有两种方式，一种是全局性的，一种是局部性的。全局性设置会影响到已经设置的字体，局部性设置字体比较灵活，可以根据需要设置。</p><p>全局设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.rcParams[<span class="hljs-string">&#x27;font.family&#x27;</span>] = [<span class="hljs-string">&#x27;sans-serif&#x27;</span>]  <br>plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;SimSun&#x27;</span>] <span class="hljs-comment"># 步骤一（替换宋体）</span><br>plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span>   <span class="hljs-comment"># 解决坐标轴负数的负号显示问题</span><br><br></code></pre></td></tr></table></figure><p>局部设置:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># ...</span><br><br>plt.xlabel(<span class="hljs-string">&quot;x轴&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;y轴&quot;</span>, fontproperties=<span class="hljs-string">&quot;SimSun&quot;</span>) <span class="hljs-comment"># （宋体）</span><br>plt.title(<span class="hljs-string">&quot;标题&quot;</span>, fontproperties=<span class="hljs-string">&quot;SimSun&quot;</span>) <span class="hljs-comment"># （宋体）</span><br>plt.show()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>深度学习</category>
      
      <category>pytorch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pytorch使用GPU训练模型</title>
    <link href="/2024/08/14/pytorch%E4%BD%BF%E7%94%A8GPU%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/08/14/pytorch%E4%BD%BF%E7%94%A8GPU%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>在深度学习中，使用GPU进行训练模型是必不可少。使用GPU训练模型的主要原因是GPU的并行处理能力和高吞吐量，主流的深度学习框架如Tensorflow、pytorch等都对GPU进行了优化。</p><h4 id="cuda">CUDA</h4><hr /><p>CUDA（Compute Unified DeviceArchitecture）是由NVIDIA开发的用于并行计算的平台和编程模型。CUDA旨在利用NVIDIAGPU（图形处理单元）的强大计算能力来加速各种科学计算、数值模拟和深度学习任务。</p><p>CUDA的软件堆栈由驱动层、运行时层和函数库层构成。CUDA软件堆栈中涉及的API包括驱动层API和运行时层API。</p><p>CUDA是显卡厂商NVIDIA在2007年推出的并行计算平台和编程模型。CUDA利用图形处理器GPU（GraphicsProcessing Unit），可显著提高计算性能。</p><p>下图展示CUDA的架构体系。CUDA软件堆栈中的驱动层API和运行时层API的区别如下。</p><ul><li>驱动层API（Driver API）：功能较完整，但是使用复杂。</li><li>运行时API（CUDA RuntimeAPI）：封装了部分驱动的API，将某些驱动初始化操作隐藏，使用方便。</li></ul><p>CUDA的Driver API由<ahref="https://www.nvidia.com/Download/index.aspx">NVIDIADriver</a>包提供，而CUDA Library和CUDA Runtime由<ahref="https://developer.nvidia.com/cuda-toolkit">CUDAToolkit</a>包提供。</p><p><img src="cuda-gpu.png" style="zoom:50%;" /></p><p><strong>CUDA的作用和特点:</strong></p><ol type="1"><li><strong>「GPU并行计算」</strong>：CUDA使GPU能够执行并行计算任务，从而大幅提高了计算性能。GPU由许多小型处理单元组成，每个处理单元都能够执行多个线程，这意味着GPU可以同时处理大量的计算任务。</li><li><strong>「CUDA编程模型」</strong>：CUDA提供了一种编程模型，允许开发人员编写C/C++代码，利用GPU的并行性来执行任务。开发人员可以编写称为"核函数"（kernel）的代码，这些核函数在GPU上并行执行。CUDA编程模型还提供了一组API（应用程序接口）来管理GPU内存、控制GPU设备和调度核函数的执行。</li><li>「并行计算应用」：CUDA广泛用于各种领域的科学计算和高性能计算应用，包括：<ul><li><strong>「数值模拟」</strong>：CUDA可用于模拟物理现象、天气模型、流体力学等领域的数值模拟。</li><li><strong>「深度学习」</strong>：深度学习框架如TensorFlow和PyTorch都支持CUDA，可用于训练和推理深度神经网络，加速图像识别、自然语言处理等任务。</li><li><strong>「分子动力学」</strong>：用于模拟分子之间相互作用，有助于药物设计和材料科学研究。</li><li><strong>「地球科学」</strong>：用于地震模拟、气象学、地球物理学等领域的大规模数值模拟。</li></ul></li><li><strong>「NVIDIA GPU支持」</strong>： CUDA仅适用于NVIDIAGPU。不同版本的CUDA通常与特定型号的NVIDIAGPU兼容，因此需要确保你的GPU支持所选版本的CUDA。</li><li><strong>「CUDA工具和库」</strong>：NVIDIA提供了一套用于CUDA开发的工具和库，包括CUDAToolkit、cuDNN（CUDA深度神经网络库）、cuBLAS（CUDA基础线性代数库）等。这些工具和库简化了CUDA应用程序的开发和优化过程。</li></ol><h4 id="cudnn">cuDNN</h4><hr /><p>cuDNN（CUDA Deep Neural NetworkLibrary）是由NVIDIA开发的用于深度学习的加速库。cuDNN旨在优化神经网络的前向传播和反向传播过程，以利用NVIDIAGPU的并行计算能力，从而加速深度学习模型的训练和推理。</p><p><strong>cuDNN的作用特点：</strong></p><ol type="1"><li><strong>「深度学习加速」</strong>：cuDNN是专门为深度学习任务而设计的，旨在加速神经网络的训练和推理。它提供了一系列高度优化的算法和函数，用于执行神经网络层的前向传播、反向传播和权重更新。</li><li><strong>「GPU加速」</strong>： cuDNN充分利用NVIDIAGPU的并行计算能力，以高效地执行深度学习操作。这使得训练深度神经网络更快速，尤其是对于大型模型和大规模数据集。</li><li><strong>「深度学习框架支持」</strong>：cuDNN被广泛用于多个深度学习框架，包括TensorFlow、PyTorch、Caffe、MXNet等。这些框架通过cuDNN来加速模型的训练和推理过程，使得深度学习研究和开发更加高效。</li><li><strong>「提高性能」</strong>：cuDNN通过使用高度优化的卷积和池化算法、自动混合精度计算、内存管理和多GPU支持等技术，显著提高了深度学习任务的性能。这些优化可以加速卷积神经网络（CNN）、循环神经网络（RNN）、生成对抗网络（GAN）等各种类型的神经网络。</li><li><strong>「版本兼容性」</strong>： cuDNN的不同版本与NVIDIAGPU架构和深度学习框架的版本兼容。因此，为了获得最佳性能，你需要选择适用于你的GPU型号和深度学习框架版本的cuDNN版本。</li><li><strong>「免费使用」</strong>：cuDNN是免费的，可以在NVIDIA的官方网站上下载和使用。</li></ol><h4 id="pytorch">Pytorch</h4><hr /><p>PyTorch是一个开源的深度学习框架，由Facebook的人工智能研究团队开发和维护。它是一个非常流行的深度学习框架，用于构建和训练神经网络模型。</p><p><strong>pytorch的作用和特点:</strong></p><ol type="1"><li><strong>「动态计算图」</strong>： PyTorch 采用动态计算图（DynamicComputationalGraph）的方式来定义和执行神经网络。这意味着你可以像编写常规Python代码一样编写神经网络，同时保留了计算图的优势，使模型的构建和调试更加直观和灵活。</li><li><strong>「灵活性」</strong>： PyTorch提供了丰富的张量操作，以及各种优化工具和模块，可以轻松构建各种类型的深度学习模型，包括卷积神经网络（CNN）、循环神经网络（RNN）、生成对抗网络（GAN）等。它还支持自定义神经网络层和损失函数，允许你创建高度定制的模型。</li><li><strong>「GPU加速」</strong>：PyTorch天然支持GPU加速，你可以在GPU上训练和执行神经网络，大幅提高了计算性能。PyTorch的GPU张量操作与CPU张量操作非常相似，使得将计算从CPU迁移到GPU变得相对容易。</li><li><strong>「动态调试」</strong>：由于采用动态计算图，PyTorch允许你在模型构建和训练过程中轻松进行动态调试，检查梯度、查看中间变量等。这对于理解和诊断模型行为非常有帮助。</li><li><strong>「丰富的生态系统」</strong>：PyTorch拥有庞大的用户社区，有许多开源项目、库和工具，可以扩展其功能。这些包括模型部署工具、迁移学习库、自然语言处理工具和计算机视觉工具，以及与其他深度学习框架的集成。</li><li><strong>「深度学习研究和教育」</strong>：PyTorch在深度学习研究和教育中非常流行，因为它易于学习、易于使用，并提供了丰富的教程和文档资源。它还被许多大学和研究机构用于深度学习课程和研究项目。</li><li><strong>「跨平台支持」</strong>：PyTorch支持多种操作系统，包括Linux、macOS和Windows，以及多种编程语言接口，如Python、C++等。这使得它适用于各种应用场景。</li></ol><h4 id="cudacudnnpytorch的关系">CUDA、cuDNN、Pytorch的关系</h4><hr /><p>CUDA、cuDNN 和 PyTorch是三个不同但相关的组件，它们之间存在一些依赖关系，</p><ol type="1"><li>「CUDA（Compute Unified Device Architecture）」:<ul><li><strong>「CUDA是GPU并行计算平台」</strong>：CUDA 是由 NVIDIA开发的用于并行计算的平台和编程模型。它允许开发人员利用 NVIDIA GPU的强大计算能力来加速各种科学计算、数值模拟和深度学习任务。</li><li><strong>「PyTorch依赖CUDA」</strong>：PyTorch 使用 CUDA来加速神经网络的训练和推理。在 PyTorch 中，张量（Tensor）可以在 CPU 或GPU 上进行计算。如果你想在 GPU 上训练神经网络，你需要确保 CUDA已经正确安装并配置。</li><li><strong>「版本兼容性」</strong>：不同版本的 PyTorch可能需要特定版本的 CUDA。你需要根据所使用的 PyTorch 版本来选择合适的CUDA 版本，以确保兼容性。</li></ul></li><li>「cuDNN（CUDA Deep Neural Network Library）」:<ul><li><strong>「cuDNN用于深度学习加速」</strong>：cuDNN 是 NVIDIA开发的专门用于深度学习的加速库。它提供了高度优化的卷积和其他深度神经网络层的操作，以提高深度学习模型的性能。</li><li><strong>「PyTorch依赖cuDNN」</strong>：PyTorch 使用 cuDNN来执行深度学习操作，尤其是在卷积神经网络（CNN）中。cuDNN提供了高性能的卷积操作，使 PyTorch 能够在 GPU上高效地进行前向传播和反向传播。</li><li><strong>「版本兼容性」</strong>：不同版本的 PyTorch 需要特定版本的cuDNN。你需要确保所使用的 cuDNN 版本与 PyTorch 版本兼容。</li></ul></li><li>「PyTorch」:<ul><li><strong>「PyTorch是深度学习框架」</strong>：PyTorch是一个开源的深度学习框架，用于构建、训练和部署神经网络模型。它提供了张量操作、自动求导、优化器、损失函数等工具，使深度学习任务更加便捷。</li><li><strong>「PyTorch依赖CUDA和cuDNN」</strong>：PyTorch 可以在 CPU 或GPU 上运行，但为了获得最佳性能，特别是在大规模深度学习任务中，你通常会将PyTorch 配置为在 GPU 上运行。这就需要确保 CUDA 和 cuDNN已正确安装和配置。</li></ul></li></ol><h4 id="查看cuda">查看CUDA</h4><hr /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-built_in">print</span>(torch.cuda.is_available())<br><span class="hljs-built_in">print</span>(torch.cuda.get_arch_list())<br>torch.zeros(<span class="hljs-number">1</span>).cuda()<br></code></pre></td></tr></table></figure><p>输出:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">True<br><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;sm_37&#x27;</span>, <span class="hljs-string">&#x27;sm_50&#x27;</span>, <span class="hljs-string">&#x27;sm_60&#x27;</span>, <span class="hljs-string">&#x27;sm_70&#x27;</span>, <span class="hljs-string">&#x27;sm_75&#x27;</span>, <span class="hljs-string">&#x27;sm_80&#x27;</span>, <span class="hljs-string">&#x27;sm_86&#x27;</span>]</span><br><span class="hljs-function"><span class="hljs-title">tensor</span><span class="hljs-params">([<span class="hljs-number">0</span>.], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)</span></span><br></code></pre></td></tr></table></figure><p>torch.cuda.is_available() 为True 说明CUDA是可用的，如果为False就要检查pytorch的版本与CUDA的版本是否兼容一致。</p><p>torch.cuda.get_arch_list() 返回的是CUDA架构列表。也就是说CUDA能支持的GPU的架构，不同版本的CUDA支持的GPU是不一样的，所以一定要根据GPU的型号/架构来选择要安装的CUDA版本.</p><p>如果cuda版本和GPU兼容，则<code>torch.zeros(1).cuda()</code>在GPU上运算就会成功，否则就会报错。</p><p>如果安装了GPU显卡驱动：在命令行执行以下命令</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nvidia-smi</span><br></code></pre></td></tr></table></figure><p><img src="nvidia-smi.png" alt="nvidia-smi" style="zoom:50%;" /></p><p>从上图可以知道安装的驱动版本为550.78，驱动API版本为12.4，表示该驱动最高支持CUDA运行时API版本为12.4。显卡是GeForceRTX 3090,24G显存。</p><p>根据上述信息，从nvidia的网站上就可以找到对应的<ahref="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html?spm=a2c4g.207292.0.0.62f2778erY9RgV">CUDA版本</a>。</p><h4 id="pytorch的安装">PyTorch的安装</h4><hr /><p>在pytorch的<ahref="https://pytorch.org/">官方网站</a>上可以找到pytorch的安装说明。如果需要安装其他版本pytorch和对应的cuda版本，可以在<ahref="https://pytorch.org/get-started/previous-versions/">这里</a>找到。从这个页面找到对应的pytorch版本，并选择相应的系统，执行对应的命令即可。</p><p>如需要安装cuda=11.6 pytorch=1.12.0 torchvision=0.13.0torchaudio=0.12.0就可以执行如下命令进行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install torch==1.12.0+cu116 torchvision==0.13.0+cu116 torchaudio==0.12.0 --extra-index-url https://download.pytorch.org/whl/cu116<br></code></pre></td></tr></table></figure><p>关于GPU架构和CUDA算力的关系,可以查看<ahref="https://cuiyuhao.com/posts/8a630bae/">这篇文章</a></p><h4 id="pytorch在gpu上训练的方法">pytorch在GPU上训练的方法</h4><hr /><p>方法一 .cuda()</p><p>我们可以通过对网络模型，数据，损失函数这三种变量调用 .cuda()来在GPU上进行训练.</p><p><img src="cuda.png" style="zoom:50%;" /></p><p>比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将网络模型在gpu上训练</span><br>model = Model()<br><span class="hljs-keyword">if</span> torch.cuda.is_available(): <span class="hljs-comment"># 判断 cuda 是否可用</span><br>model = model.cuda()<br><br><span class="hljs-comment"># 损失函数在gpu上训练</span><br>loss_fn = nn.CrossEntropyLoss()<br><span class="hljs-keyword">if</span> torch.cuda.is_available(): <span class="hljs-comment"># 判断 cuda 是否可用</span><br>loss_fn = loss_fn.cuda()<br><br><span class="hljs-comment"># 数据在gpu上训练</span><br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataloader:                        <br>imgs, targets = data<br>    <span class="hljs-keyword">if</span> torch.cuda.is_available(): <span class="hljs-comment"># 判断 cuda 是否可用</span><br>        imgs = imgs.cuda()<br>        targets = targets.cuda()<br><br></code></pre></td></tr></table></figure><p>方法二 .to(device)</p><p>指定训练设备:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">device = torch.device(<span class="hljs-string">&quot;cpu&quot;</span>)<span class="hljs-comment"># 使用cpu训练</span><br>device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span>)<span class="hljs-comment"># 使用gpu训练 </span><br>device = torch.device(<span class="hljs-string">&quot;cuda:0&quot;</span>)<span class="hljs-comment"># 当电脑中有多张显卡时，使用第一张显卡</span><br>device = torch.device(<span class="hljs-string">&quot;cuda:1&quot;</span>)<span class="hljs-comment"># 当电脑中有多张显卡时，使用第二张显卡</span><br><br>device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br></code></pre></td></tr></table></figure><p>使用GPU训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">model = model.to(device)<br><br>loss_fn = loss_fn.to(device)<br><br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> train_dataloader:<br>    imgs, targets = data<br>    imgs = imgs.to(device)<br>    targets = targets.to(device)<br><br></code></pre></td></tr></table></figure><h4 id="qa">Q&amp;A</h4><ol type="1"><li><p>CUDA error: no kernel image is available for execution on thedevice</p><p>当前GPU的算力与当前版本的Pytorch依赖的CUDA算力不匹配。</p><p>解决：需要根据显卡的cuda版本，重新安装pytorch的版本.</p></li><li><p>Expected all tensors to be on the same device, but found at leasttwo devices, cuda:0 and cpu! (when checking argument for argument indexin method wrapper__index_select)</p><p>原因：参与运算的两个或多个变量，有的在CPU上，有的在GPU上</p><p>解决方案:先找到报错的行，看看计算时都用到哪些变量或者数据，然后在调试模式下使用.is_cuda这个属性去查看到底哪些是在GPU上，哪些是在CPU上，然后把它们统一都放在CPU，或者统一放在GPU上就可以。如果增加了变量，需要将新增加的变量也搬到GPU上去。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>深度学习</category>
      
      <category>pytorch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pytorch的model.train()与model.eval()</title>
    <link href="/2024/08/07/pytorch%E7%9A%84model-train-%E4%B8%8Emodel-eval/"/>
    <url>/2024/08/07/pytorch%E7%9A%84model-train-%E4%B8%8Emodel-eval/</url>
    
    <content type="html"><![CDATA[<p>在pytorch的深度学习代码中，经常遇到model.train() 和 model.eval()，这两句代码有什么区别，究竟有什么用呢？</p><p>先看<ahref="https://pytorch.org/docs/stable/generated/torch.nn.Module.html">文档</a>。</p><figure><img src="train.png" alt="train" /><figcaption aria-hidden="true">train</figcaption></figure><p>根据官方文档的说明，train()就是把module设置为训练(training)模式。</p><figure><img src="eval.png" alt="eval" /><figcaption aria-hidden="true">eval</figcaption></figure><p>根据官方文档的说明，eval()就是把module设置为评价(evaluation)模式。</p><p>这两个方法都会对模型有一定影响，比如对BN和dropout的影响。那具体在使用中是怎么影响的呢？</p><h4 id="train">train</h4><p>如果模型中有BN层（Batch Normalization）和 Dropout ，需要在 训练时添加 model.train()。</p><p>model.train() 是保证 BN 层能够用到 每一批数据 的均值和方差。对于Dropout，model.train() 是 随机取一部分 网络连接来训练更新参数。</p><p>训练过程中会在程序上方添加一句model.train()，作用是 <strong>启用batch normalization (BN)和 dropout</strong> 。</p><h4 id="eval">eval</h4><p>如果模型中有 BN 层（Batch Normalization）和 Dropout，在 测试时 添加model.eval()。</p><p>model.eval() 是保证 BN 层能够用 全部训练数据的均值和方差，即测试过程中要保证 BN 层的均值和方差不变。对于Dropout，model.eval() 是利用到了 所有网络连接，即不进行随机舍弃神经元。</p><p>model.eval()的作用是 <strong>不启用 Batch Normalization 和Dropout</strong>。</p><h4 id="为什么测试要用eval">为什么测试要用eval</h4><p>训练完 train 样本后，生成的模型 model 要用来测试样本了。在model(test)之前，需要加上model.eval()，否则的话，有输入数据，即使不训练，它也会改变权值。这是model 中含有 BN 层和 Dropout 所带来的的性质。</p><p>eval() 时，pytorch 会自动把 BN 和 DropOut固定住，不会取平均，而是用训练好的值。 不然的话，一旦 test 的 batch_size过小，很容易就会被 BN 层导致生成图片颜色失真极大。 eval()在非训练的时候是需要加的，没有这句代码，一些网络层的值会发生变动，不会固定，你神经网络每一次生成的结果也是不固定的，生成质量可能好也可能不好。</p><p>也就是说，测试过程中使用model.eval()，这时神经网络会 沿用 batchnormalization 的值，而并 不使用 dropout。</p><p>在PyTorch中进行validation/test时，会使用model.eval()切换到测试模式，在该模式下：</p><p>1.主要用于通知dropout层和BN层在training和validation/test模式间切换：</p><p>在train模式下，dropout网络层会按照设定的参数p，设置保留激活单元的概率（保留概率=p)。BN层会继续计算数据的mean和var等参数并更新。在eval模式下，dropout层会让所有的激活单元都通过，而BN层会停止计算和更新mean和var，直接使用在训练阶段已经学出的mean和var值。</p><p>2.eval模式不会影响各层的gradient计算行为，即gradient计算和存储与training模式一样，只是不进行反向传播（backprobagation)。</p><p>而<strong>withtorch.no_grad()</strong>则主要是用于停止autograd模块的工作，以起到加速和节省显存的作用。它的作用是将该with语句包裹起来的部分停止梯度的更新，从而节省了GPU算力和显存，但是并不会影响dropout和BN层的行为。</p><p>如果不在意显存大小和计算时间的话，仅仅使用model.eval()已足够得到正确的validation/test的结果；而withtorch.no_grad()则是更进一步加速和节省gpu空间（因为不用计算和存储梯度），从而可以更快计算，也可以跑更大的batch来测试。</p>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>深度学习</category>
      
      <category>pytorch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深度学习入门</title>
    <link href="/2024/07/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"/>
    <url>/2024/07/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="感知机">感知机</h3><hr /><p><strong>感知机</strong> (perception) 是美国学者FrankRosenblatt提出来的（1957年）。了解感知机可以更好的学习神经网络（深度学习）的重要思想。感知机是一种最简单形式的前馈神经网络，是一种二元线性分类器。</p><center><img src="2LP.png" alt="有两个输入的感知机" style="zoom:33%;" /><br/><br/> 图：有两个输入的感知机</center><p>图中的<span class="math inline">\(x_1,x_2\)</span> 是输入信号，<spanclass="math inline">\(y\)</span>是输出信号，<spanclass="math inline">\(w_1, w_2\)</span> 是权重(weight)，<spanclass="math inline">\(\bigcirc\)</span>是神经元(节点)，输入信号被送往神经元时，会被分别乘以固定的权重<spanclass="math inline">\((w_1x_1, w_2x_2)\)</span>。神经元计算传递过来的信号总和，当总和超过某个界限值（阈值），输出1，就称为“神经元被激活”。界限值（阈值）用<spanclass="math inline">\(\theta\)</span> 表示。</p><p>感知机的运行原理用数学表达式表示如下： <span class="math display">\[y=\begin{cases}0 &amp;&amp;(w_1x_1+w_2x_2 \leq \theta) \\1 &amp;&amp;(w_1x_1+w_2x_2 &gt; \theta)\end{cases}\]</span>感知机中输入信号的权重越大，说明信号的重要性就越高。如果把<spanclass="math inline">\(\theta\)</span> 换成 <spanclass="math inline">\(-b\)</span> ，感知机的表示就可以变成另外一种形式： <span class="math display">\[y=\begin{cases}0 &amp;&amp;(b+w_1x_1+w_2x_2 \leq 0) \\1 &amp;&amp;(b+w_1x_1+w_2x_2 &gt; 0)\end{cases}\]</span> 现在<span class="math inline">\(b\)</span> 被称为偏置，<spanclass="math inline">\(w_1,w_2\)</span>是权重，<spanclass="math inline">\(x_1,x_2\)</span>是输入。</p><h4 id="单层感知机的局限性">单层感知机的局限性</h4><p>单层感知机的局限性在于只能表示由一条直线分割的空间（线性空间）。如果要表示非线性空间，可以通过组合（叠加）单层感知机，实现多层感知机，通过多层感知机表示非线性空间。</p><h5 id="多层感知机">多层感知机</h5><p>多层感知机(multi-layer perception, MLP)是叠加了多层感知机(单层感知机)的感知机。</p><center><img src="MLP.png" alt="多层感知机" style="zoom:33%;" /> <br/><br/>图：多层感知机</center><p>第0层是输入，第2层是输出。上图中的感知机，如果是按照拥有权重的层，是2层感知机，如果是按照拥有神经元的层，是3层感知机。</p><h4 id="神经网络">神经网络</h4><hr /><p>既然感知机（多层感知机）可以进行复杂任务的处理，为什么还要有神经网络呢？因为设置合适的、可以符合预期的感知机的权重是一个麻烦的工作，而且主要是有人工进行设置。神经网络的一个重要性质就是可以自动地从数据中学习到合适的权重参数。</p><center><img src="network.png" alt="神经网络" style="zoom:33%;" /> <br/><br/>图：神经网络</center><p>如图所示，最左边的一列是输入层，最右边一列是输出层，中间一列的中间层也称为隐藏层。这个神经网络和多层感知机非常像。</p><p>在用数学表达式表示感知机时，我们用了偏置<spanclass="math inline">\(b\)</span>，但是在图中的神经元中并没有偏置项<spanclass="math inline">\(b\)</span>。在神经网络的图中，我们可以把偏置项表示出来，并用<spanclass="math inline">\(y=h(\boldsymbol b+\boldsymbol w\boldsymbolx)\)</span>的形式写出神经网络的表达式。</p><center><img src="bias.png" alt="神经网络的偏置项" style="zoom:33%;" /><br/><br/> 图：神经网络的偏置项</center><p><span class="math display">\[h(x)=\begin{cases}0 &amp;&amp;(x \leq 0) \\1 &amp;&amp;(x &gt; 0)\end{cases}\]</span></p><h5 id="激活函数">激活函数</h5><p>像<spanclass="math inline">\(h(x)\)</span>这样把输入信号转为输出信号的函数称为<strong>激活函数</strong>(activationfuncation)。比如 <span class="math inline">\(a=b+w_1x_1 +w_2x_2\)</span> , <span class="math inline">\(y=h(a)\)</span> , <spanclass="math inline">\(h()\)</span>函数将<spanclass="math inline">\(a\)</span>转化为<spanclass="math inline">\(y\)</span> 。</p><center><img src="af.png" alt="激活函数的计算过程" style="zoom:33%;" /><br/><br/> 图：激活函数工作过程</center><p>如图所示，红线框中标识的神经元<spanclass="math inline">\(\bigcirc\)</span>显示了激活函数的计算过程。在神经网络中常用的激活函数有Relu、sigmoid等。在感知机中，激活函数是阶跃函数。阶跃函数以0为界，输出从0切换为1（或者从1切换为0）。它的值呈阶梯式变化，所以称为阶跃函数。</p><h6 id="sigmoid函数">sigmoid函数</h6><p>sigmoid函数(sigmoid function) 的表达式如下： <spanclass="math display">\[h(x) = {1\over 1+e^{-x}}\]</span></p><p><span class="math inline">\(e^{-x}\)</span> 中的<spanclass="math inline">\(e\)</span>是自然常数，是无线不循环小数，其值等于2.71828….. 近似值为<spanclass="math inline">\(271801\over 99990\)</span>。</p><p>sigmoid函数图像如下所示:</p><center><img src="sigmoid-1.png" alt="sigmoid函数图像" style="zoom:33%;" /><br/><br/> 图：sigmoid函数图像</center><p>从图中可以看出，sigmoid函数是一条平滑的曲线，输出随着输入发生连续性的变化，在神经网络中流动的是连续的实数值信号。sigmoid函数的平滑性对神经网络的学习具有重要意义。sigmoid函数的取值规律是：输入小时，输出接近0（为0）；随着输入增大，输出向1靠近（变成1）”。也就是说，当输入信号为重要信息时，阶跃函数和sigmoid函数都会输出较大的值；当输入信号为不重要的信息时，两者都输出较小的值；不管输入信号有多小，或者有多大，输出信号的值在0到1之间。sigmoid函数是非线性函数。</p><p>为什么神经网络要使用非线性函数呢？因为线性函数使得加深神经网络的层数没有意义。举例来说，<spanclass="math inline">\(h=cx\)</span>是一个线性函数，假设把这个线性函数作为激活函数，<spanclass="math inline">\(y=h(h(h(x)))\)</span>的函数运算对应的是3层神经网络，<spanclass="math inline">\(y=c\times c\times c \times x\)</span>，<spanclass="math inline">\(y=c^3x\)</span> ， <spanclass="math inline">\(c^3\)</span>是一个常数，令<spanclass="math inline">\(a=c^3\)</span>, 得到 <spanclass="math inline">\(y=ax\)</span> ,激活函数的效果与原来没有区别，无法发挥多层网络带来的优势。因此，为了发挥叠加层所带来的优势，激活函数必须使用非线性函数。</p><h6 id="relu函数">ReLu函数</h6><p>ReLu(Rectified Linear Unit)函数在输入大于0时，直接输出该值；在输入小于等于0时，输出0。Relu函数的函数表达式如下：<span class="math display">\[h(x)=\begin{cases}x &amp;&amp;(x &gt; 0) \\0 &amp;&amp;(x \leq 0)\end{cases}\]</span> ReLU 函数是一个非常简单的函数。函数图像如下：</p><center><img src="ReLu.png" alt="ReLu函数图像" style="zoom:33%;" /> <br/><br/>图：ReLu函数图像</center><h5 id="softmax函数">softmax函数</h5><p>机器学习的问题大致可以分为分类问题和回归问题。分类问题是数据属于哪一个类别的问题。比如，区分图像中的人是男性还是女性的问题就是分类问题。而回归问题是根据某个输入预测一个（连续的）数值的问题。比如，根据一个人的图像预测这个人的体重的问题就是回归问题。</p><p>一般而言，回归问题用恒等函数，分类问题用softmax函数。</p><p>分类问题中使用的softmax函数的数学表达式如下所示： <spanclass="math display">\[y_k = {e^{a_k} \over \displaystyle\sum_{i=1}^n{e^{x_i}}}\]</span>公式表达的是假设输出层共有n个神经元，计算第k个神经元的输出<spanclass="math inline">\(y_k\)</span>。softmax函数的分子是输入信号<spanclass="math inline">\(a_k\)</span>的指数函数，分母是所有输入信号的指数函数的和。softmax函数的输出是0.0到1.0之间的实数。并且，softmax函数的输出值的总和是1。输出总和为1是softmax函数的一个重要性质。正因为有了这个性质，我们才可以把softmax函数的输出解释为“概率”。一般而言，神经网络只把输出值最大的神经元所对应的类别作为识别结果。</p><h5 id="恒等函数">恒等函数</h5><p>恒等函数会将输入按原样输出，对于输入的信息，不加以任何改动地直接输出。因此，在输出层使用恒等函数时，输入信号会原封不动地被输出。</p><h3 id="神经网络的学习">神经网络的学习</h3><p>神经网络的“学习”是指从训练数据中自动获取最优权重参数的过程。学习的目的就是以损失函数为基准，找出能使它的值达到最小的权重参数。</p><p>深度学习有时也称为端到端机器学习（end-to-end machinelearning）。这里所说的端到端是指从一端到另一端的意思，也就是从原始数据（输入）中获得目标结果（输出）的意思。</p><h4 id="训练数据与测试数据">训练数据与测试数据</h4><p>机器学习中，一般将数据分为<strong>训练数据</strong>和<strong>测试数据</strong>两部分来进行学习和实验等。首先，使用<strong>训练数据</strong>进行学习，寻找最优的参数；然后，使用<strong>测试数据</strong>评价训练得到的模型的实际能力。</p><p>将数据分为训练数据和测试数据是因为我们追求的是模型的泛化能力。<strong>泛化能力</strong>是指处理未被观察过的数据（不包含在训练数据中的数据）的能力。获得泛化能力是机器学习的最终目标。</p><p>仅仅用一个数据集去学习和评价参数,可以顺利地处理某个数据集，但无法处理其他数据集的情况，这种只对某个数据集过度拟合的状态称为<strong>过拟合</strong>（overfitting）。</p><h4 id="one-hot表示法">One-hot表示法</h4><p>将正确解标签表示为1，其他标签表示为0的表示方法称为one-hot表示。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">t</span> = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h4 id="损失函数">损失函数</h4><p><strong>损失函数</strong>（lossfunction）是表示"神经网络性能有多好"的指标，即当前的神经网络对监督数据在多大程度上不拟合，在多大程度上不一致。损失函数可以使用任意函数，但一般用<strong>均方误差</strong>和<strong>交叉熵误差</strong>等。</p><h5 id="均方误差">均方误差</h5><p><strong>均方误差</strong>（mean squared error）。均方误差如下式所示：<span class="math display">\[E={1\over 2}{\displaystyle \sum_k{(y_k-t_k)^2}}\]</span></p><p>这里，<spanclass="math inline">\(y_k\)</span>是表示神经网络的输出，<spanclass="math inline">\(t_k\)</span>表示监督数据，<spanclass="math inline">\(k\)</span>表示数据的维数。</p><h5 id="交叉熵误差">交叉熵误差</h5><p><strong>交叉熵误差</strong>（cross entropyerror）也经常被用作损失函数。交叉熵误差如下式所示。 <spanclass="math display">\[E=-\displaystyle \sum_k{t_k\log y_k}\]</span> 这里，log表示以e为底数的自然对数（log e）。<spanclass="math inline">\(y_k\)</span>是神经网络的输出，<spanclass="math inline">\(t_k\)</span>是正确解标签</p><center><img src="cee.png" alt="交叉熵损失函数图像" style="zoom:33%;" /><br/><br/> 图：交叉熵损失函数图像</center><p>从图中可以看出，，x等于1时，y为0；随着x向0靠近，y逐渐变小。因此，正确解标签对应的输出越大（也就是交叉熵误差公式中的<spanclass="math inline">\(y_k\)</span>越大，对应的是图中的x坐标），误差公式的值越接近0（误差越小,对应图中的y坐标）；当输出为1时，交叉熵误差为0。此外，如果正确解标签对应的输出较小（也就是交叉熵误差公式中的<spanclass="math inline">\(y_k\)</span>越小）误差公式的值值较大(误差越大)。</p><p>注意：因为交叉熵误差公式有负号(<spanclass="math inline">\(-\)</span>)。该图<spanclass="math inline">\(y_k\)</span>的输出是0-1之间的数，可以看似是概率输出，所以<spanclass="math inline">\(\log x \le0\)</span>，公式加负号可以变为正数。也就是变成输出的正确概率越小，误差越大，输出的正确概率越大，误差越小。</p><h5 id="mini-batch学习">mini-batch学习</h5><p>如果遇到大数据，数据量非常多，以全部数据为对象求损失函数的和，则计算过程需要花费较长的时间，这种情况下以全部数据为对象计算损失函数是不现实的。因此，从全部数据中选出一部分，作为全部数据的“近似”。这种从训练数据中选出一批数据（称为mini-batch,小批量），然后对每个mini-batch进行学习的方式称为<strong>mini-baatch学习</strong>。</p><p>损失函数 交叉熵误差公式如下所示： <span class="math display">\[E=-{1\over N}{\displaystyle \sum_n\sum_k{y_{nk}\log {t_{nk}}}}\]</span> 这里,假设数据有<span class="math inline">\(N\)</span>个，<spanclass="math inline">\(t_{nk}\)</span>表示第<spanclass="math inline">\(n\)</span>个数据的第<spanclass="math inline">\(k\)</span>个元素的值（<spanclass="math inline">\(y_{nk}\)</span>是神经网络的输出，<spanclass="math inline">\(t_{nk}\)</span>是监督数据）。这个公式只是把求单个数据的损失函数的公式扩大到了N份数据，不过最后还要除以N进行正规化。通过除以N，可以求单个数据的“平均损失函数”。通过这样的平均化，可以获得和训练数据的数量无关的统一指标。</p><h5 id="为什么要用损失函数">为什么要用损失函数</h5><p>在进行神经网络的学习时，不能将识别精度（或者预测准确率等）作为指标。因为如果以识别精度为指标，则参数的导数在绝大多数地方都会变为0。</p><p>举个具体的例子，假设某个神经网络正确识别出了100笔训练数据中的32笔，此时识别精度为32%。如果以识别精度为指标，即使稍微改变权重参数的值，识别精度也仍将保持在32%，不会出现变化。也就是说，仅仅微调参数，是无法改善识别精度的。即便识别精度有所改善，它的值也不会像32.0123... %这样连续变化，而是变为33 %、34%这样的不连续的、离散的值。而如果把损失函数作为指标，则当前损失函数的值可以表示为0.92543...这样的值。并且，如果稍微改变一下参数的值，对应的损失函数也会像0.93432... 这样发生连续性的变化。</p><p>识别精度对微小的参数变化基本上没有什么反应，即便有反应，它的值也是不连续地、突然地变化。作为激活函数的阶跃函数也有同样的情况。出于相同的原因，如果使用阶跃函数作为激活函数，神经网络的学习将无法进行。</p><center><img src="diff.png" alt=" 阶跃函数和sigmoid函数" style="zoom:33%;" /><br/><br/> 图： 阶跃函数和sigmoid函数</center><p>阶跃函数的斜率在绝大多数地方都为0，而sigmoid函数的斜率（切线）不会为0</p><h4 id="梯度">梯度</h4><p>像<span class="math inline">\(( \frac {\partial f}{\partial x_0},\frac { \partial f}{\partialx_1})\)</span>这样的由全部变量的偏导数汇总而成的向量称为<strong>梯度</strong>（gradient）。</p><h3 id="误差的反向传播">误差的反向传播</h3><p>要正确理解误差反向传播法，有两种方法：一种是基于数学式；另一种是基于计算图（computationalgraph）。基于数学式的方法严密且简洁，计算图，直观且易理解。</p><h4 id="计算图">计算图</h4><p>计算图将计算过程用图形表示出来。计算图通过节点和箭头表示计算过程。节点用<spanclass="math inline">\(\bigcirc\)</span>表示，<spanclass="math inline">\(\bigcirc\)</span>中是计算的内容。将计算的中间结果写在箭头的上方，表示各个节点的计算结果从左向右传递。</p><center><img src="jst.png" alt="计算图示例" style="zoom:33%;" /> <br/><br/> 图：计算图示例</center><h4 id="正向传播">正向传播</h4><p><strong>正向传播</strong>（forwardpropagation）是从计算图出发点到结束点的传播。</p><h4 id="反向传播">反向传播</h4><p><strong>反向传播</strong>（backwardpropagation）从计算图结束点到出发点的传播（从图上看的话，就是从右向左的转播）。反向传播将局部导数向正方向的反方向（从右到左）传递。传递这个局部导数的原理，是基于<strong>链式法则</strong>（chainrule）。</p><h4 id="链式法则">链式法则</h4><p>链式法则是复合函数的导数的性质，如果某个函数由复合函数表示，则该复合函数的导数可以用构成复合函数的各个函数的导数的乘积表示。</p><h4 id="局部计算">局部计算</h4><p>局部计算是指，无论全局发生了什么，都只根据与自己相关的信息输出接下来的结果。</p><h3 id="深度学习的技巧">深度学习的技巧</h3><p>神经网络的学习的目的是找到使损失函数的值尽可能小的参数。这是寻找最优参数的问题，解决这个问题的过程称为最优化（optimization）。</p><h4 id="参数更新">参数更新</h4><h5 id="随机梯度下降法">随机梯度下降法</h5><p>为了找到最优参数，我们将参数的梯度（导数）作为了线索。使用参数的梯度，沿梯度方向更新参数，并重复这个步骤多次，从而逐渐靠近最优参数，这个过程称为<strong>随机梯度下降法</strong>（stochasticgradient descent），简称<strong>SGD</strong>。SGD的数学表达如下所示：<span class="math display">\[\boldsymbol W\leftarrow \boldsymbol W-\eta \frac{\partial L}{\partial\boldsymbol W}\]</span> 这里把需要更新的权重参数记为<spanclass="math inline">\(\boldsymbol W\)</span>，把损失函数关于<spanclass="math inline">\(\boldsymbol W\)</span>的梯度记为<spanclass="math inline">\(\frac{\partial L}{\partial \boldsymbolW}\)</span>, <spanclass="math inline">\(\eta\)</span>表示学习率，实际上会取0.01或0.001这些事先决定好的值。式子中的←表示用右边的值更新左边的值。</p><h6 id="sgd的缺点">SGD的缺点：</h6><p>如果函数的形状非均向（anisotropic），比如呈延伸状，搜索的路径就会非常低效。SGD低效的根本原因是，梯度的方向并没有指向最小值的方向。</p><h5 id="monentum">Monentum</h5><p>Monentum 是动量的意思，数学式表示Momentum方法，如下所示: <spanclass="math display">\[\displaylines{\boldsymbol {\upsilon} \leftarrow \alpha \boldsymbol\upsilon - \eta \frac {\partial L}{\partial \boldsymbol W}\\\boldsymbol W = \boldsymbol W + \boldsymbol  \upsilon}\]</span> 这里新出现了一个变量<spanclass="math inline">\(\upsilon\)</span>，对应物理上的速度。Momentum方法给人的感觉就像是小球在地面上滚动。通过增加动量后，可以有效改善更新不稳定的情况。</p><center><img src="momentum.png" alt="Momentum的最优化的更新路径" style="zoom:33%;" /><br/><br/> 图： Momentum的最优化的更新路径</center><h5 id="学习率">学习率</h5><p>在神经网络的学习中，学习率（数学式中记为<spanclass="math inline">\(\eta\)</span>）的值很重要。学习率过小，会导致学习花费过多时间；反过来，学习率过大，则会导致学习发散而不能正确进行。</p><h5 id="学习率衰减">学习率衰减</h5><p><strong>学习率衰减</strong>（learning ratedecay），即随着学习的进行，使学习率逐渐减小。一开始“多”学，然后逐渐“少”学的方法，在神经网络的学习中经常被使用。逐渐减小学习率的想法，相当于将“全体”参数的学习率值一起降低。</p><h5 id="adagrad">AdaGrad</h5><p>AdaGrad会为参数的每个元素适当地调整学习率，与此同时进行学习。数学表示如下：<span class="math display">\[\displaylines{\boldsymbol h \leftarrow \boldsymbol h + \frac {\partial L}{\partial\boldsymbol W} \odot \frac {\partial L}{\partial \boldsymbol W}\\\boldsymbol W = \boldsymbol W - \eta \frac{1}{\sqrt {\boldsymbol h}}\frac {\partial L}{\partial \boldsymbol W}}\]</span> 这里新出现了变量<span class="math inline">\(\boldsymbolh\)</span>，它保存了以前的所有梯度值的平方和，然后，在更新参数时，通过乘以$$，就可以调整学习的尺度。这意味着，参数的元素中变动较大（被大幅更新）的元素的学习率将变小。也就是说，可以按参数的元素进行学习率衰减，使变动大的参数的学习率逐渐减小。</p><h5 id="adam">Adam</h5><p>Adam是2015年提出的，直观地讲，就是融合了Momentum和AdaGrad的方法。通过组合前面两个方法的优点，有望实现参数空间的高效搜索。此外，进行超参数的“偏置校正”也是Adam的特征。</p><p>Adam会设置 3个超参数。一个是学习率（论文中以<spanclass="math inline">\(\alpha\)</span>出现），另外两个是一次momentum系数<spanclass="math inline">\(\beta_1\)</span>和二次momentum系数<spanclass="math inline">\(\beta_2\)</span>。根据论文，标准的设定值是<spanclass="math inline">\(\beta_1\)</span>为 0.9，<spanclass="math inline">\(\beta_2\)</span> 为 0.999。</p><center><img src="adam.png" alt="Adam" style="zoom:33%;" /> <br/><br/> 图：Adam的最优化的更新路径</center><h4 id="权重的初始值">权重的初始值</h4><p>在神经网络的学习中，权重的初始值特别重要。实际上，设定什么样的权重初始值，经常关系到神经网络的学习能否成功。</p><h5 id="权重的初始值是否可以为0">权重的初始值是否可以为0</h5><p>从结论来说，将权重初始值设为0不是一个好主意。事实上，将权重初始值设为0的话，将无法正确进行学习。</p><p>是因为在误差反向传播法中，所有的权重值都会进行相同的更新。比如，在2层神经网络中，假设第1层和第2层的权重为0。这样一来，正向传播时，因为输入层的权重为0，所以第2层的神经元全部会被传递相同的值。第2层的神经元中全部输入相同的值，这意味着反向传播时第2层的权重全部都会进行相同的更新。因此，权重被更新为相同的值，并拥有了对称的值（重复的值）。这使得神经网络拥有许多不同的权重的意义丧失了。为了防止“权重均一化”（严格地讲，是为了瓦解权重的对称结构），必须随机生成初始值。</p><h5 id="梯度消失">梯度消失</h5><p>梯度消失（gradientvanishing），随着输出不断地靠近0（或者靠近1），它的导数的值逐渐接近0。因此，偏向0和1的数据分布会造成反向传播中梯度的值不断变小，最后消失。这个问题称为梯度消失。</p><h5 id="权重值的要求">权重值的要求</h5><p>神经网络各层的激活值的分布都要求有适当的广度。为什么呢？因为通过在各层间传递多样性的数据，神经网络可以进行高效的学习。反过来，如果传递的是有所偏向的数据，就会出现梯度消失或者“表现力受限”的问题，导致学习可能无法顺利进行。</p><h5 id="一些推荐的权重初始值">一些推荐的权重初始值</h5><h6 id="xavier初始值">Xavier初始值</h6><p><strong>Xavier初始值</strong>是XavierGlorot等人的论文中推荐的权重初始值，Xavier的论文中，为了使各层的激活值呈现出具有相同广度的分布，推导了合适的权重尺度。推导出的结论是，如果前一层的节点数为<spanclass="math inline">\(n\)</span>，则初始值使用标准差为<spanclass="math inline">\(\frac{1}{\sqrt n}\)</span>的分布。</p><p><strong>Xavier初始值</strong>是以激活函数是线性函数为前提而推导出来的。因为sigmoid函数和tanh函数左右对称，且中央附近可以视作线性函数，所以适合使用Xavier初始值。</p><h6 id="relu初始值">ReLu初始值</h6><p>当激活函数使用ReLU时，一般推荐使用ReLU专用的初始值，也就是KaimingHe等人推荐的初始值，也称为“He初始值”。当前一层的节点数为n时，He初始值使用标准差为<spanclass="math inline">\(\sqrt \frac{2}{n}\)</span>的高斯分布。</p><p><strong>总结一下</strong>，当激活函数使用ReLU时，权重初始值使用He初始值，当激活函数为sigmoid或tanh等S型曲线函数时，初始值使用Xavier初始值。这是目前的最佳实践。</p><h4 id="batch-normalization">Batch Normalization</h4><p><strong>BatchNorm</strong>，顾名思义，以进行学习时的mini-batch为单位，按mini-batch进行正规化。具体而言，就是进行使数据分布的均值为0、方差为1的正规化。用数学式表示的话，如下所示。<span class="math display">\[\displaylines{\mu_B \leftarrow \frac{1}{m} \displaystyle \sum_{i=1}^m{x_i}\\\sigma^2_B \leftarrow \frac{1}{m} \displaystyle\sum_{i=1}^m(x_i-\mu_B)^2\\\hat x_i \leftarrow \frac{x_i-\mu_B}{\sqrt {\sigma^2_B + \varepsilon}}}\]</span></p><p>Batch Norm的优点:</p><ol type="1"><li>可以使学习快速进行（可以增大学习率）。</li><li>不那么依赖初始值（对于初始值不用那么神经质）。</li><li>抑制过拟合（降低Dropout等的必要性）。</li></ol><h4 id="正则化">正则化</h4><p>机器学习的问题中，过拟合是一个很常见的问题。</p><h5 id="过拟合">过拟合</h5><p><strong>过拟合</strong>指的是只能拟合训练数据，但不能很好地拟合不包含在训练数据中的其他数据的状态。</p><p>发生过拟合的原因，主要有以下两个:</p><ol type="1"><li>模型拥有大量参数、表现力强。</li><li>训练数据少。</li></ol><h5 id="权重衰减">权重衰减</h5><p><strong>权值衰减</strong>（weightdecay）就是一种以减小权重参数的值为目的进行学习的方法。通过减小权重参数的值来抑制过拟合的发生，提高泛化能力。该方法通过在学习的过程中对大的权重进行惩罚，来抑制过拟合。</p><h5 id="l1范数">L1范数</h5><p>L1范数是各个元素的绝对值之和，即<spanclass="math inline">\(|w_1|+|w_2|+\cdots+|w_n|\)</span></p><h5 id="l2范数">L2范数</h5><p>L2范数相当于各个元素的平方和。用数学式表示的话，假设有权重<spanclass="math inline">\(W = (w_,w_2, ... ,w_n)\)</span>，则L2范数为<spanclass="math inline">\(\sqrt{w_1^2+w_2^2+\cdots+w_n^2}\)</span>。L2是比较常用的 范数。</p><h5 id="l范数">L∞范数</h5><p>L∞也称为Max范数，相当于各个元素的绝对值中最大的那一个。</p><h5 id="dropout">DropOut</h5><p>Dropout是一种在学习的过程中随机删除神经元的方法。训练时，随机选出隐藏层的神经元，然后将其删除。被删除的神经元不再进行信号的传递。</p><h4 id="超参数及最优化">超参数及最优化</h4><p><strong>超参数</strong>（hyper-parameter）是指，比如各层的神经元数量、batch大小、参数更新时的学习率或权值衰减等。如果这些超参数没有设置合适的值，模型的性能就会很差。</p><h5 id="超参数的最优化">超参数的最优化</h5><p>进行超参数的最优化时，逐渐缩小超参数的“好值”的存在范围非常重要。所谓逐渐缩小范围，是指一开始先大致设定一个范围，从这个范围中随机选出一个超参数（采样），用这个采样到的值进行识别精度的评估；然后，多次重复该操作，观察识别精度的结果，根据这个结果缩小超参数的“好值”的范围。通过重复这一操作，就可以逐渐确定超参数的合适范围。</p><h4 id="验证数据">验证数据</h4><p>验证数据（validationdata）用于调整超参数的数据。使用这个验证数据来评估超参数的好坏。</p><p>训练数据用于参数（权重和偏置）的学习，验证数据用于超参数的性能评估。为了确认泛化能力，要在最后使用（比较理想的是只用一次）测试数据。</p><h3 id="卷积神经网络">卷积神经网络</h3><p><strong>卷积神经网络</strong>（Convolutional Neural Network，CNN）中新增了 Convolution 层和 Pooling 层。CNN 的层的连接顺序是“Convolution -ReLU -（Pooling） ”</p><h4 id="卷积层">卷积层</h4><h5 id="特征图">特征图</h5><p>卷积层的输入输出数据称为<strong>特征图</strong>（featuremap）。其中，卷积层的输入数据称为<strong>输入特征图</strong>（inputfeature map）， 输 出数据称为<strong>输出特征图</strong>（output featuremap）。</p><h5 id="卷积运算">卷积运算</h5><p>卷积层进行的处理就是卷积运算。卷积运算相当于图像处理中的“滤波器运算”。</p><center><img src="cnn_calc.png" alt="卷积运算" style="zoom:33%;" /> <br/><br/>图： 卷积运算</center><h5 id="填充">填充</h5><p>在进行卷积层的处理之前，有时要向输入数据的周围填入固定的数据（比如0等），这称为<strong>填充</strong>（padding），使用填充主要是为了调整输出的大小。</p><h5 id="步幅">步幅</h5><p>应用滤波器的位置间隔称为<strong>步幅</strong>（stride）。增大步幅后，输出大小会变小。而增大填充后，输出大小会变大。</p><p>假设输入大小为(H, W)，滤波器大小为(FH, FW)，输出大小为(OH,OW)，填充为P，步幅为S。此时，输出大小可通过下列公式进行计算。 <spanclass="math display">\[\displaylines {OH = \frac{H+2P-FH}{S} + 1\\OW = \frac{W+2P-FW}{S} + 1}\]</span></p><h5 id="批处理">批处理</h5><p>神经网络的处理中进行了将输入数据打包的批处理。</p><center><img src="cnn_bat.png" alt="卷积运算的批处理" style="zoom:33%;" /><br/><br/> 图： 卷积运算的批处理</center><h4 id="池化层">池化层</h4><p>池化是缩小高、长方向上的空间的运算。</p><p>常用的池化方法有Max池化、Average池化等。</p><h5 id="max池化">Max池化</h5><p>Max池化是从目标区域中取出最大值。</p><h5 id="average池化">Average池化</h5><p>Average池化则是计算目标区域的平均值。</p><h5 id="池化层的特征">池化层的特征</h5><ol type="1"><li>没有要学习的参数池化层和卷积层不同，没有要学习的参数。池化只是从目标区域中取最大值（或者平均值），所以不存在要学习的参数。</li><li>通道数不发生变化经过池化运算，输入数据和输出数据的通道数不会发生变化。计算是按通道独立进行的。</li><li>对微小的位置变化具有鲁棒性（健壮）输入数据发生微小偏差时，池化仍会返回相同的结果。因此，池化对输入数据的微小偏差具有鲁棒性。</li></ol><h4 id="代表性的cnn网络结构">代表性的CNN网络结构</h4><h5 id="lenet">LeNet</h5><p>LeNet在1998年被提出，是进行手写数字识别的网络，它有连续的卷积层和池化层（正确地讲，是只“抽选元素”的子采样层），最后经全连接层输出结果。LeNet中使用sigmoid激活函数</p><h5 id="alexnet">AlexNet</h5><p>AlexNet叠有多个卷积层和池化层，最后经由全连接层输出结果。AlexNet的特点：</p><ol type="1"><li>激活函数使用ReLU。</li><li>使用进行局部正规化的LRN（Local Response Normalization）层 。</li><li>使用Dropout。</li></ol><h3 id="深度学习">深度学习</h3><h4 id="为什么要加深层">为什么要加深层?</h4><ol type="1"><li>层越深，识别性能也越高。</li><li>可以减少网络的参数数量。</li><li>叠加小型滤波器来加深网络的好处是可以减少参数的数量，扩大感受野（receptive field，给神经元施加变化的某个局部空间区域）。并且，通过叠加层，将ReLU等激活函数夹在卷积层的中间，进一步提高了网络的表现力。这是因为向网络添加了基于激活函数的“非线性”表现力，通过非线性函数的叠加，可以表现更加复杂的东西。</li><li>加深层的另一个好处就是使学习更加高效。</li></ol><h4 id="其他的网络结构">其他的网络结构</h4><h5 id="vgg">VGG</h5><p>VGG是由卷积层和池化层构成的基础的CNN。</p><h5 id="googlenet">GoogleNet</h5><p>GoogleNet的特征是，网络不仅在纵向上有深度，在横向上也有深度（广度）。GoogleNet在横向上有“宽度”，这称为“Inception结构”。</p><h5 id="resnet">ResNet</h5><p>ResNet是微软团队开发的网络。它的特征在于具有比以前的网络更深的结构。</p><p>《深度学习入门：基于Python的理论与实现》是一本非常好的入门书，本文的内容就来自于对这本书的整理。</p>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python知识点</title>
    <link href="/2024/07/16/python%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2024/07/16/python%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="python函数的参数">Python函数的参数</h3><hr /><p>python函数的主要参数类型有：默认参数、关键字参数（位置参数）、不定长参数。</p><h5 id="默认参数">默认参数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"> a , b , c = <span class="hljs-number">0</span> </span>):<br>    <span class="hljs-comment"># 打印参数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数a：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(a) , end = <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数b：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(b) , end = <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数c：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(c))<br>    <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment"># 调用 func 函数</span><br>func( <span class="hljs-string">&#x27;a&#x27;</span> , <span class="hljs-number">10</span> , <span class="hljs-number">12</span>)<br>func( <span class="hljs-string">&#x27;b&#x27;</span> , <span class="hljs-number">100</span> )<br></code></pre></td></tr></table></figure><p>输出：</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">&gt;参数<span class="hljs-selector-tag">a</span>：<span class="hljs-selector-tag">a</span> 参数<span class="hljs-selector-tag">b</span>：<span class="hljs-number">10</span> 参数c：<span class="hljs-number">12</span><br>&gt;参数<span class="hljs-selector-tag">a</span>：<span class="hljs-selector-tag">b</span> 参数<span class="hljs-selector-tag">b</span>：<span class="hljs-number">100</span> 参数c：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></blockquote><p>当设置了默认参数的时候，在调用函数的时候，不传该参数，就会使用默认值</p><p><strong>只有在形参表末尾的那些参数可以有默认参数值</strong>，deffunc(a, b=1) 是有效的，但是 def func(a=1, b) 是 无效 的。</p><p>如果想判断默认参数有没有值传递进来，可以这样设置参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br>_no_value =<span class="hljs-built_in">object</span>()<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"> a , b = _no_value </span>):<br>    <span class="hljs-keyword">if</span> b <span class="hljs-keyword">is</span> _no_value :<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;b 没有赋值&#x27;</span>)<br>    <span class="hljs-keyword">return</span>;<br>func(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>输出:</p><blockquote><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">&gt;<span class="hljs-keyword">b</span> 没有赋值<br></code></pre></td></tr></table></figure></blockquote><h5 id="关键字参数位置参数">关键字参数（位置参数）</h5><p>一般情况下，给函数传参的时候，是按照顺序传递参数的，如果不对应顺序，就会传错值。</p><p>不过在 Python中，可以通过参数名来给函数传递参数，而不用关心参数列表定义时的顺序，这被称之为关键字参数。</p><p>使用关键参数有两个优势 ：</p><ul><li>由于我们不必担心参数的顺序，使用函数变得更加简单了。</li><li>假设其他参数都有默认值，我们可以只给我们想要的那些参数赋值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"> a , b , c = <span class="hljs-number">0</span> </span>):<br>    <span class="hljs-comment"># 打印参数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数a：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(a) , end = <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数b：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(b) , end = <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数c：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(c))<br>    <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment"># 调用 func 函数</span><br>func( a=<span class="hljs-string">&#x27;a&#x27;</span> , b=<span class="hljs-number">10</span> , c=<span class="hljs-number">12</span>)<br>func( a=<span class="hljs-string">&#x27;b&#x27;</span> , c=<span class="hljs-number">100</span>, b=<span class="hljs-number">1000</span> )<br></code></pre></td></tr></table></figure><p>输出：</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">&gt;参数<span class="hljs-selector-tag">a</span>：<span class="hljs-selector-tag">a</span> 参数<span class="hljs-selector-tag">b</span>：<span class="hljs-number">10</span> 参数c：<span class="hljs-number">12</span><br>&gt;参数<span class="hljs-selector-tag">a</span>：<span class="hljs-selector-tag">b</span> 参数<span class="hljs-selector-tag">b</span>：<span class="hljs-number">1000</span> 参数c：<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure></blockquote><p>从输出结果看，在第二次调用的时候，即使用 func( a='b' , c=100, b=1000) 也可以把参数传递到函数执行体。</p><h5 id="不定长参数">不定长参数</h5><p>有些时候，在设计函数的时候，无法确定传入的参数个数。这种情况下，就可以使用不定长参数。</p><p>Python提供了一种元组的方式来接受没有直接定义的参数。这种方式在参数前边加星号<code>*</code> 。</p><p>如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"> a , b , c=<span class="hljs-number">0</span>, *args</span>):<br>    <span class="hljs-comment"># 打印参数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数a：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(a) , end = <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数b：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(b) , end = <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数c：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(c))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数args：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(args))<br>    <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment"># 调用 func 函数</span><br>func( <span class="hljs-string">&#x27;a&#x27;</span> , <span class="hljs-number">10</span> , <span class="hljs-number">12</span>, <span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-string">&quot;345&quot;</span>,<span class="hljs-number">789</span>)<br>func( a=<span class="hljs-string">&#x27;b&#x27;</span> , c=<span class="hljs-number">100</span>, b=<span class="hljs-number">1000</span> )<br></code></pre></td></tr></table></figure><p>输出:</p><blockquote><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less">&gt;参数<span class="hljs-selector-tag">a</span>：<span class="hljs-selector-tag">a</span> 参数<span class="hljs-selector-tag">b</span>：<span class="hljs-number">10</span> 参数<span class="hljs-selector-tag">c</span>：<span class="hljs-number">12</span><br>&gt;参数<span class="hljs-selector-tag">args</span>：(<span class="hljs-string">&#x27;123&#x27;</span>, <span class="hljs-string">&#x27;345&#x27;</span>, <span class="hljs-number">789</span>)<br>&gt;参数<span class="hljs-selector-tag">a</span>：<span class="hljs-selector-tag">b</span> 参数<span class="hljs-selector-tag">b</span>：<span class="hljs-number">1000</span> 参数<span class="hljs-selector-tag">c</span>：<span class="hljs-number">100</span><br>&gt;参数<span class="hljs-selector-tag">args</span>：()<br></code></pre></td></tr></table></figure></blockquote><p>如果需要传不定长的参数<code>*args</code>，那么就不要使用位置参数传递，否则会报错。如果需要通过位置参数的方式传递不定长参数，就需要用<code>**args</code>的方式。使用方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"> a , b , c=<span class="hljs-number">0</span>, **args</span>):<br>    <span class="hljs-comment"># 打印参数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数a：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(a) , end = <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数b：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(b) , end = <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数c：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(c))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数args：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(args))<br>    <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment"># 调用 func 函数</span><br>func( a=<span class="hljs-string">&#x27;a&#x27;</span> , b=<span class="hljs-number">10</span> , c=<span class="hljs-number">12</span>, args=(<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-string">&quot;345&quot;</span>,<span class="hljs-number">789</span>))<br>func( a=<span class="hljs-string">&#x27;b&#x27;</span> , c=<span class="hljs-number">100</span>, b=<span class="hljs-number">1000</span> )<br></code></pre></td></tr></table></figure><p>输出：</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">参数a：a 参数b：10 参数c：12</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">参数args：&#123;<span class="hljs-string">&#x27;args&#x27;</span>: (<span class="hljs-string">&#x27;123&#x27;</span>, <span class="hljs-string">&#x27;345&#x27;</span>, 789)&#125;</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">参数a：b 参数b：1000 参数c：100</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">参数args：&#123;&#125;</span><br></code></pre></td></tr></table></figure></blockquote><p>通过对比两个例子，可以知道，<code>*args</code>是可变参数，且args其实就是一个 tuple （元组），<code>**args</code>是关键字参数，且args 就是一个 dict （字典）</p><h5 id="只接受关键字参数">只接受关键字参数</h5><p>关键字参数使用简单，不容易出错，如果希望某些参数强制使用关键字参数传递，这时候该怎么办呢？</p><p>将强制关键字参数放到某个<code>*</code>参数或者单个<code>*</code>后面就能达到这种效果,比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"> a , *, b , c=<span class="hljs-number">0</span></span>):<br>    <span class="hljs-comment"># 打印参数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数a：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(a) , end = <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数b：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(b) , end = <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数c：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(c))<br>    <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment"># 调用 func 函数</span><br>func( a=<span class="hljs-string">&#x27;a&#x27;</span> , b=<span class="hljs-number">10</span> , c=<span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure><p>在这个代码中，函数的参数中，在参数<code>a</code>的后面加了<code>*</code>,那么参数<code>b</code>和参数<code>c</code>就要使用关键字参数。否则就会报错。</p><p>func( 'a' , 10 ) 或者 func( 'a' , b=10,100) 这样的传参调用就会报错，func( 'a' , b=10 ) 或者 func( a='a' , b=10,c=a00 )则没有问题。</p><p>原因就在于 *之后的参数必须用关键字参数传递，如果最后一个有默认值则可以不传递。</p><h3 id="类与对象">类与对象</h3><hr /><p>面向对象有两个基本的概念，分别是类和对象。面向对象的编程语言，也有三大特性，继承，多态和封装性。</p><h5 id="新式类与旧式类经典类">新式类与旧式类（经典类）</h5><p>Python2.x中，默认都是经典类，只有显式继承了object的才是新式类，即：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Person</span>(<span class="hljs-symbol">object</span>):<span class="hljs-symbol">pass</span>    新式类<br><span class="hljs-symbol">class</span> <span class="hljs-symbol">Person</span>():<span class="hljs-symbol">pass</span>    经典类<br></code></pre></td></tr></table></figure><p>在<ahref="https://so.csdn.net/so/search?q=Python&amp;spm=1001.2101.3001.7020">Python</a>3.x中取消了经典类，默认都是新式类，并且不必显式的继承object，也就是说：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Person</span>(<span class="hljs-symbol">object</span>):<span class="hljs-symbol">pass</span>    新式类<br><span class="hljs-symbol">class</span> <span class="hljs-symbol">Person</span>():<span class="hljs-symbol">pass</span>     新式类<br></code></pre></td></tr></table></figure><p><code>新式类</code>和<code>经典类（旧式类）</code>的<code>区别</code>的在于<code>子类多继承</code>的情况下，<code>经典类</code>多继承搜索顺序是<code>深度优先</code>，<code>新式类</code>多继承搜索顺序是<code>广度优先</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#这里基类Person显式的继承了object</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, I&#x27;m Person.&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, I&#x27;m Man.&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Woman</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, I&#x27;m Woman.&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span>(Man,Woman):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>child = Child()<br>child.say_hello()<br></code></pre></td></tr></table></figure><p>输出：</p><blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">&gt;Hello, I<span class="hljs-symbol">&#x27;m</span> Man.<br></code></pre></td></tr></table></figure></blockquote><p>如果注释掉 Man的say_hello方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#这里基类Person显式的继承了object</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, I&#x27;m Person.&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-comment"># def say_hello(self):</span><br>    <span class="hljs-comment">#     print(&quot;Hello, I&#x27;m Man.&quot;)</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Woman</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, I&#x27;m Woman.&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span>(Man,Woman):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>child = Child()<br>child.say_hello()<br><br></code></pre></td></tr></table></figure><p>输出:</p><blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">&gt;Hello, I<span class="hljs-symbol">&#x27;m</span> Woman.<br></code></pre></td></tr></table></figure></blockquote><p>child继承了Man和Woman两个类，新式类机制下，child先调用man的say_hello方法，如果man没有该方法，则调用Woman下的say_hello方法，是广度优先调用策略。如果是深度优先，child会优先调用man的say_hello方法，如果没有，然后会调用man的父类的方法。</p><h5 id="调用类的属性和方法">调用类的属性和方法</h5><p>类里面定义的变量是属性，类里面定义的函数是方法。</p><p>调用格式：类.变量 、 类.方法</p><h5 id="类方法">类方法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    a = <span class="hljs-number">1</span><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">funcA</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a=&quot;</span>,cls.a)<br>        <br>    <span class="hljs-comment">#def funcB():</span><br>    <span class="hljs-comment">#    print(&quot;a=&quot;,a) #无法调用类属性</span><br>        <br>obj = ClassA()<br>obj.funcA()<br>ClassA.funcA()<br></code></pre></td></tr></table></figure><p>类方法调用类属性，需要以下步骤：</p><ul><li>在方法上面，用 <code>@classmethod</code>声明该方法是类方法。只有声明了是类方法，才能使用类属性</li><li>类方法想要使用类属性，在第一个参数中，需要写上 <code>cls</code> ,cls 是 class的缩写，其实意思就是把这个类作为参数，传给自己，这样就可以使用类属性了。</li><li>类属性的使用方式就是 <code>cls.变量名</code></li></ul><p>无论是 <code>@classmethod</code> 还是 <code>cls</code>,都是不能省去的。</p><h5 id="增加和修改类的属性">增加和修改类的属性</h5><p>有两种方法可以修改和增加类的属性，在类的内部和类的外部</p><p>类的内外部部修改、添加属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    a = <span class="hljs-number">1</span><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a=&quot;</span>,cls.a)<br>        cls.a = <span class="hljs-number">3</span> <span class="hljs-comment">#内部修改属性</span><br>        cls.b = <span class="hljs-number">2</span> <span class="hljs-comment">#内部添加属性 </span><br>        <br>obj = ClassA()<br>obj.func()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;内部修改后 a =&quot;</span>, ClassA.a)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;内部添加 b =&quot;</span>, ClassA.b)<br><br>ClassA.a = <span class="hljs-number">4</span> <span class="hljs-comment">#外部修改属性</span><br>ClassA.c = <span class="hljs-number">5</span> <span class="hljs-comment">#外部添加属性</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;外部修改后 a =&quot;</span>, ClassA.a)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;外部添加 c =&quot;</span>, ClassA.c)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a=&quot;</span>,obj.a,<span class="hljs-string">&quot;b=&quot;</span>,obj.b,<span class="hljs-string">&quot;c=&quot;</span>,obj.c)<br></code></pre></td></tr></table></figure><p>输出:</p><blockquote><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&gt;a<span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>&gt;内部修改后 a <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>&gt;内部添加 b <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>&gt;外部修改后 a <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>&gt;外部添加 c <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br>&gt;a<span class="hljs-operator">=</span> <span class="hljs-number">4</span> b<span class="hljs-operator">=</span> <span class="hljs-number">2</span> c<span class="hljs-operator">=</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></blockquote><h5id="类属性与实例属性类方法与实例方法">类属性与实例属性、类方法与实例方法</h5><p>先说结论：</p><blockquote><p><strong>类属性改变了，实例属性会跟着改变。</strong><strong>实例属性改变了，类属性不会改变</strong>。</p><p><strong>类方法改变了，实例方法会跟着改变。</strong><strong>实例方法改变了，类方法不会改变(会报错)。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    a = <span class="hljs-number">1</span><br><br>    <span class="hljs-comment">#类方法</span><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a=&quot;</span>,cls.a)<br>    <span class="hljs-comment">#实例方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;func1 a=&quot;</span>, self.a)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func2</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;func2&quot;</span>)<br>        <br>obj = ClassA()<br>obj.func()<br>obj.func1()<br><span class="hljs-comment"># obj.func2() #报错</span><br><br>ClassA.func()<br><span class="hljs-comment"># ClassA.func1() #报错</span><br>ClassA.func2()<br></code></pre></td></tr></table></figure><p>类属性与实例属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    a = <span class="hljs-number">1</span><br><br>    <span class="hljs-comment">#类方法</span><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a=&quot;</span>,cls.a)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;func1 a=&quot;</span>, self.a)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func2</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;func2&quot;</span>)<br>        <br>obj = ClassA()<br>obj.func()<br>obj.func1()<br><span class="hljs-comment"># obj.func2() #报错</span><br><br>ClassA.func()<br><span class="hljs-comment"># ClassA.func1() #报错</span><br>ClassA.func2()<br><br>ClassA.a = <span class="hljs-number">3</span> <span class="hljs-comment">#修改类属性</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;类属性修改为：&quot;</span>,ClassA.a) <span class="hljs-comment">#实例属性由1 改为 3</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;实例属性修改为：&quot;</span>,obj.a) <span class="hljs-comment">#实例属性由1 改为 3</span><br>obj.a = <span class="hljs-number">4</span> <span class="hljs-comment"># 修改实例属性为4</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;实例属性修改为：&quot;</span>, obj.a)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;类属性：&quot;</span>, ClassA.a) <span class="hljs-comment">#修改实例属性，类属性不变</span><br></code></pre></td></tr></table></figure><p>输出</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">a= 1</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">func1 a= 1</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">a= 1</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">func2</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">类属性修改为： 3</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">实例属性修改为： 3</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">实例属性修改为： 4</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">类属性： 3</span><br></code></pre></td></tr></table></figure></blockquote><p>类方法与实例方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    a = <span class="hljs-number">1</span><br><br>    <span class="hljs-comment">#类方法</span><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a=&quot;</span>,cls.a)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;func1 a=&quot;</span>, self.a)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func3</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;func3&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func2</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;func2&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">newfunc</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这是新方法&quot;</span>)<br>        <br>obj = ClassA()<br>obj.func()<br>obj.func1()<br><span class="hljs-comment"># obj.func2() #报错</span><br><br>ClassA.func()<br><span class="hljs-comment"># ClassA.func1() #报错</span><br>ClassA.func2()<br><br>ClassA.func1 = newfunc <span class="hljs-comment">#修改类的方法</span><br>obj.func1() <span class="hljs-comment"># 实例方法改变</span><br><br>obj.func3 = newfunc<br>obj.func3()  <span class="hljs-comment">#会报错</span><br></code></pre></td></tr></table></figure><p>输出:</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">a= 1</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">func1 a= 1</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">a= 1</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">func2</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">这是新方法</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">---------------------------------------------------------------------------</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">TypeError                                 Traceback (most recent call last)</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">Cell In[101], line 34</span><br>    31 obj.func1() # 实例方法改变<br>    33 obj.func3 = newfunc<br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">---&gt; 34 obj.func3()  <span class="hljs-comment">#会报错</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">TypeError: newfunc() missing 1 required positional argument: <span class="hljs-string">&#x27;self&#x27;</span></span><br></code></pre></td></tr></table></figure></blockquote><h5 id="类中的函数">类中的函数</h5><p>构造函数（初始化函数），在创建实例的时候会自动调用<code>__init__(self)</code></p><p>析构函数:当销毁一个实例对象的时候，会自动调用<code>__del__(self)</code></p><h5 id="类的继承重写">类的继承、重写</h5><p>Python支持多继承，格式如下所示，如果是单独定义的一个类，也建议继承object，因为object是一切类的基类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>(Base1,Base2,Base3):<br>    &lt;statement-<span class="hljs-number">1</span>&gt;<br>    .<br>    .<br>    .<br>    &lt;statement-N&gt;<br></code></pre></td></tr></table></figure><p>类的重写</p><p>子类在继承父类的情况下，如果子类没有定义自己的构造函数<code>__init__</code>，也会调用父类的构造函数<code>__init__</code>，如果定义了构造函数<code>__init__</code>,就是重写了父类的构造函数。如果重写了父类的构造函数，还需要调用父类的构造函数，则通过<code>super()</code>方式调用。</p><p><strong>super() 在 python2、3中的区别</strong>：</p><p>Python3.x 和 Python2.x 的一个区别: Python 3 可以使用直接使用super().xxx 代替 super(Class, self).xxx :</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">python3 直接写成 ： super()<span class="hljs-selector-class">.__init__</span>()<br>python2 必须写成 ：super(本类名,self)<span class="hljs-selector-class">.__init__</span>()<br></code></pre></td></tr></table></figure><p>Python3.x中的重写例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):<br>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, x</span>):<br>         y = x+<span class="hljs-number">1</span><br>         <span class="hljs-built_in">print</span>(y)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, x</span>):  <span class="hljs-comment">#重写父类方法</span><br>        <span class="hljs-built_in">super</span>().add(x)  <span class="hljs-comment">#调用父类方法</span><br>b = B()<br>b.add(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 3</span><br></code></pre></td></tr></table></figure><p>python2.x中的重写例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):   <span class="hljs-comment"># Python2.x 记得继承 object</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, x</span>):<br>         y = x+<span class="hljs-number">1</span><br>         <span class="hljs-built_in">print</span>(y)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, x</span>): <span class="hljs-comment">#重写父类方法</span><br>        <span class="hljs-built_in">super</span>(B, self).add(x) <span class="hljs-comment">#调用父类方法</span><br>b = B()<br>b.add(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 3</span><br><br></code></pre></td></tr></table></figure><h5 id="类的多态">类的多态</h5><p>类的多态指对不同类型的变量进行相同的操作，它会根据对象（或类）类型的不同而表现出不同的行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">printUser</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello !&#x27;</span> + self.name)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserVip</span>(<span class="hljs-title class_ inherited__">User</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">printUser</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello ! 尊敬的Vip用户：&#x27;</span> + self.name)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserGeneral</span>(<span class="hljs-title class_ inherited__">User</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">printUser</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello ! 尊敬的用户：&#x27;</span> + self.name)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">printUserInfo</span>(<span class="hljs-params">user</span>):<br>    user.printUser()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    userVip = UserVip(<span class="hljs-string">&#x27;VIP&#x27;</span>)<br>    printUserInfo(userVip)<br>    userGeneral = UserGeneral(<span class="hljs-string">&#x27;普通用户&#x27;</span>)<br>    printUserInfo(userGeneral)<br><br></code></pre></td></tr></table></figure><p>输出</p><blockquote><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">&gt;Hello ! 尊敬的Vip用户：VIP<br>&gt;Hello ! 尊敬的用户：普通用户<br></code></pre></td></tr></table></figure></blockquote><p>从输出可以看到 根据对象的不同调用不同的实例方法。</p><h5 id="重载与重写">重载与重写</h5><p><strong>重写</strong>子类对父类的允许访问的方法的实现过程进行重新编写,返回值和形参都不能改变。</p><p><strong>优点：</strong>子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法。</p><p><strong>重载</strong>(overloading)是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p><p>*重载与重写的区别**</p><ol type="1"><li>方法重载是一个类中定义了多个方法名相同，而他们的参数的数量不同或数量相同而类型和次序不同，则称为方法的重载。</li><li>方法重写是在子类存在方法与父类的方法的名字相同，而且参数的个数与类型一样，返回值也一样的方法，就称为重写。</li><li>方法重载是一个类的多态性表现，而方法重写是子类与父类的一种多态性表现。</li></ol><h5 id="类的封装">类的封装</h5><p>创建一个类，实际上是将具有特定属性或功能的数据或方法，“打包”定义到一个模块中，供我们需要时调用它们。这个打包的行为，我们也称“类的封装”。</p><p>如何管理和使用被封装在类中的属性或者方法，就需用到类的访问控制。</p><h5 id="类的访问控制">类的访问控制</h5><p><strong>属性的访问控制</strong></p><p>在python中，一般情况下，会使用 <code>__private_attrs</code>两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时<code>self.__private_attrs</code>。</p><p>实际上， Python 中是没有提供私有属性等功能的。Python对属性的访问控制是靠程序员自觉的。</p><p><strong>方法的访问控制</strong></p><p>方法的访问控制也是跟属性是一样的，也是没有实质上的私有方法。一切都是靠程序员自觉遵守Python 的编程规范，具体规则也是跟属性一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, account</span>):<br>        self.name = name<br>        self._age = age<br>        self.__account = account <span class="hljs-comment">#私有属性</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">upgrade</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_buy_equipment</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__pk</span>(<span class="hljs-params">self</span>): <span class="hljs-comment"># 私有方法</span><br>        <span class="hljs-keyword">pass</span><br><br></code></pre></td></tr></table></figure><h5 id="类专有的方法">类专有的方法</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>__init__</code></td><td>构造函数，在生成对象时调用</td></tr><tr><td><code>__del__</code></td><td>析构函数，释放对象时使用</td></tr><tr><td><code>__repr__</code></td><td>打印，转换</td></tr><tr><td><code>__setitem__</code></td><td>按照索引赋值</td></tr><tr><td><code>__getitem__</code></td><td>按照索引获取值</td></tr><tr><td><code>__len__</code></td><td>获得长度</td></tr><tr><td><code>__cmp__</code></td><td>比较运算</td></tr><tr><td><code>__call__</code></td><td>函数调用</td></tr><tr><td><code>__add__</code></td><td>加运算</td></tr><tr><td><code>__sub__</code></td><td>减运算</td></tr><tr><td><code>__mul__</code></td><td>乘运算</td></tr><tr><td><code>__div__</code></td><td>除运算</td></tr><tr><td><code>__mod__</code></td><td>求余运算</td></tr><tr><td><code>__pow__</code></td><td>乘方</td></tr></tbody></table><p>需要获取类的相关信息，我们可以使用如下的方法：</p><ul><li><code>type(obj)</code>：来获取对象的相应类型；</li><li><code>isinstance(obj, type)</code>：判断对象是否为指定的 type类型的实例；</li><li><code>hasattr(obj, attr)</code>：判断对象是否具有指定属性/方法；</li><li><code>getattr(obj, attr[, default])</code> 获取属性/方法的值,要是没有对应的属性则返回 default 值（前提是设置了 default），否则会抛出AttributeError 异常；</li><li><code>setattr(obj, attr, value)</code>：设定该属性/方法的值，类似于obj.attr=value；</li><li><code>dir(obj)</code>：可以获取相应对象的所有属性和方法名的列表：</li></ul><h3 id="闭包与装饰器">闭包与装饰器</h3><h5 id="闭包">闭包</h5><p><strong>闭包</strong>是指一个函数可以记住其外部变量并可以访问这些变量。</p><p>举个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num</span>):<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + num<br>    <span class="hljs-keyword">return</span>  <span class="hljs-built_in">sum</span><br><br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">2</span>)) <span class="hljs-comment">#报错 UnboundLocalError: cannot access local variable &#x27;sum&#x27; where it is not associated with a value</span><br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">10</span>)) <br></code></pre></td></tr></table></figure><p>比如要做一个求和，第7行会报错。因为，在 Python中，如果一个函数使用了和全局变量相同的名字且改变了该变量的值，那么该变量就会变成局部变量，那么就会造成在函数中我们没有进行定义就引用了，所以会报该错误。</p><p>如果要引用全局变量，并在函数中对它进行修改，请使用global关键字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num</span>):<br>    <span class="hljs-keyword">global</span> <span class="hljs-built_in">sum</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + num<br>    <span class="hljs-keyword">return</span>  <span class="hljs-built_in">sum</span><br><br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><p>输出:</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">12</span><br></code></pre></td></tr></table></figure></blockquote><p>使用全局变量的缺点：不同模块，不同函数都可以自由的访问全局变量，可能会造成全局变量的不可预知性。</p><p>可是使用<strong>闭包</strong>来解决。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_num</span>(<span class="hljs-params"><span class="hljs-built_in">sum</span></span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num</span>):<br>        <span class="hljs-keyword">nonlocal</span> <span class="hljs-built_in">sum</span><br>        <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + num<br>        <span class="hljs-keyword">return</span>  <span class="hljs-built_in">sum</span><br>    <span class="hljs-keyword">return</span> add<br><br>func = add_num(<span class="hljs-built_in">sum</span>)<br><span class="hljs-built_in">print</span>(func.__closure__) <br><span class="hljs-built_in">print</span>(func(<span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>)<br><span class="hljs-built_in">print</span>(func(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>)<br></code></pre></td></tr></table></figure><p>输出</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">(&lt;cell at 0x7f8c1d5d9480: int object at 0x94f1e8&gt;,)</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">0</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">12</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">0</span><br></code></pre></td></tr></table></figure></blockquote><p>在这段代码中，add_sum中 嵌套了一个函数add,add通过nonlocal关键字访问外部变量(add_sum的参数)sum，而最外层的sum变量并没有受到影响（依旧为0）。</p><p>在这里可以把global和nonlocal做一个区分：</p><p>两个关键词都用于允许在一个局部作用域中使用外层的变量。</p><ul><li>global 表示将变量声明为全局变量</li><li>nonlocal表示将变量声明为外层变量（外层函数的局部变量，而且不能是全局变量）</li><li>在使用 nonlocal a 之前，必须保证外层的确已经定义过 a 了，但是在global a的时候，可以允许全局变量中还没有定义过a，可以留在后面定义。</li></ul><p>python 在访问一个变量时，先要去定位这个变量来源于哪里。</p><p>python引用变量的顺序如下：</p><ol type="1"><li>当前作用域局部变量</li><li>外层作用域变量</li><li>当前模块中的全局变量</li><li>python内置变量</li></ol><p>即优先从局部作用域中查找这个变量，如果没有的话，再去外层找，如果到了最后还没找到，则报错。</p><p>这种内部函数的局部作用域中可以访问外部函数局部作用域中变量的行为，我们称为：闭包。更加直接的表达方式就是，当某个函数被当成对象返回时，夹带了外部变量，就形成了一个闭包。所有函数都有一个<code>__closure__</code> 属性，如果函数是闭包的话，那么它返回的是一个由cell 组成的元组对象。cell 对象的 cell_contents属性就是存储在闭包中的变量。如上面 的代码print(func.<code>__closure__</code> ) ，则可以得到输出 (&lt;cell at0x7f8c1d5d9480: int object at 0x94f1e8&gt;,)</p><h5 id="装饰器">装饰器</h5><p><strong>装饰器</strong>是修改其他函数的功能的函数。装饰器的实现就可以通过闭包来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;简单函数&#x27;</span>)<br>func()<br></code></pre></td></tr></table></figure><p>给这个简单的函数加点东西，比如输出时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>, time.localtime(time.time())))  <span class="hljs-comment"># 输出时间</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;简单函数&#x27;</span>)<br>func()<br></code></pre></td></tr></table></figure><p>在原来的基础上修改可以达到要求，但是不符合开闭原则（对扩展开放,对修改封闭），那么可以修改为如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;简单函数&#x27;</span>)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">new_func</span>():<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;新函数&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_time</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-built_in">print</span>(time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>, time.localtime(time.time())))<br>    func()<br><br>add_time(func)<br>add_time(new_func)<br></code></pre></td></tr></table></figure><p>通过添加add_time(func)这个功能函数，可以为任意的函数添加输出时间的功能。</p><p>这种方式虽然可以满足要求，但是写法上不好判断是哪个函数装饰哪个函数，有没有更好的写法呢?是有的，这个写法和闭包的写法有点相似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment">#装饰函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_time</span>():<br>        <span class="hljs-built_in">print</span>(time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>, time.localtime(time.time())))<br>        func() <br>    <span class="hljs-keyword">return</span> add_time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;简单函数&#x27;</span>)<br><br>f = decorator(func) <span class="hljs-comment"># 返回的函数对象</span><br>f()  <span class="hljs-comment"># 使用返回的函数对象调用函数</span><br></code></pre></td></tr></table></figure><p>在这段代码中，把add_time作为装饰函数的内部函数，把待装饰的函数传入装饰函数，并返回一个装饰的函数对象，通过调用这个返回的函数对象，就可以实现以上代码的功能，这中写法更简洁。</p><p>通过代码，能知道装饰器函数一般做这三件事：</p><ol type="1"><li>接收一个函数作为参数</li><li>嵌套一个包装函数,包装函数会接收原函数的相同参数，并执行原函数，且还会执行附加功能</li><li>返回嵌套函数。</li></ol><p>当然，有了装饰器函数， Python 设计出了 <code>@</code> 语法糖，让定义装饰器，把装饰器调用原函数再把结果赋值为原函数的对象名的过程变得更加简单，方便，易操作，所以Python装饰器的核心可以说就是它的语法糖。使用了语法糖的装饰器用法，有点像java中的注解。把上面的代码改为使用<code>@</code>语法糖的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment">#装饰函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_time</span>():<br>        <span class="hljs-built_in">print</span>(time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>, time.localtime(time.time())))<br>        func() <br>    <span class="hljs-keyword">return</span> add_time<br><br><span class="hljs-meta">@decorator  </span><span class="hljs-comment">#将装饰函数加到待装饰的函数上面，就可以为待装饰函数增添新的功能。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;简单函数&#x27;</span>)<br><br>func()<br></code></pre></td></tr></table></figure><p>通过使用<code>@</code>语法糖，将装饰函数加到待装饰的函数上面，就可以为待装饰函数增添新的功能。而且调用方式也与正常的调用方式保持一致，不需要通过函数对象的方式调用了。</p><h6 id="python内置的装饰器">python内置的装饰器</h6><table><thead><tr><th>装饰器</th><th>说明</th></tr></thead><tbody><tr><td><span class="citation" data-cites="lru_cache">@lru_cache</span></td><td>使用缓存技巧加速</td></tr><tr><td><span class="citation"data-cites="total_ordering">@total_ordering</span></td><td>根据定义的方法为 Python 类生成缺少的比较方法。</td></tr><tr><td><span class="citation"data-cites="contextmanager">@contextmanager</span></td><td>Python 有一个上下文管理器机制来帮助你正确地管理资源。</td></tr><tr><td><span class="citation" data-cites="property">@property</span></td><td>使用 <span class="citation" data-cites="property">@property</span>装饰器可以设置每个类属性的getter和setter方法。</td></tr><tr><td><span class="citation"data-cites="cached_property">@cached_property</span></td><td>Python 3.8 为 functool 模块引入了一个新的强大装饰器——<spanclass="citation"data-cites="cached_property">@cached_property</span>。它可以将一个类的方法转换为一个属性，该属性的值计算一次，然后在实例的生命周期内作为普通属性缓存。</td></tr><tr><td><span class="citation"data-cites="classmethod">@classmethod</span></td><td>要定义一个类方法，我们需要使用@classmethod 装饰器。</td></tr><tr><td><span class="citation"data-cites="staticmethod">@staticmethod</span></td><td>要定义一个静态方法，我们只需要使用@staticmethod 装饰器</td></tr><tr><td><span class="citation" data-cites="dataclass">@dataclass</span></td><td><span class="citation"data-cites="dataclass装饰器">@dataclass装饰器</span>（Python3.7引入）可以自动为一个类生成几个特殊的方法，如<strong>init</strong>、<strong>repr</strong>、<strong>eq</strong>、<strong>lt</strong>等。</td></tr><tr><td><span class="citation"data-cites="atexit.register">@atexit.register</span></td><td>来自 atexit 模块的 <span class="citation"data-cites="register">@register</span> 装饰器可以让我们在 Python解释器退出时执行一个函数。</td></tr></tbody></table><p>具体请参考这里的<ahref="https://cloud.tencent.com/developer/article/2210650">示例</a></p><h3 id="进程与线程">进程与线程</h3><p>进程是操作系统进行资源分配的最小单元，线程是操作系统进行运算调度的最小单元。</p><p>进程一般由程序、数据集合和进程控制块三部分组成：</p><ul><li>程序用于描述进程要完成的功能，是控制进程执行的指令集</li><li>数据集合是程序在执行时所需要的数据和工作区</li><li>程序控制块，包含进程的描述信息和控制信息，是进程存在的唯一标志</li></ul><p><strong>区别</strong></p><ul><li><strong>本质区别</strong>：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</li><li><strong>从属关系不同</strong>:进程中包含了线程，线程属于进程。一个进程可以有很多线程，每条线程并行执行不同的任务。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</li><li><strong>开销不同</strong>：进程的创建、销毁和切换的开销都远大于线程。由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统内多个程序间并发执行的程度，从而显著提高系统资源的利用率和吞吐量。</li><li><strong>拥有资源不同</strong>：每个进程有自己的内存和资源，一个进程中的线程会共享这些内存和资源。进程是资源分配的基本单位。所有与该进程有关的资源，都被记录在进程控制块PCB中。以表示该进程拥有这些资源或正在使用它们。另外，进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。</li><li><strong>控制和影响能力不同</strong>：子进程无法影响父进程，而子线程可以影响父线程，如果主线程发生异常会影响其所在进程和子线程。与进程相对应，线程与资源分配无关，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。</li><li><strong>CPU利用率不同</strong>：进程的CPU利用率较低，因为上下文切换开销较大，而线程的CPU的利用率较高，上下文的切换速度快。在多核或多CPU，或支持Hyper-threading的CPU上使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I/O处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，从而提高了程序的执行效率。</li></ul><h5 id="python的多线程">Python的多线程</h5><p>线程的状态可以分为</p><ul><li>New 创建</li><li>Runnable 就绪。等待调度</li><li>Running 运行</li><li>Blocked 阻塞。阻塞可能在 Wait Locked Sleeping</li><li>Dead 消亡</li></ul><p>线程的类型可分为：</p><ul><li>主线程</li><li>子线程</li><li>守护线程（后台线程）</li><li>前台线程</li></ul><p>Python 提供两个模块进行多线程的操作，分别是 <code>thread</code> 和<code>threading</code></p><p>Thread是比较低级的模块，用于更底层的操作。因此，主要用threading多一些。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> threading<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubThread</span>(threading.Thread):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;thread &#123;&#125;, @number: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self.name, i))<br>            time.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Start main threading&quot;</span>)<br><br>    <span class="hljs-comment"># 创建三个线程</span><br>    threads = [SubThread() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]<br>    <span class="hljs-comment"># 启动三个线程</span><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>        t.start()<br>    <span class="hljs-comment"># 让新创建的线程执行 join,等待子线程执行</span><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>        t.join()<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;End Main threading&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure><h5 id="线程同步">线程同步</h5><p>多线程会造成数据不同步的问题，在这种情况下，就要使用锁机制。pythonThreading模块提供了Lock功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">lock = threading.Lock()<br>lock.acquire()<br>lock.release()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> threading<br><br>shared_resource_lock = threading.Lock()<br><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubThread</span>(threading.Thread):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, threadname, startnum, endnum</span>):<br>        threading.Thread.__init__(self)<br>        self._threadname = threadname<br>        self._startnum = startnum<br>        self._endnum = endnum<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">global</span> <span class="hljs-built_in">sum</span><br>        shared_resource_lock.acquire() <span class="hljs-comment">#加锁</span><br>        <span class="hljs-comment"># print(self._startnum, self._endnum)</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self._startnum, self._endnum+<span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># print(i)</span><br>            <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + i<br>            time.sleep(<span class="hljs-number">0.1</span>)<br>        <span class="hljs-built_in">print</span>(self._threadname,<span class="hljs-string">&quot;计算结果&quot;</span>,<span class="hljs-built_in">sum</span>)<br>        shared_resource_lock.release() <span class="hljs-comment"># 释放锁</span><br>    <br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Start main threading&quot;</span>)<br><br>    <span class="hljs-comment"># 创建三个线程</span><br>    threads = [SubThread(<span class="hljs-string">&quot;线程&quot;</span>+<span class="hljs-built_in">str</span>(i), i*<span class="hljs-number">20</span>+<span class="hljs-number">1</span>, (i+<span class="hljs-number">1</span>)*<span class="hljs-number">20</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)]<br>    <span class="hljs-comment"># 启动三个线程</span><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>        t.start()<br><br>   <span class="hljs-comment"># 一次让新创建的线程执行 join</span><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>        t.join()<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;End Main threading&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure><p>输出:</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">Start main threading</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">线程0 计算结果 210</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">线程1 计算结果 820</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">线程2 计算结果 1830</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">线程3 计算结果 3240</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">线程4 计算结果 5050</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">End Main threading</span><br></code></pre></td></tr></table></figure></blockquote><p>这段代码展示了使用多线程从1到100的求和。5个线程，每个线程负责20个数，最后得到5050的求和结果。为了保证求和的顺利进行，全局变量<code>sum</code>是共享的，所以需要通过加锁保证计算的正确性。</p><h5 id="线程同步的其他方式">线程同步的其他方式</h5><h6 id="可重入锁">可重入锁</h6><p>支持在同一线程中多次请求同一资源，Python提供了可重入锁（RLock）。RLock 内部维护着一个 Lock 和一个 counter变量，counter 记录了 acquire 的次数，从而使得资源可以被多次require。直到一个线程所有的 acquire 都被release，其他的线程才能获得资源。</p><p>r_lock = threading.RLock()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    lock = threading.RLock() <span class="hljs-comment"># 可重入锁</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.total_items = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">self, n</span>):<br>        Box.lock.acquire()<br>        self.total_items += n<br>        Box.lock.release()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self</span>):<br>        Box.lock.acquire()<br>        self.execute(<span class="hljs-number">1</span>)<br>        Box.lock.release()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self</span>):<br>        Box.lock.acquire()<br>        self.execute(-<span class="hljs-number">1</span>)<br>        Box.lock.release()<br><br><span class="hljs-comment">## These two functions run n in separate</span><br><span class="hljs-comment">## threads and call the Box&#x27;s methods</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">adder</span>(<span class="hljs-params">box, items</span>):<br>    <span class="hljs-keyword">while</span> items &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;adding 1 item in the box&quot;</span>)<br>        box.add()<br>        time.sleep(<span class="hljs-number">1</span>)<br>        items -= <span class="hljs-number">1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">remover</span>(<span class="hljs-params">box, items</span>):<br>    <span class="hljs-keyword">while</span> items &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;removing 1 item in the box&quot;</span>)<br>        box.remove()<br>        time.sleep(<span class="hljs-number">1</span>)<br>        items -= <span class="hljs-number">1</span><br><br><span class="hljs-comment">## the main program build some</span><br><span class="hljs-comment">## threads and make sure it works</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    items = <span class="hljs-number">5</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;putting %s items in the box &quot;</span> % items)<br>    box = Box()<br>    t1 = threading.Thread(target=adder, args=(box, items))<br>    t2 = threading.Thread(target=remover, args=(box, items))<br>    t1.start()<br>    t2.start()<br><br>    t1.join()<br>    t2.join()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s items still remain in the box &quot;</span> % box.total_items)<br></code></pre></td></tr></table></figure><h6 id="信号量">信号量</h6><p>使用 semaphore = threading.Semaphore(0) 定义信号量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-string">&quot;&quot;&quot;Using a Semaphore to synchronize threads&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> random<br><br><span class="hljs-comment"># The optional argument gives the initial value for the internal</span><br><span class="hljs-comment"># counter;</span><br><span class="hljs-comment"># it defaults to 1.</span><br><span class="hljs-comment"># If the value given is less than 0, ValueError is raised.</span><br>semaphore = threading.Semaphore(<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">consumer</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;consumer is waiting.&quot;</span>)<br>        <span class="hljs-comment"># Acquire a semaphore</span><br>        semaphore.acquire()<br>        <span class="hljs-comment"># The consumer have access to the shared resource</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Consumer notify : consumed item number %s &quot;</span> % item)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">producer</span>():<br>        <span class="hljs-keyword">global</span> item<br>        time.sleep(<span class="hljs-number">0.5</span>)<br>        <span class="hljs-comment"># create a random item</span><br>        item = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;producer notify : produced item number %s&quot;</span> % item)<br>         <span class="hljs-comment"># Release a semaphore, incrementing the internal counter by one.</span><br>        <span class="hljs-comment"># When it is zero on entry and another thread is waiting for it</span><br>        <span class="hljs-comment"># to become larger than zero again, wake up that thread.</span><br>        semaphore.release()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (<span class="hljs-number">0</span>,<span class="hljs-number">5</span>) :<br>                t1 = threading.Thread(target=producer)<br>                t2 = threading.Thread(target=consumer)<br>                t1.start()<br>                t2.start()<br>                t1.join()<br>                t2.join()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;program terminated&quot;</span>)<br></code></pre></td></tr></table></figure><h6 id="条件">条件</h6><p>condition = Condition()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread, Condition<br><span class="hljs-keyword">import</span> time<br><br>items = []<br>condition = Condition()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">consumer</span>(<span class="hljs-title class_ inherited__">Thread</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        Thread.__init__(self)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">consume</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">global</span> condition<br>        <span class="hljs-keyword">global</span> items<br>        condition.acquire()<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(items) == <span class="hljs-number">0</span>:<br>            condition.wait()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Consumer notify : no item to consume&quot;</span>)<br>        items.pop()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Consumer notify : consumed 1 item&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Consumer notify : items to consume are &quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(items)))<br><br>        condition.notify()<br>        condition.release()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>):<br>            time.sleep(<span class="hljs-number">2</span>)<br>            self.consume()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">producer</span>(<span class="hljs-title class_ inherited__">Thread</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        Thread.__init__(self)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">produce</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">global</span> condition<br>        <span class="hljs-keyword">global</span> items<br>        condition.acquire()<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(items) == <span class="hljs-number">10</span>:<br>            condition.wait()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Producer notify : items producted are &quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(items)))<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Producer notify : stop the production!!&quot;</span>)<br>        items.append(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Producer notify : total items producted &quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(items)))<br>        condition.notify()<br>        condition.release()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>):<br>            time.sleep(<span class="hljs-number">1</span>)<br>            self.produce()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    producer = producer()<br>    consumer = consumer()<br>    producer.start()<br>    consumer.start()<br>    producer.join()<br>    consumer.join()<br></code></pre></td></tr></table></figure><h6 id="事件">事件</h6><p>Python 还提供了 Event对象用于线程间通信，它是由线程设置的信号标志，如果信号标志位真，则其他线程等待直到信号接触。</p><p>Event对象实现了简单的线程通信机制，它提供了设置信号，清除信号，等待等用于实现线程间的通信。</p><ul><li>设置信号</li></ul><p>使用 Event 的 <code>set()</code> 方法可以设置 Event对象内部的信号标志为真。Event 对象提供了 <code>isSet()</code>方法来判断其内部信号标志的状态。当使用 event 对象的 <code>set()</code>方法后，<code>isSet()</code> 方法返回真</p><ul><li>清除信号</li></ul><p>使用 Event 对象的 <code>clear()</code> 方法可以清除 Event对象内部的信号标志，即将其设为假，当使用 Event 的 clear 方法后，isSet()方法返回假</p><ul><li>等待</li></ul><p>Event 对象 wait的方法只有在内部信号为真的时候才会很快的执行并完成返回。当 Event对象的内部信号标志位假时，则 wait 方法一直等待到其为真时才返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread, Event<br><span class="hljs-keyword">import</span> random<br>items = []<br>event = Event()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">consumer</span>(<span class="hljs-title class_ inherited__">Thread</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, items, event</span>):<br>        Thread.__init__(self)<br>        self.items = items<br>        self.event = event<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            time.sleep(<span class="hljs-number">2</span>)<br>            self.event.wait()<br>            item = self.items.pop()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Consumer notify : %d popped from list by %s&#x27;</span> % (item, self.name))<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">producer</span>(<span class="hljs-title class_ inherited__">Thread</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, items, event</span>):<br>        Thread.__init__(self)<br>        self.items = items<br>        self.event = event<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">global</span> item<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>            time.sleep(<span class="hljs-number">2</span>)<br>            item = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">256</span>)<br>            self.items.append(item)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Producer notify : item N° %d appended to list by %s&#x27;</span> % (item, self.name))<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Producer notify : event set by %s&#x27;</span> % self.name)<br>            self.event.<span class="hljs-built_in">set</span>()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Produce notify : event cleared by %s &#x27;</span>% self.name)<br>            self.event.clear()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    t1 = producer(items, event)<br>    t2 = consumer(items, event)<br>    t1.start()<br>    t2.start()<br>    t1.join()<br>    t2.join()<br></code></pre></td></tr></table></figure><h5 id="python的多进程">python的多进程</h5><p>Python 中的多线程其实并不是真正的多线程，如果想要充分地使用多核 CPU的资源，在 Python 中大部分情况需要使用多进程。</p><p>Python 提供了非常好用的多进程包multiprocessing，只需要定义一个函数，Python 会完成其他所有事情。</p><p>借助这个包，可以轻松完成从单进程到并发执行的转换。multiprocessing支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock 等组件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> multiprocessing<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">i</span>):<br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;called function in process: %s&#x27;</span> %i)<br>    <span class="hljs-keyword">return</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    Process_jobs = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        p = multiprocessing.Process(target=foo, args=(i,))<br>        Process_jobs.append(p)<br>        p.start()<br>        p.join()<br></code></pre></td></tr></table></figure><p>创建进程的类：<code>Process([group [, target [, name [, args [, kwargs]]]]])</code></p><ul><li>target 表示调用对象</li><li>args 表示调用对象的位置参数元组</li><li>kwargs表示调用对象的字典</li><li>name为别名</li><li>group实质上不使用</li></ul><h6 id="使用类的形式创建进程">使用类的形式创建进程</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-keyword">import</span> multiprocessing<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClockProcess</span>(multiprocessing.Process):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, interval</span>):<br>        multiprocessing.Process.__init__(self)<br>        self.interval = interval<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        n = <span class="hljs-number">5</span><br>        <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前时间: &#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(time.ctime()))<br>            time.sleep(self.interval)<br>            n -= <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    p = ClockProcess(<span class="hljs-number">3</span>)<br>    p.start()<br><br></code></pre></td></tr></table></figure><h6 id="进程池">进程池</h6><p>因为进程的创建和销毁都需要消耗资源，可以使用进程池的方法批量创建子进程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Pool<br><span class="hljs-keyword">import</span> os, time, random<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">long_time_task</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;进程的名称：&#123;0&#125; ；进程的PID: &#123;1&#125; &#x27;</span>.<span class="hljs-built_in">format</span>(name, os.getpid()))<br>    start = time.time()<br>    time.sleep(random.random() * <span class="hljs-number">3</span>)<br>    end = time.time()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;进程 &#123;0&#125; 运行了 &#123;1&#125; 秒&#x27;</span>.<span class="hljs-built_in">format</span>(name, (end - start)))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主进程的 PID：&#123;0&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(os.getpid()))<br>    p = Pool(<span class="hljs-number">4</span>)  <span class="hljs-comment"># 进程池</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>        p.apply_async(long_time_task, args=(i,))<br>    p.close()<br>    <span class="hljs-comment"># 等待所有子进程结束后在关闭主进程</span><br>    p.join()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;【End】&#x27;</span>)<br></code></pre></td></tr></table></figure><h6 id="后台进程">后台进程</h6><p>如果需要处理比较巨大的任务，又不需要人为干预，将其作为后台进程执行是个非常常用的编程模型。此进程又可以和其他进程并发执行。通过Python的multiprocessing模块的后台进程选项，我们可以让进程在后台运行。</p><p>为了在后台运行进程，我们设置 <code>daemon</code> 参数为<code>True</code></p><p><strong>注意</strong> :后台进程不允许创建子进程。否则，当后台进程跟随父进程退出的时候，子进程会变成孤儿进程。另外，它们并不是Unix的守护进程或服务（daemonsorservices），所以当非后台进程退出，它们会被终结。后台运行进程在主进程结束之后会自动结束。</p><p>更过关于python并行编程的内容请参考<ahref="https://python-parallel-programmning-cookbook.readthedocs.io/zh-cn/latest/chapter2/index.html">这里</a>,<ahref="https://github.com/walter201230/Python/tree/master">教程</a></p><h3 id="模块与包">模块与包</h3><h6 id="模块">模块</h6><p><strong>在 Python 中，一个 .py文件就称之为一个模块（Module）。</strong></p><p>模块的好处：</p><ul><li>提高了代码的可维护性</li><li>可以避免函数名和变量名冲突</li></ul><p>使用模块的方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> module1[, module2[,... moduleN]<br><br><span class="hljs-comment"># from 后的参数可以为包路径，也可以为模块名路径，并且可以精确指定 import 模块中各成员。</span><br><span class="hljs-keyword">from</span> modname <span class="hljs-keyword">import</span> name1[, name2[, ... nameN]]<br><br><span class="hljs-keyword">from</span> modname <span class="hljs-keyword">import</span> *<br></code></pre></td></tr></table></figure><p>主模块和非主模块</p><p>在 Python中，有主模块和非主模块之分，如果一个模块被直接使用，而没有被别人调用，我们称这个模块为主模块，如果一个模块被别人调用，我们称这个模块为非主模块。</p><p><code>__name__</code>属性值是一个变量，且这个变量是系统给出的。利用这个变量可以判断一个模块是否是主模块。这个属性不能决定他们是否是主模块，决定是否是主模块的条件只是这个模块有没有被人调用。</p><h6 id="包">包</h6><p>为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。</p><p>简单说包就是一个文件夹，这个文件夹包含一个 <code>__init__.py</code>文件，它可以是一个空文件。引入了包以后，只要顶层的包名不冲突，那么所有的模块都不会冲突。</p><p><code>__init__.py</code> 可以是空文件，也可以有Python代码，因为<code>__init__.py</code>本身就是一个模块，而它对应的模块名就是它的包名。</p><p>更多信息请参考<ahref="https://pythonhowto.readthedocs.io/zh-cn/latest/module.html">这里</a></p><h6 id="作用域">作用域</h6><p>在 Python 中，是通过 <code>_</code>前缀来实现的。正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，ni12，PI等；类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的<code>__name__</code> 就是特殊变量，还有 <code>__author__</code>也是特殊变量，用来标明作者。</p><p>注意，我们自己的变量一般不要用这种变量名；类似 <code>_xxx</code> 和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code> ，<code>__abc</code> 等；</p><p><strong>这里是说不应该，而不是不能。因为 Python种并没有一种方法可以完全限制访问 private函数或变量，但是，从编程习惯上不应该引用 private函数或变量。</strong></p>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>开发语言</category>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo文章中插入图片</title>
    <link href="/2024/07/14/hexo%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    <url>/2024/07/14/hexo%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h3 id="markdown添加图片">Markdown添加图片</h3><hr /><p>Markdown 添加图片的格式是:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">图片说明</span>](<span class="hljs-link">图片路径 http网络路径或者本地路径</span>)<br>![<span class="hljs-string">这是一张图片</span>](<span class="hljs-link">https://upload.wikimedia.org/wikipedia/commons/thumb/1/10/20090529_Great_Wall_8185.jpg/2560px-20090529_Great_Wall_8185.jpg</span>)<br></code></pre></td></tr></table></figure><p>插入的图片效果如下图：</p><figure><imgsrc="https://upload.wikimedia.org/wikipedia/commons/thumb/1/10/20090529_Great_Wall_8185.jpg/2560px-20090529_Great_Wall_8185.jpg"alt="这是一张图片" /><figcaption aria-hidden="true">这是一张图片</figcaption></figure><h3 id="hexo文章中的图片">Hexo文章中的图片</h3><hr /><p>在使用Hexo写文章时，有的图片在本地，在本地的markdown文件中可以查看，但是发布到网络后，就因为路径问题无法显示图片。</p><p>解决办法：</p><h5 id="修改配置文件">修改配置文件</h5><p>打开_config.yml配置文件，找到post_asset_folder配置项</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 修改前</span><br><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 修改后</span><br><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>修改post_asset_folder为true后，在使用新建文档时，会在文档同一目录下生成一个同名的文件夹，可以在该文件夹中存放图片，如下图所示。</p><p><img src="image_demo.png" /></p><p>如果是使用Typora编辑文档，为了可以在文档中显示图片，需要设置图片的目录。</p><h5 id="设置typora的图片根目录">设置Typora的图片根目录</h5><blockquote><p>格式（O） -&gt; 图像 -&gt; 设置图片根目录 -&gt;选择文章同名文件夹（即放置图片的文件夹）</p></blockquote><h3 id="总结">总结</h3><hr /><p>经过以上设置后，就可以实现既可以在本地文档中显示图片，发布到网络后也可以现实图片。</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>搭建pytorch环境说明</title>
    <link href="/2024/07/14/%E6%90%AD%E5%BB%BApytorch%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E/"/>
    <url>/2024/07/14/%E6%90%AD%E5%BB%BApytorch%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h3 id="pytorch版本选择">Pytorch版本选择</h3><hr /><p>Pytorch是当前应用最广泛的深度学习框架，在<ahref="https://pytorch.org/">Pytorch官方网站</a>可以找到对应的安装方式。</p><figure><img src="pytorch.png" alt="pytorch" /><figcaption aria-hidden="true">pytorch</figcaption></figure><h3 id="python及虚拟环境安装与设置">Python及虚拟环境安装与设置</h3><hr /><p>使用Pytorch离不开Python，在Pytorch的安装要求中有对python版本的要求，因此可以根据需要安装对应的python版本。</p><p>为了方便python环境中不同包版本的管理，可以用通过虚拟环境进行不同python版本的切换。</p><p>一般来说，有三种方法可以建立python的虚拟环境：virtualenv、Virtualenvwrapper、pipenv。这三种不同的安装使用方式可以参考<ahref="https://blog.csdn.net/sirobot/article/details/107067577">这里</a>.</p><p>这里使用Virtualenvwrapper。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">on Windows</span><br>pip install virtualenvwrapper-win<br><span class="hljs-meta prompt_"># </span><span class="language-bash">on macOS / Linux</span><br>pip install --user virtualenvwrapper #pip install virtualenvwrapper<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">then</span> make Bash load virtualenvwrapper automatically</span><br>echo &quot;source virtualenvwrapper.sh&quot; &gt;&gt; ~/.bashrc  # echo &quot;source 具体的virtualenvwrapper.sh路径&quot; &gt;&gt; ~/.bashrc<br>source ~/.bashrc<br></code></pre></td></tr></table></figure><p>—user 表示 Install to the Python user install directory for yourplatform. Typically ~/.local/, or %APPDATA%on Windows. (See the Pythondocumentation for site.USER_BASE for full details.) (pip install --userxxx 是将module库默认安装到（windows平台）%APPDATA%，（非windows平台）~/.local/ 。)</p><p>如果不用—user 参数, 会有默认的安装目录。</p><p>可以通过 find / -name virtualenvwrapper.sh 找到virtualenvwrapper.sh的目录。如/root/miniconda3/bin/virtualenvwrapper.sh</p><p>根据找到的路径 echo "source/root/miniconda3/bin/virtualenvwrapper.sh" &gt;&gt; ~/.bashrc。</p><p>如果使用pip 有报警提示:</p><blockquote><p>WARNING: Running pip as the 'root' user can result in brokenpermissions and conflicting behaviour with the system package manager.It is recommended to use a virtual environment instead</p></blockquote><p>可以通过添加 --root-user-action=ignore 来忽略。如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install --root-user-action=ignore virtualenvwrapper<br></code></pre></td></tr></table></figure><p>安装好虚拟环境管理工具后，就可以通过工具管理虚拟环境，在虚拟环境下使用不同版本的python或者模块进行工作。</p><h5 id="创建虚拟环境">创建虚拟环境</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">on macOS/Linux:</span><br>mkvirtualenv --python=python3.6 venv<br><span class="hljs-meta prompt_"># </span><span class="language-bash">on Windows</span><br>mkvirtualenv --python=python3 venv<br></code></pre></td></tr></table></figure><h5 id="激活环境">激活环境</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">workon #列出虚拟环境列表<br>workon [venv] #切换环境<br></code></pre></td></tr></table></figure><h5 id="退出环境">退出环境</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">deactivate<br></code></pre></td></tr></table></figure><p>删除环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rmvirtualenv venv<br></code></pre></td></tr></table></figure><h3 id="jupyter安装内核与使用">Jupyter安装内核与使用</h3><hr /><p>Jupyter Notebook是一个交互式笔记本，可以切换不同的内核。</p><p>为了使用虚拟环境下的内核，可以进行如下操作，更详细的请<ahref="https://blog.singee.me/2018/06/28/python/jupyter-kernel/">参考这里</a></p><h5 id="进入虚拟环境">进入虚拟环境</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">workon venv<br></code></pre></td></tr></table></figure><h5 id="查看虚拟是否安装ipykernel">查看虚拟是否安装ipykernel</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m ipykernel --version<br></code></pre></td></tr></table></figure><p>如果有版本输出说明已经安装了 ipykernel如果没有输出，需要安装ipykernel。</p><h5 id="安装ipykernel">安装ipykernel</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install ipykernel<br></code></pre></td></tr></table></figure><h5 id="添加内核">添加内核</h5><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> -<span class="hljs-keyword">m</span> ipykernel install --name <span class="hljs-keyword">python3</span>.<span class="hljs-number">12.3</span> --<span class="hljs-keyword">display</span>-name <span class="hljs-string">&quot;python3.12.3&quot;</span><br></code></pre></td></tr></table></figure><p>添加内核后，就可以使用列出内核命令或者打开jupyternotebook查看内核是否已经添加。</p><h5 id="删除内核">删除内核</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">jupyter</span> kernelspec remove python3.<span class="hljs-number">12</span>.<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h5 id="列出内核">列出内核</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jupyter kernelspec list<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>深度学习</category>
      
      <category>pytorch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo搭建blog教程</title>
    <link href="/2024/07/11/hexo%E6%90%AD%E5%BB%BAblog%E6%95%99%E7%A8%8B/"/>
    <url>/2024/07/11/hexo%E6%90%AD%E5%BB%BAblog%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="hexo">Hexo</h3><hr /><p>Hexo 是一个快速、简洁且高效的博客框架。 Hexo 使用 <ahref="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="hexo文档">Hexo文档</h3><hr /><p><a href="https://hexo.io/zh-cn/docs/">Hexo文档</a></p><p>Hexo文档基本解决大部分写作的问题。</p><h3 id="在github上使用hexo建立blog">在github上使用hexo建立blog</h3><hr /><p>使用Hexo在github上建立blog，请参考<ahref="https://blog.csdn.net/wufengfeng130/article/details/131251961">这里</a></p><blockquote><p>注意：</p><p>如果使用命令行在上传github提示 hexo Support for passwordauthentication was removed on August 13, 2021. Please use a personalaccess token instead.</p><p>请使用 SSHkey在github仓库中部署文件。具体的ssh key 请在github-&gt;settings-&gt;SSH and GPG keys中设置。</p><p>关于ssh key的生成方法，参考<ahref="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent?platform=mac">github文档</a></p></blockquote><h3 id="hexo设置多级目录">Hexo设置多级目录</h3><hr /><p>如果想把文章放在多级目录下，</p><p>请在文件头部添加：</p><blockquote><p>categories: [教程, hexo]</p></blockquote><p>[]内的多级目录使用逗号（英文逗号）分割，前面的是父目录，后面的是子目录。</p><h3 id="hexo写作">Hexo写作</h3><p>在命令行执行如下命令，在可以生成一个要完成的写作文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new post &quot;hexo搭建blog教程&quot;<br></code></pre></td></tr></table></figure><p>生成的文件路径是 本地blog目录下的 source/_posts下面,在该目录下会有一个对应的"hexo搭建blog教程.md"文件，使用文本编辑器进行写作即可。</p><h3 id="hexo发布到github">Hexo发布到github</h3><p>在命令行执行如下命令，即可将文章发布到网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo d -g<br></code></pre></td></tr></table></figure><p>hexo d -g = hero deploy generate.</p><p>具体的hexo命令 请参考<ahref="https://hexo.io/zh-cn/docs/commands">这里</a></p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>markdown输入拼音声调</title>
    <link href="/2024/06/27/markdown%E8%BE%93%E5%85%A5%E6%8B%BC%E9%9F%B3%E5%A3%B0%E8%B0%83/"/>
    <url>/2024/06/27/markdown%E8%BE%93%E5%85%A5%E6%8B%BC%E9%9F%B3%E5%A3%B0%E8%B0%83/</url>
    
    <content type="html"><![CDATA[<p>使用markdown写作，有时会遇到对中文注音的情况。通过查询资料，在此记录下来。</p><table><thead><tr><th>声调</th><th>格式</th><th>效果</th></tr></thead><tbody><tr><td>一声（阴平）</td><td>&amp;<strong>a</strong>macr;</td><td>ā</td></tr><tr><td>二声（阳平）</td><td>&amp;<strong>a</strong>acute;</td><td>á</td></tr><tr><td>三声（上声）上 (shǎng)声</td><td>&amp;<strong>e</strong>caron;ǎ不能使用这个方式，可以使用搜狗拼音输入</td><td>ě</td></tr><tr><td>四声（去声）</td><td>&amp;<strong>a</strong>grave;</td><td>à</td></tr><tr><td>u音</td><td>&amp;<strong>u</strong>uml;</td><td>ü</td></tr></tbody></table><p>用法： 替换<code>&amp;</code>后的第一个字母即可。 注：有的字母替换后显示会不正常，自己尝试下即可。</p><p><ahref="https://dev.w3.org/html5/html-author/charref">特殊字符网址</a></p><p><ahref="https://www.w3.org/TR/WD-math-970710/fnewtable17.html">特殊字符网址2</a></p>]]></content>
    
    
    <categories>
      
      <category>工具技巧</category>
      
      <category>奇技淫巧</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>咏荆轲</title>
    <link href="/2024/06/24/%E5%92%8F%E8%8D%86%E8%BD%B2/"/>
    <url>/2024/06/24/%E5%92%8F%E8%8D%86%E8%BD%B2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>咏荆轲</p><p>唐 柳宗元</p><p>燕秦不两立，太子已为虞。</p><p>千金奉短计，匕首荆卿趋。</p><p>穷年徇所欲，兵势且见屠。</p><p>微言激幽愤，怒目辞燕都。</p><p>朔风动易水，挥爵前长驱。</p><p>函首致宿怨，献田开版图。</p><p>炯然耀电光，掌握罔正夫。</p><p>造端何其锐，临事竟趑（zī）趄(jū)。</p><p>长虹吐白日，仓卒反受诛。</p><p>按剑赫凭怒，风雷助号呼。</p><p>慈父断子首，狂走无容躯。</p><p>夷城芟（shān）七族，台观皆焚污。</p><p>始期忧患弭，卒动灾祸枢。</p><p>秦皇本诈力，事与桓公殊。</p><p>奈何效曹子，实谓勇且愚。</p><p>世传故多谬，太史征无且（jū）。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>人文社科</category>
      
      <category>唐诗</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>田家即事</title>
    <link href="/2024/06/23/%E7%94%B0%E5%AE%B6%E5%8D%B3%E4%BA%8B/"/>
    <url>/2024/06/23/%E7%94%B0%E5%AE%B6%E5%8D%B3%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>田家即事</p><p>唐 储光羲</p><p>蒲叶日已长，杏花日已滋。</p><p>老农要（yào）看此，贵不违天时。</p><p>迎晨起饭牛，双驾耕东菑（zī）。</p><p>蚯蚓土中出，田乌随我飞。</p><p>群合乱啄噪，嗷嗷如道饥。</p><p>我心多恻隐，顾此两伤悲。</p><p>拨食与田乌，日暮空筐归。</p><p>亲戚更相诮（qìao），我心终不移。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>人文社科</category>
      
      <category>唐诗</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>测试</title>
    <link href="/2024/06/17/%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/06/17/%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>这是一个测试页面.</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/06/14/hello-world/"/>
    <url>/2024/06/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
