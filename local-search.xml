<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>matplotlib中的中文字体设置</title>
    <link href="/2024/08/15/matplotlib%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE/"/>
    <url>/2024/08/15/matplotlib%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>在机器学习或者深度学习中，可视化是一个非常重要的事情，一般使用图表呈现结果，在呈现结果的时候，出现中文乱码是经常遇见的事情。</p><p>本文是在python虚拟环境下的中文乱码处理。</p><h4id="查看字体路径配置当前支持的字体字体缓存">查看字体路径、配置、当前支持的字体、字体缓存</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> matplotlib<br>a=<span class="hljs-built_in">sorted</span>([f.name <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> matplotlib.font_manager.fontManager.ttflist]) <span class="hljs-comment"># 当前支持的字体</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a:<br>    <span class="hljs-built_in">print</span>(i) <span class="hljs-comment">#输出字体</span><br><span class="hljs-built_in">print</span>(matplotlib.get_data_path()) <span class="hljs-comment">#字体路径</span><br><span class="hljs-built_in">print</span>(matplotlib.matplotlib_fname()) <span class="hljs-comment">#matplotlib 字体配置文件</span><br><span class="hljs-built_in">print</span>(matplotlib.get_cachedir()) <span class="hljs-comment"># 字体缓存路径</span><br></code></pre></td></tr></table></figure><h4 id="下载宋体字体">下载宋体字体</h4><p>宋体字体<ahref="https://github.com/SparksFly8/Stylify-Me/blob/master/.fonts/SimSun.ttf">下载</a></p><h4 id="字体配置">字体配置</h4><p>将下载的字体文件复制到 上文中输出的<code>字体路径</code>下面的fonts/ttf目录下。如:/root/.virtualenvs/venv3.9/lib/python3.9/site-packages/matplotlib/mpl-data/<strong>fonts/ttf</strong>下面</p><h4 id="修改matplotlibrc文件">修改matplotlibrc文件</h4><p>打开上文输出的matplotlib的字体配置文件matplotlibrc，修改内容如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">font.family         :</span> <span class="hljs-string">sans-serif</span>   <br><span class="hljs-comment"># 去掉前面的#     </span><br><span class="hljs-attr">font.sans-serif     :</span> <span class="hljs-string">SimSun,</span> <span class="hljs-string">DejaVu</span> <span class="hljs-string">Sans,</span> <span class="hljs-string">Bitstream</span> <span class="hljs-string">Vera</span> <span class="hljs-string">Sans,</span> <span class="hljs-string">Computer</span> <span class="hljs-string">Modern</span> <span class="hljs-string">Sans</span> <span class="hljs-string">Serif,</span> <span class="hljs-string">Lucida</span> <span class="hljs-string">Grande,</span> <span class="hljs-string">Verdana,</span> <span class="hljs-string">Geneva,</span> <span class="hljs-string">Lucid,</span> <span class="hljs-string">Arial,</span> <span class="hljs-string">Helvetica,</span> <span class="hljs-string">Avant</span> <span class="hljs-string">Garde,</span> <span class="hljs-string">sans-serif</span> <br><span class="hljs-comment"># 去掉前面的#，并在冒号后面添加SimSun, 显示的字体可能不尽相同，只需要加上需要的字体即可，如SimSun.</span><br><span class="hljs-attr">axes.unicode_minus  :</span> <span class="hljs-literal">False</span><br><span class="hljs-comment"># 去掉前面的#，并将True改为False</span><br></code></pre></td></tr></table></figure><h4 id="清除字体缓存">清除字体缓存</h4><p>打开上文输出的字体缓存路径， 执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd 字体缓存目录<br>rm -fr *<br><br>如 <br>cd /root/.cache/matplotlib<br>rm -fr *<br></code></pre></td></tr></table></figure><h4 id="最后">最后</h4><p>如果是虚拟环境，使用jupyter的话，重启内核就可以。如果是pycharm，重启软件，或者重启系统即可。</p><h4 id="设置字体">设置字体</h4><p>设置字体，总体来说有两种方式，一种是全局性的，一种是局部性的。全局性设置会影响到已经设置的字体，局部性设置字体比较灵活，可以根据需要设置。</p><p>全局设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.rcParams[<span class="hljs-string">&#x27;font.family&#x27;</span>] = [<span class="hljs-string">&#x27;sans-serif&#x27;</span>]  <br>plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;SimSun&#x27;</span>] <span class="hljs-comment"># 步骤一（替换宋体）</span><br>plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span>   <span class="hljs-comment"># 解决坐标轴负数的负号显示问题</span><br><br></code></pre></td></tr></table></figure><p>局部设置:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># ...</span><br><br>plt.xlabel(<span class="hljs-string">&quot;x轴&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;y轴&quot;</span>, fontproperties=<span class="hljs-string">&quot;SimSun&quot;</span>) <span class="hljs-comment"># （宋体）</span><br>plt.title(<span class="hljs-string">&quot;标题&quot;</span>, fontproperties=<span class="hljs-string">&quot;SimSun&quot;</span>) <span class="hljs-comment"># （宋体）</span><br>plt.show()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>深度学习</category>
      
      <category>pytorch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pytorch使用GPU训练模型</title>
    <link href="/2024/08/14/pytorch%E4%BD%BF%E7%94%A8GPU%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/08/14/pytorch%E4%BD%BF%E7%94%A8GPU%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>在深度学习中，使用GPU进行训练模型是必不可少。使用GPU训练模型的主要原因是GPU的并行处理能力和高吞吐量，主流的深度学习框架如Tensorflow、pytorch等都对GPU进行了优化。</p><h4 id="cuda">CUDA</h4><hr /><p>CUDA（Compute Unified DeviceArchitecture）是由NVIDIA开发的用于并行计算的平台和编程模型。CUDA旨在利用NVIDIAGPU（图形处理单元）的强大计算能力来加速各种科学计算、数值模拟和深度学习任务。</p><p>CUDA的软件堆栈由驱动层、运行时层和函数库层构成。CUDA软件堆栈中涉及的API包括驱动层API和运行时层API。</p><p>CUDA是显卡厂商NVIDIA在2007年推出的并行计算平台和编程模型。CUDA利用图形处理器GPU（GraphicsProcessing Unit），可显著提高计算性能。</p><p>下图展示CUDA的架构体系。CUDA软件堆栈中的驱动层API和运行时层API的区别如下。</p><ul><li>驱动层API（Driver API）：功能较完整，但是使用复杂。</li><li>运行时API（CUDA RuntimeAPI）：封装了部分驱动的API，将某些驱动初始化操作隐藏，使用方便。</li></ul><p>CUDA的Driver API由<ahref="https://www.nvidia.com/Download/index.aspx">NVIDIADriver</a>包提供，而CUDA Library和CUDA Runtime由<ahref="https://developer.nvidia.com/cuda-toolkit">CUDAToolkit</a>包提供。</p><p><img src="cuda-gpu.png" style="zoom:50%;" /></p><p><strong>CUDA的作用和特点:</strong></p><ol type="1"><li><strong>「GPU并行计算」</strong>：CUDA使GPU能够执行并行计算任务，从而大幅提高了计算性能。GPU由许多小型处理单元组成，每个处理单元都能够执行多个线程，这意味着GPU可以同时处理大量的计算任务。</li><li><strong>「CUDA编程模型」</strong>：CUDA提供了一种编程模型，允许开发人员编写C/C++代码，利用GPU的并行性来执行任务。开发人员可以编写称为"核函数"（kernel）的代码，这些核函数在GPU上并行执行。CUDA编程模型还提供了一组API（应用程序接口）来管理GPU内存、控制GPU设备和调度核函数的执行。</li><li>「并行计算应用」：CUDA广泛用于各种领域的科学计算和高性能计算应用，包括：<ul><li><strong>「数值模拟」</strong>：CUDA可用于模拟物理现象、天气模型、流体力学等领域的数值模拟。</li><li><strong>「深度学习」</strong>：深度学习框架如TensorFlow和PyTorch都支持CUDA，可用于训练和推理深度神经网络，加速图像识别、自然语言处理等任务。</li><li><strong>「分子动力学」</strong>：用于模拟分子之间相互作用，有助于药物设计和材料科学研究。</li><li><strong>「地球科学」</strong>：用于地震模拟、气象学、地球物理学等领域的大规模数值模拟。</li></ul></li><li><strong>「NVIDIA GPU支持」</strong>： CUDA仅适用于NVIDIAGPU。不同版本的CUDA通常与特定型号的NVIDIAGPU兼容，因此需要确保你的GPU支持所选版本的CUDA。</li><li><strong>「CUDA工具和库」</strong>：NVIDIA提供了一套用于CUDA开发的工具和库，包括CUDAToolkit、cuDNN（CUDA深度神经网络库）、cuBLAS（CUDA基础线性代数库）等。这些工具和库简化了CUDA应用程序的开发和优化过程。</li></ol><h4 id="cudnn">cuDNN</h4><hr /><p>cuDNN（CUDA Deep Neural NetworkLibrary）是由NVIDIA开发的用于深度学习的加速库。cuDNN旨在优化神经网络的前向传播和反向传播过程，以利用NVIDIAGPU的并行计算能力，从而加速深度学习模型的训练和推理。</p><p><strong>cuDNN的作用特点：</strong></p><ol type="1"><li><strong>「深度学习加速」</strong>：cuDNN是专门为深度学习任务而设计的，旨在加速神经网络的训练和推理。它提供了一系列高度优化的算法和函数，用于执行神经网络层的前向传播、反向传播和权重更新。</li><li><strong>「GPU加速」</strong>： cuDNN充分利用NVIDIAGPU的并行计算能力，以高效地执行深度学习操作。这使得训练深度神经网络更快速，尤其是对于大型模型和大规模数据集。</li><li><strong>「深度学习框架支持」</strong>：cuDNN被广泛用于多个深度学习框架，包括TensorFlow、PyTorch、Caffe、MXNet等。这些框架通过cuDNN来加速模型的训练和推理过程，使得深度学习研究和开发更加高效。</li><li><strong>「提高性能」</strong>：cuDNN通过使用高度优化的卷积和池化算法、自动混合精度计算、内存管理和多GPU支持等技术，显著提高了深度学习任务的性能。这些优化可以加速卷积神经网络（CNN）、循环神经网络（RNN）、生成对抗网络（GAN）等各种类型的神经网络。</li><li><strong>「版本兼容性」</strong>： cuDNN的不同版本与NVIDIAGPU架构和深度学习框架的版本兼容。因此，为了获得最佳性能，你需要选择适用于你的GPU型号和深度学习框架版本的cuDNN版本。</li><li><strong>「免费使用」</strong>：cuDNN是免费的，可以在NVIDIA的官方网站上下载和使用。</li></ol><h4 id="pytorch">Pytorch</h4><hr /><p>PyTorch是一个开源的深度学习框架，由Facebook的人工智能研究团队开发和维护。它是一个非常流行的深度学习框架，用于构建和训练神经网络模型。</p><p><strong>pytorch的作用和特点:</strong></p><ol type="1"><li><strong>「动态计算图」</strong>： PyTorch 采用动态计算图（DynamicComputationalGraph）的方式来定义和执行神经网络。这意味着你可以像编写常规Python代码一样编写神经网络，同时保留了计算图的优势，使模型的构建和调试更加直观和灵活。</li><li><strong>「灵活性」</strong>： PyTorch提供了丰富的张量操作，以及各种优化工具和模块，可以轻松构建各种类型的深度学习模型，包括卷积神经网络（CNN）、循环神经网络（RNN）、生成对抗网络（GAN）等。它还支持自定义神经网络层和损失函数，允许你创建高度定制的模型。</li><li><strong>「GPU加速」</strong>：PyTorch天然支持GPU加速，你可以在GPU上训练和执行神经网络，大幅提高了计算性能。PyTorch的GPU张量操作与CPU张量操作非常相似，使得将计算从CPU迁移到GPU变得相对容易。</li><li><strong>「动态调试」</strong>：由于采用动态计算图，PyTorch允许你在模型构建和训练过程中轻松进行动态调试，检查梯度、查看中间变量等。这对于理解和诊断模型行为非常有帮助。</li><li><strong>「丰富的生态系统」</strong>：PyTorch拥有庞大的用户社区，有许多开源项目、库和工具，可以扩展其功能。这些包括模型部署工具、迁移学习库、自然语言处理工具和计算机视觉工具，以及与其他深度学习框架的集成。</li><li><strong>「深度学习研究和教育」</strong>：PyTorch在深度学习研究和教育中非常流行，因为它易于学习、易于使用，并提供了丰富的教程和文档资源。它还被许多大学和研究机构用于深度学习课程和研究项目。</li><li><strong>「跨平台支持」</strong>：PyTorch支持多种操作系统，包括Linux、macOS和Windows，以及多种编程语言接口，如Python、C++等。这使得它适用于各种应用场景。</li></ol><h4 id="cudacudnnpytorch的关系">CUDA、cuDNN、Pytorch的关系</h4><hr /><p>CUDA、cuDNN 和 PyTorch是三个不同但相关的组件，它们之间存在一些依赖关系，</p><ol type="1"><li>「CUDA（Compute Unified Device Architecture）」:<ul><li><strong>「CUDA是GPU并行计算平台」</strong>：CUDA 是由 NVIDIA开发的用于并行计算的平台和编程模型。它允许开发人员利用 NVIDIA GPU的强大计算能力来加速各种科学计算、数值模拟和深度学习任务。</li><li><strong>「PyTorch依赖CUDA」</strong>：PyTorch 使用 CUDA来加速神经网络的训练和推理。在 PyTorch 中，张量（Tensor）可以在 CPU 或GPU 上进行计算。如果你想在 GPU 上训练神经网络，你需要确保 CUDA已经正确安装并配置。</li><li><strong>「版本兼容性」</strong>：不同版本的 PyTorch可能需要特定版本的 CUDA。你需要根据所使用的 PyTorch 版本来选择合适的CUDA 版本，以确保兼容性。</li></ul></li><li>「cuDNN（CUDA Deep Neural Network Library）」:<ul><li><strong>「cuDNN用于深度学习加速」</strong>：cuDNN 是 NVIDIA开发的专门用于深度学习的加速库。它提供了高度优化的卷积和其他深度神经网络层的操作，以提高深度学习模型的性能。</li><li><strong>「PyTorch依赖cuDNN」</strong>：PyTorch 使用 cuDNN来执行深度学习操作，尤其是在卷积神经网络（CNN）中。cuDNN提供了高性能的卷积操作，使 PyTorch 能够在 GPU上高效地进行前向传播和反向传播。</li><li><strong>「版本兼容性」</strong>：不同版本的 PyTorch 需要特定版本的cuDNN。你需要确保所使用的 cuDNN 版本与 PyTorch 版本兼容。</li></ul></li><li>「PyTorch」:<ul><li><strong>「PyTorch是深度学习框架」</strong>：PyTorch是一个开源的深度学习框架，用于构建、训练和部署神经网络模型。它提供了张量操作、自动求导、优化器、损失函数等工具，使深度学习任务更加便捷。</li><li><strong>「PyTorch依赖CUDA和cuDNN」</strong>：PyTorch 可以在 CPU 或GPU 上运行，但为了获得最佳性能，特别是在大规模深度学习任务中，你通常会将PyTorch 配置为在 GPU 上运行。这就需要确保 CUDA 和 cuDNN已正确安装和配置。</li></ul></li></ol><h4 id="查看cuda">查看CUDA</h4><hr /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-built_in">print</span>(torch.cuda.is_available())<br><span class="hljs-built_in">print</span>(torch.cuda.get_arch_list())<br>torch.zeros(<span class="hljs-number">1</span>).cuda()<br></code></pre></td></tr></table></figure><p>输出:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">True<br><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;sm_37&#x27;</span>, <span class="hljs-string">&#x27;sm_50&#x27;</span>, <span class="hljs-string">&#x27;sm_60&#x27;</span>, <span class="hljs-string">&#x27;sm_70&#x27;</span>, <span class="hljs-string">&#x27;sm_75&#x27;</span>, <span class="hljs-string">&#x27;sm_80&#x27;</span>, <span class="hljs-string">&#x27;sm_86&#x27;</span>]</span><br><span class="hljs-function"><span class="hljs-title">tensor</span><span class="hljs-params">([<span class="hljs-number">0</span>.], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)</span></span><br></code></pre></td></tr></table></figure><p>torch.cuda.is_available() 为True 说明CUDA是可用的，如果为False就要检查pytorch的版本与CUDA的版本是否兼容一致。</p><p>torch.cuda.get_arch_list() 返回的是CUDA架构列表。也就是说CUDA能支持的GPU的架构，不同版本的CUDA支持的GPU是不一样的，所以一定要根据GPU的型号/架构来选择要安装的CUDA版本.</p><p>如果cuda版本和GPU兼容，则<code>torch.zeros(1).cuda()</code>在GPU上运算就会成功，否则就会报错。</p><p>如果安装了GPU显卡驱动：在命令行执行以下命令</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nvidia-smi</span><br></code></pre></td></tr></table></figure><p><img src="nvidia-smi.png" alt="nvidia-smi" style="zoom:50%;" /></p><p>从上图可以知道安装的驱动版本为550.78，驱动API版本为12.4，表示该驱动最高支持CUDA运行时API版本为12.4。显卡是GeForceRTX 3090,24G显存。</p><p>根据上述信息，从nvidia的网站上就可以找到对应的<ahref="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html?spm=a2c4g.207292.0.0.62f2778erY9RgV">CUDA版本</a>。</p><h4 id="pytorch的安装">PyTorch的安装</h4><hr /><p>在pytorch的<ahref="https://pytorch.org/">官方网站</a>上可以找到pytorch的安装说明。如果需要安装其他版本pytorch和对应的cuda版本，可以在<ahref="https://pytorch.org/get-started/previous-versions/">这里</a>找到。从这个页面找到对应的pytorch版本，并选择相应的系统，执行对应的命令即可。</p><p>如需要安装cuda=11.6 pytorch=1.12.0 torchvision=0.13.0torchaudio=0.12.0就可以执行如下命令进行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install torch==1.12.0+cu116 torchvision==0.13.0+cu116 torchaudio==0.12.0 --extra-index-url https://download.pytorch.org/whl/cu116<br></code></pre></td></tr></table></figure><p>关于GPU架构和CUDA算力的关系,可以查看<ahref="https://cuiyuhao.com/posts/8a630bae/">这篇文章</a></p><h4 id="pytorch在gpu上训练的方法">pytorch在GPU上训练的方法</h4><hr /><p>方法一 .cuda()</p><p>我们可以通过对网络模型，数据，损失函数这三种变量调用 .cuda()来在GPU上进行训练.</p><p><img src="cuda.png" style="zoom:50%;" /></p><p>比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将网络模型在gpu上训练</span><br>model = Model()<br><span class="hljs-keyword">if</span> torch.cuda.is_available(): <span class="hljs-comment"># 判断 cuda 是否可用</span><br>model = model.cuda()<br><br><span class="hljs-comment"># 损失函数在gpu上训练</span><br>loss_fn = nn.CrossEntropyLoss()<br><span class="hljs-keyword">if</span> torch.cuda.is_available(): <span class="hljs-comment"># 判断 cuda 是否可用</span><br>loss_fn = loss_fn.cuda()<br><br><span class="hljs-comment"># 数据在gpu上训练</span><br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataloader:                        <br>imgs, targets = data<br>    <span class="hljs-keyword">if</span> torch.cuda.is_available(): <span class="hljs-comment"># 判断 cuda 是否可用</span><br>        imgs = imgs.cuda()<br>        targets = targets.cuda()<br><br></code></pre></td></tr></table></figure><p>方法二 .to(device)</p><p>指定训练设备:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">device = torch.device(<span class="hljs-string">&quot;cpu&quot;</span>)<span class="hljs-comment"># 使用cpu训练</span><br>device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span>)<span class="hljs-comment"># 使用gpu训练 </span><br>device = torch.device(<span class="hljs-string">&quot;cuda:0&quot;</span>)<span class="hljs-comment"># 当电脑中有多张显卡时，使用第一张显卡</span><br>device = torch.device(<span class="hljs-string">&quot;cuda:1&quot;</span>)<span class="hljs-comment"># 当电脑中有多张显卡时，使用第二张显卡</span><br><br>device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br></code></pre></td></tr></table></figure><p>使用GPU训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">model = model.to(device)<br><br>loss_fn = loss_fn.to(device)<br><br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> train_dataloader:<br>    imgs, targets = data<br>    imgs = imgs.to(device)<br>    targets = targets.to(device)<br><br></code></pre></td></tr></table></figure><h4 id="qa">Q&amp;A</h4><ol type="1"><li><p>CUDA error: no kernel image is available for execution on thedevice</p><p>当前GPU的算力与当前版本的Pytorch依赖的CUDA算力不匹配。</p><p>解决：需要根据显卡的cuda版本，重新安装pytorch的版本.</p></li><li><p>Expected all tensors to be on the same device, but found at leasttwo devices, cuda:0 and cpu! (when checking argument for argument indexin method wrapper__index_select)</p><p>原因：参与运算的两个或多个变量，有的在CPU上，有的在GPU上</p><p>解决方案:先找到报错的行，看看计算时都用到哪些变量或者数据，然后在调试模式下使用.is_cuda这个属性去查看到底哪些是在GPU上，哪些是在CPU上，然后把它们统一都放在CPU，或者统一放在GPU上就可以。如果增加了变量，需要将新增加的变量也搬到GPU上去。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>深度学习</category>
      
      <category>pytorch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pytorch的model.train()与model.eval()</title>
    <link href="/2024/08/07/pytorch%E7%9A%84model-train-%E4%B8%8Emodel-eval/"/>
    <url>/2024/08/07/pytorch%E7%9A%84model-train-%E4%B8%8Emodel-eval/</url>
    
    <content type="html"><![CDATA[<p>在pytorch的深度学习代码中，经常遇到model.train() 和 model.eval()，这两句代码有什么区别，究竟有什么用呢？</p><p>先看<ahref="https://pytorch.org/docs/stable/generated/torch.nn.Module.html">文档</a>。</p><figure><img src="train.png" alt="train" /><figcaption aria-hidden="true">train</figcaption></figure><p>根据官方文档的说明，train()就是把module设置为训练(training)模式。</p><figure><img src="eval.png" alt="eval" /><figcaption aria-hidden="true">eval</figcaption></figure><p>根据官方文档的说明，eval()就是把module设置为评价(evaluation)模式。</p><p>这两个方法都会对模型有一定影响，比如对BN和dropout的影响。那具体在使用中是怎么影响的呢？</p><h4 id="train">train</h4><p>如果模型中有BN层（Batch Normalization）和 Dropout ，需要在 训练时添加 model.train()。</p><p>model.train() 是保证 BN 层能够用到 每一批数据 的均值和方差。对于Dropout，model.train() 是 随机取一部分 网络连接来训练更新参数。</p><p>训练过程中会在程序上方添加一句model.train()，作用是 <strong>启用batch normalization (BN)和 dropout</strong> 。</p><h4 id="eval">eval</h4><p>如果模型中有 BN 层（Batch Normalization）和 Dropout，在 测试时 添加model.eval()。</p><p>model.eval() 是保证 BN 层能够用 全部训练数据的均值和方差，即测试过程中要保证 BN 层的均值和方差不变。对于Dropout，model.eval() 是利用到了 所有网络连接，即不进行随机舍弃神经元。</p><p>model.eval()的作用是 <strong>不启用 Batch Normalization 和Dropout</strong>。</p><h4 id="为什么测试要用eval">为什么测试要用eval</h4><p>训练完 train 样本后，生成的模型 model 要用来测试样本了。在model(test)之前，需要加上model.eval()，否则的话，有输入数据，即使不训练，它也会改变权值。这是model 中含有 BN 层和 Dropout 所带来的的性质。</p><p>eval() 时，pytorch 会自动把 BN 和 DropOut固定住，不会取平均，而是用训练好的值。 不然的话，一旦 test 的 batch_size过小，很容易就会被 BN 层导致生成图片颜色失真极大。 eval()在非训练的时候是需要加的，没有这句代码，一些网络层的值会发生变动，不会固定，你神经网络每一次生成的结果也是不固定的，生成质量可能好也可能不好。</p><p>也就是说，测试过程中使用model.eval()，这时神经网络会 沿用 batchnormalization 的值，而并 不使用 dropout。</p><p>在PyTorch中进行validation/test时，会使用model.eval()切换到测试模式，在该模式下：</p><p>1.主要用于通知dropout层和BN层在training和validation/test模式间切换：</p><p>在train模式下，dropout网络层会按照设定的参数p，设置保留激活单元的概率（保留概率=p)。BN层会继续计算数据的mean和var等参数并更新。在eval模式下，dropout层会让所有的激活单元都通过，而BN层会停止计算和更新mean和var，直接使用在训练阶段已经学出的mean和var值。</p><p>2.eval模式不会影响各层的gradient计算行为，即gradient计算和存储与training模式一样，只是不进行反向传播（backprobagation)。</p><p>而<strong>withtorch.no_grad()</strong>则主要是用于停止autograd模块的工作，以起到加速和节省显存的作用。它的作用是将该with语句包裹起来的部分停止梯度的更新，从而节省了GPU算力和显存，但是并不会影响dropout和BN层的行为。</p><p>如果不在意显存大小和计算时间的话，仅仅使用model.eval()已足够得到正确的validation/test的结果；而withtorch.no_grad()则是更进一步加速和节省gpu空间（因为不用计算和存储梯度），从而可以更快计算，也可以跑更大的batch来测试。</p>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>深度学习</category>
      
      <category>pytorch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深度学习入门</title>
    <link href="/2024/07/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"/>
    <url>/2024/07/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="感知机">感知机</h3><hr /><p><strong>感知机</strong> (perception) 是美国学者FrankRosenblatt提出来的（1957年）。了解感知机可以更好的学习神经网络（深度学习）的重要思想。感知机是一种最简单形式的前馈神经网络，是一种二元线性分类器。</p><center><img src="2LP.png" alt="有两个输入的感知机" style="zoom:33%;" /><br/><br/> 图：有两个输入的感知机</center><p>图中的<span class="math inline">\(x_1,x_2\)</span> 是输入信号，<spanclass="math inline">\(y\)</span>是输出信号，<spanclass="math inline">\(w_1, w_2\)</span> 是权重(weight)，<spanclass="math inline">\(\bigcirc\)</span>是神经元(节点)，输入信号被送往神经元时，会被分别乘以固定的权重<spanclass="math inline">\((w_1x_1, w_2x_2)\)</span>。神经元计算传递过来的信号总和，当总和超过某个界限值（阈值），输出1，就称为“神经元被激活”。界限值（阈值）用<spanclass="math inline">\(\theta\)</span> 表示。</p><p>感知机的运行原理用数学表达式表示如下： <span class="math display">\[y=\begin{cases}0 &amp;&amp;(w_1x_1+w_2x_2 \leq \theta) \\1 &amp;&amp;(w_1x_1+w_2x_2 &gt; \theta)\end{cases}\]</span>感知机中输入信号的权重越大，说明信号的重要性就越高。如果把<spanclass="math inline">\(\theta\)</span> 换成 <spanclass="math inline">\(-b\)</span> ，感知机的表示就可以变成另外一种形式： <span class="math display">\[y=\begin{cases}0 &amp;&amp;(b+w_1x_1+w_2x_2 \leq 0) \\1 &amp;&amp;(b+w_1x_1+w_2x_2 &gt; 0)\end{cases}\]</span> 现在<span class="math inline">\(b\)</span> 被称为偏置，<spanclass="math inline">\(w_1,w_2\)</span>是权重，<spanclass="math inline">\(x_1,x_2\)</span>是输入。</p><h4 id="单层感知机的局限性">单层感知机的局限性</h4><p>单层感知机的局限性在于只能表示由一条直线分割的空间（线性空间）。如果要表示非线性空间，可以通过组合（叠加）单层感知机，实现多层感知机，通过多层感知机表示非线性空间。</p><h5 id="多层感知机">多层感知机</h5><p>多层感知机(multi-layer perception, MLP)是叠加了多层感知机(单层感知机)的感知机。</p><center><img src="MLP.png" alt="多层感知机" style="zoom:33%;" /> <br/><br/>图：多层感知机</center><p>第0层是输入，第2层是输出。上图中的感知机，如果是按照拥有权重的层，是2层感知机，如果是按照拥有神经元的层，是3层感知机。</p><h4 id="神经网络">神经网络</h4><hr /><p>既然感知机（多层感知机）可以进行复杂任务的处理，为什么还要有神经网络呢？因为设置合适的、可以符合预期的感知机的权重是一个麻烦的工作，而且主要是有人工进行设置。神经网络的一个重要性质就是可以自动地从数据中学习到合适的权重参数。</p><center><img src="network.png" alt="神经网络" style="zoom:33%;" /> <br/><br/>图：神经网络</center><p>如图所示，最左边的一列是输入层，最右边一列是输出层，中间一列的中间层也称为隐藏层。这个神经网络和多层感知机非常像。</p><p>在用数学表达式表示感知机时，我们用了偏置<spanclass="math inline">\(b\)</span>，但是在图中的神经元中并没有偏置项<spanclass="math inline">\(b\)</span>。在神经网络的图中，我们可以把偏置项表示出来，并用<spanclass="math inline">\(y=h(\boldsymbol b+\boldsymbol w\boldsymbolx)\)</span>的形式写出神经网络的表达式。</p><center><img src="bias.png" alt="神经网络的偏置项" style="zoom:33%;" /><br/><br/> 图：神经网络的偏置项</center><p><span class="math display">\[h(x)=\begin{cases}0 &amp;&amp;(x \leq 0) \\1 &amp;&amp;(x &gt; 0)\end{cases}\]</span></p><h5 id="激活函数">激活函数</h5><p>像<spanclass="math inline">\(h(x)\)</span>这样把输入信号转为输出信号的函数称为<strong>激活函数</strong>(activationfuncation)。比如 <span class="math inline">\(a=b+w_1x_1 +w_2x_2\)</span> , <span class="math inline">\(y=h(a)\)</span> , <spanclass="math inline">\(h()\)</span>函数将<spanclass="math inline">\(a\)</span>转化为<spanclass="math inline">\(y\)</span> 。</p><center><img src="af.png" alt="激活函数的计算过程" style="zoom:33%;" /><br/><br/> 图：激活函数工作过程</center><p>如图所示，红线框中标识的神经元<spanclass="math inline">\(\bigcirc\)</span>显示了激活函数的计算过程。在神经网络中常用的激活函数有Relu、sigmoid等。在感知机中，激活函数是阶跃函数。阶跃函数以0为界，输出从0切换为1（或者从1切换为0）。它的值呈阶梯式变化，所以称为阶跃函数。</p><h6 id="sigmoid函数">sigmoid函数</h6><p>sigmoid函数(sigmoid function) 的表达式如下： <spanclass="math display">\[h(x) = {1\over 1+e^{-x}}\]</span></p><p><span class="math inline">\(e^{-x}\)</span> 中的<spanclass="math inline">\(e\)</span>是自然常数，是无线不循环小数，其值等于2.71828….. 近似值为<spanclass="math inline">\(271801\over 99990\)</span>。</p><p>sigmoid函数图像如下所示:</p><center><img src="sigmoid-1.png" alt="sigmoid函数图像" style="zoom:33%;" /><br/><br/> 图：sigmoid函数图像</center><p>从图中可以看出，sigmoid函数是一条平滑的曲线，输出随着输入发生连续性的变化，在神经网络中流动的是连续的实数值信号。sigmoid函数的平滑性对神经网络的学习具有重要意义。sigmoid函数的取值规律是：输入小时，输出接近0（为0）；随着输入增大，输出向1靠近（变成1）”。也就是说，当输入信号为重要信息时，阶跃函数和sigmoid函数都会输出较大的值；当输入信号为不重要的信息时，两者都输出较小的值；不管输入信号有多小，或者有多大，输出信号的值在0到1之间。sigmoid函数是非线性函数。</p><p>为什么神经网络要使用非线性函数呢？因为线性函数使得加深神经网络的层数没有意义。举例来说，<spanclass="math inline">\(h=cx\)</span>是一个线性函数，假设把这个线性函数作为激活函数，<spanclass="math inline">\(y=h(h(h(x)))\)</span>的函数运算对应的是3层神经网络，<spanclass="math inline">\(y=c\times c\times c \times x\)</span>，<spanclass="math inline">\(y=c^3x\)</span> ， <spanclass="math inline">\(c^3\)</span>是一个常数，令<spanclass="math inline">\(a=c^3\)</span>, 得到 <spanclass="math inline">\(y=ax\)</span> ,激活函数的效果与原来没有区别，无法发挥多层网络带来的优势。因此，为了发挥叠加层所带来的优势，激活函数必须使用非线性函数。</p><h6 id="relu函数">ReLu函数</h6><p>ReLu(Rectified Linear Unit)函数在输入大于0时，直接输出该值；在输入小于等于0时，输出0。Relu函数的函数表达式如下：<span class="math display">\[h(x)=\begin{cases}x &amp;&amp;(x &gt; 0) \\0 &amp;&amp;(x \leq 0)\end{cases}\]</span> ReLU 函数是一个非常简单的函数。函数图像如下：</p><center><img src="ReLu.png" alt="ReLu函数图像" style="zoom:33%;" /> <br/><br/>图：ReLu函数图像</center><h5 id="softmax函数">softmax函数</h5><p>机器学习的问题大致可以分为分类问题和回归问题。分类问题是数据属于哪一个类别的问题。比如，区分图像中的人是男性还是女性的问题就是分类问题。而回归问题是根据某个输入预测一个（连续的）数值的问题。比如，根据一个人的图像预测这个人的体重的问题就是回归问题。</p><p>一般而言，回归问题用恒等函数，分类问题用softmax函数。</p><p>分类问题中使用的softmax函数的数学表达式如下所示： <spanclass="math display">\[y_k = {e^{a_k} \over \displaystyle\sum_{i=1}^n{e^{x_i}}}\]</span>公式表达的是假设输出层共有n个神经元，计算第k个神经元的输出<spanclass="math inline">\(y_k\)</span>。softmax函数的分子是输入信号<spanclass="math inline">\(a_k\)</span>的指数函数，分母是所有输入信号的指数函数的和。softmax函数的输出是0.0到1.0之间的实数。并且，softmax函数的输出值的总和是1。输出总和为1是softmax函数的一个重要性质。正因为有了这个性质，我们才可以把softmax函数的输出解释为“概率”。一般而言，神经网络只把输出值最大的神经元所对应的类别作为识别结果。</p><h5 id="恒等函数">恒等函数</h5><p>恒等函数会将输入按原样输出，对于输入的信息，不加以任何改动地直接输出。因此，在输出层使用恒等函数时，输入信号会原封不动地被输出。</p><h3 id="神经网络的学习">神经网络的学习</h3><p>神经网络的“学习”是指从训练数据中自动获取最优权重参数的过程。学习的目的就是以损失函数为基准，找出能使它的值达到最小的权重参数。</p><p>深度学习有时也称为端到端机器学习（end-to-end machinelearning）。这里所说的端到端是指从一端到另一端的意思，也就是从原始数据（输入）中获得目标结果（输出）的意思。</p><h4 id="训练数据与测试数据">训练数据与测试数据</h4><p>机器学习中，一般将数据分为<strong>训练数据</strong>和<strong>测试数据</strong>两部分来进行学习和实验等。首先，使用<strong>训练数据</strong>进行学习，寻找最优的参数；然后，使用<strong>测试数据</strong>评价训练得到的模型的实际能力。</p><p>将数据分为训练数据和测试数据是因为我们追求的是模型的泛化能力。<strong>泛化能力</strong>是指处理未被观察过的数据（不包含在训练数据中的数据）的能力。获得泛化能力是机器学习的最终目标。</p><p>仅仅用一个数据集去学习和评价参数,可以顺利地处理某个数据集，但无法处理其他数据集的情况，这种只对某个数据集过度拟合的状态称为<strong>过拟合</strong>（overfitting）。</p><h4 id="one-hot表示法">One-hot表示法</h4><p>将正确解标签表示为1，其他标签表示为0的表示方法称为one-hot表示。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">t</span> = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h4 id="损失函数">损失函数</h4><p><strong>损失函数</strong>（lossfunction）是表示"神经网络性能有多好"的指标，即当前的神经网络对监督数据在多大程度上不拟合，在多大程度上不一致。损失函数可以使用任意函数，但一般用<strong>均方误差</strong>和<strong>交叉熵误差</strong>等。</p><h5 id="均方误差">均方误差</h5><p><strong>均方误差</strong>（mean squared error）。均方误差如下式所示：<span class="math display">\[E={1\over 2}{\displaystyle \sum_k{(y_k-t_k)^2}}\]</span></p><p>这里，<spanclass="math inline">\(y_k\)</span>是表示神经网络的输出，<spanclass="math inline">\(t_k\)</span>表示监督数据，<spanclass="math inline">\(k\)</span>表示数据的维数。</p><h5 id="交叉熵误差">交叉熵误差</h5><p><strong>交叉熵误差</strong>（cross entropyerror）也经常被用作损失函数。交叉熵误差如下式所示。 <spanclass="math display">\[E=-\displaystyle \sum_k{t_k\log y_k}\]</span> 这里，log表示以e为底数的自然对数（log e）。<spanclass="math inline">\(y_k\)</span>是神经网络的输出，<spanclass="math inline">\(t_k\)</span>是正确解标签</p><center><img src="cee.png" alt="交叉熵损失函数图像" style="zoom:33%;" /><br/><br/> 图：交叉熵损失函数图像</center><p>从图中可以看出，，x等于1时，y为0；随着x向0靠近，y逐渐变小。因此，正确解标签对应的输出越大（也就是交叉熵误差公式中的<spanclass="math inline">\(y_k\)</span>越大，对应的是图中的x坐标），误差公式的值越接近0（误差越小,对应图中的y坐标）；当输出为1时，交叉熵误差为0。此外，如果正确解标签对应的输出较小（也就是交叉熵误差公式中的<spanclass="math inline">\(y_k\)</span>越小）误差公式的值值较大(误差越大)。</p><p>注意：因为交叉熵误差公式有负号(<spanclass="math inline">\(-\)</span>)。该图<spanclass="math inline">\(y_k\)</span>的输出是0-1之间的数，可以看似是概率输出，所以<spanclass="math inline">\(\log x \le0\)</span>，公式加负号可以变为正数。也就是变成输出的正确概率越小，误差越大，输出的正确概率越大，误差越小。</p><h5 id="mini-batch学习">mini-batch学习</h5><p>如果遇到大数据，数据量非常多，以全部数据为对象求损失函数的和，则计算过程需要花费较长的时间，这种情况下以全部数据为对象计算损失函数是不现实的。因此，从全部数据中选出一部分，作为全部数据的“近似”。这种从训练数据中选出一批数据（称为mini-batch,小批量），然后对每个mini-batch进行学习的方式称为<strong>mini-baatch学习</strong>。</p><p>损失函数 交叉熵误差公式如下所示： <span class="math display">\[E=-{1\over N}{\displaystyle \sum_n\sum_k{y_{nk}\log {t_{nk}}}}\]</span> 这里,假设数据有<span class="math inline">\(N\)</span>个，<spanclass="math inline">\(t_{nk}\)</span>表示第<spanclass="math inline">\(n\)</span>个数据的第<spanclass="math inline">\(k\)</span>个元素的值（<spanclass="math inline">\(y_{nk}\)</span>是神经网络的输出，<spanclass="math inline">\(t_{nk}\)</span>是监督数据）。这个公式只是把求单个数据的损失函数的公式扩大到了N份数据，不过最后还要除以N进行正规化。通过除以N，可以求单个数据的“平均损失函数”。通过这样的平均化，可以获得和训练数据的数量无关的统一指标。</p><h5 id="为什么要用损失函数">为什么要用损失函数</h5><p>在进行神经网络的学习时，不能将识别精度（或者预测准确率等）作为指标。因为如果以识别精度为指标，则参数的导数在绝大多数地方都会变为0。</p><p>举个具体的例子，假设某个神经网络正确识别出了100笔训练数据中的32笔，此时识别精度为32%。如果以识别精度为指标，即使稍微改变权重参数的值，识别精度也仍将保持在32%，不会出现变化。也就是说，仅仅微调参数，是无法改善识别精度的。即便识别精度有所改善，它的值也不会像32.0123... %这样连续变化，而是变为33 %、34%这样的不连续的、离散的值。而如果把损失函数作为指标，则当前损失函数的值可以表示为0.92543...这样的值。并且，如果稍微改变一下参数的值，对应的损失函数也会像0.93432... 这样发生连续性的变化。</p><p>识别精度对微小的参数变化基本上没有什么反应，即便有反应，它的值也是不连续地、突然地变化。作为激活函数的阶跃函数也有同样的情况。出于相同的原因，如果使用阶跃函数作为激活函数，神经网络的学习将无法进行。</p><center><img src="diff.png" alt=" 阶跃函数和sigmoid函数" style="zoom:33%;" /><br/><br/> 图： 阶跃函数和sigmoid函数</center><p>阶跃函数的斜率在绝大多数地方都为0，而sigmoid函数的斜率（切线）不会为0</p><h4 id="梯度">梯度</h4><p>像<span class="math inline">\(( \frac {\partial f}{\partial x_0},\frac { \partial f}{\partialx_1})\)</span>这样的由全部变量的偏导数汇总而成的向量称为<strong>梯度</strong>（gradient）。</p><h3 id="误差的反向传播">误差的反向传播</h3><p>要正确理解误差反向传播法，有两种方法：一种是基于数学式；另一种是基于计算图（computationalgraph）。基于数学式的方法严密且简洁，计算图，直观且易理解。</p><h4 id="计算图">计算图</h4><p>计算图将计算过程用图形表示出来。计算图通过节点和箭头表示计算过程。节点用<spanclass="math inline">\(\bigcirc\)</span>表示，<spanclass="math inline">\(\bigcirc\)</span>中是计算的内容。将计算的中间结果写在箭头的上方，表示各个节点的计算结果从左向右传递。</p><center><img src="jst.png" alt="计算图示例" style="zoom:33%;" /> <br/><br/> 图：计算图示例</center><h4 id="正向传播">正向传播</h4><p><strong>正向传播</strong>（forwardpropagation）是从计算图出发点到结束点的传播。</p><h4 id="反向传播">反向传播</h4><p><strong>反向传播</strong>（backwardpropagation）从计算图结束点到出发点的传播（从图上看的话，就是从右向左的转播）。反向传播将局部导数向正方向的反方向（从右到左）传递。传递这个局部导数的原理，是基于<strong>链式法则</strong>（chainrule）。</p><h4 id="链式法则">链式法则</h4><p>链式法则是复合函数的导数的性质，如果某个函数由复合函数表示，则该复合函数的导数可以用构成复合函数的各个函数的导数的乘积表示。</p><h4 id="局部计算">局部计算</h4><p>局部计算是指，无论全局发生了什么，都只根据与自己相关的信息输出接下来的结果。</p><h3 id="深度学习的技巧">深度学习的技巧</h3><p>神经网络的学习的目的是找到使损失函数的值尽可能小的参数。这是寻找最优参数的问题，解决这个问题的过程称为最优化（optimization）。</p><h4 id="参数更新">参数更新</h4><h5 id="随机梯度下降法">随机梯度下降法</h5><p>为了找到最优参数，我们将参数的梯度（导数）作为了线索。使用参数的梯度，沿梯度方向更新参数，并重复这个步骤多次，从而逐渐靠近最优参数，这个过程称为<strong>随机梯度下降法</strong>（stochasticgradient descent），简称<strong>SGD</strong>。SGD的数学表达如下所示：<span class="math display">\[\boldsymbol W\leftarrow \boldsymbol W-\eta \frac{\partial L}{\partial\boldsymbol W}\]</span> 这里把需要更新的权重参数记为<spanclass="math inline">\(\boldsymbol W\)</span>，把损失函数关于<spanclass="math inline">\(\boldsymbol W\)</span>的梯度记为<spanclass="math inline">\(\frac{\partial L}{\partial \boldsymbolW}\)</span>, <spanclass="math inline">\(\eta\)</span>表示学习率，实际上会取0.01或0.001这些事先决定好的值。式子中的←表示用右边的值更新左边的值。</p><h6 id="sgd的缺点">SGD的缺点：</h6><p>如果函数的形状非均向（anisotropic），比如呈延伸状，搜索的路径就会非常低效。SGD低效的根本原因是，梯度的方向并没有指向最小值的方向。</p><h5 id="monentum">Monentum</h5><p>Monentum 是动量的意思，数学式表示Momentum方法，如下所示: <spanclass="math display">\[\displaylines{\boldsymbol {\upsilon} \leftarrow \alpha \boldsymbol\upsilon - \eta \frac {\partial L}{\partial \boldsymbol W}\\\boldsymbol W = \boldsymbol W + \boldsymbol  \upsilon}\]</span> 这里新出现了一个变量<spanclass="math inline">\(\upsilon\)</span>，对应物理上的速度。Momentum方法给人的感觉就像是小球在地面上滚动。通过增加动量后，可以有效改善更新不稳定的情况。</p><center><img src="momentum.png" alt="Momentum的最优化的更新路径" style="zoom:33%;" /><br/><br/> 图： Momentum的最优化的更新路径</center><h5 id="学习率">学习率</h5><p>在神经网络的学习中，学习率（数学式中记为<spanclass="math inline">\(\eta\)</span>）的值很重要。学习率过小，会导致学习花费过多时间；反过来，学习率过大，则会导致学习发散而不能正确进行。</p><h5 id="学习率衰减">学习率衰减</h5><p><strong>学习率衰减</strong>（learning ratedecay），即随着学习的进行，使学习率逐渐减小。一开始“多”学，然后逐渐“少”学的方法，在神经网络的学习中经常被使用。逐渐减小学习率的想法，相当于将“全体”参数的学习率值一起降低。</p><h5 id="adagrad">AdaGrad</h5><p>AdaGrad会为参数的每个元素适当地调整学习率，与此同时进行学习。数学表示如下：<span class="math display">\[\displaylines{\boldsymbol h \leftarrow \boldsymbol h + \frac {\partial L}{\partial\boldsymbol W} \odot \frac {\partial L}{\partial \boldsymbol W}\\\boldsymbol W = \boldsymbol W - \eta \frac{1}{\sqrt {\boldsymbol h}}\frac {\partial L}{\partial \boldsymbol W}}\]</span> 这里新出现了变量<span class="math inline">\(\boldsymbolh\)</span>，它保存了以前的所有梯度值的平方和，然后，在更新参数时，通过乘以$$，就可以调整学习的尺度。这意味着，参数的元素中变动较大（被大幅更新）的元素的学习率将变小。也就是说，可以按参数的元素进行学习率衰减，使变动大的参数的学习率逐渐减小。</p><h5 id="adam">Adam</h5><p>Adam是2015年提出的，直观地讲，就是融合了Momentum和AdaGrad的方法。通过组合前面两个方法的优点，有望实现参数空间的高效搜索。此外，进行超参数的“偏置校正”也是Adam的特征。</p><p>Adam会设置 3个超参数。一个是学习率（论文中以<spanclass="math inline">\(\alpha\)</span>出现），另外两个是一次momentum系数<spanclass="math inline">\(\beta_1\)</span>和二次momentum系数<spanclass="math inline">\(\beta_2\)</span>。根据论文，标准的设定值是<spanclass="math inline">\(\beta_1\)</span>为 0.9，<spanclass="math inline">\(\beta_2\)</span> 为 0.999。</p><center><img src="adam.png" alt="Adam" style="zoom:33%;" /> <br/><br/> 图：Adam的最优化的更新路径</center><h4 id="权重的初始值">权重的初始值</h4><p>在神经网络的学习中，权重的初始值特别重要。实际上，设定什么样的权重初始值，经常关系到神经网络的学习能否成功。</p><h5 id="权重的初始值是否可以为0">权重的初始值是否可以为0</h5><p>从结论来说，将权重初始值设为0不是一个好主意。事实上，将权重初始值设为0的话，将无法正确进行学习。</p><p>是因为在误差反向传播法中，所有的权重值都会进行相同的更新。比如，在2层神经网络中，假设第1层和第2层的权重为0。这样一来，正向传播时，因为输入层的权重为0，所以第2层的神经元全部会被传递相同的值。第2层的神经元中全部输入相同的值，这意味着反向传播时第2层的权重全部都会进行相同的更新。因此，权重被更新为相同的值，并拥有了对称的值（重复的值）。这使得神经网络拥有许多不同的权重的意义丧失了。为了防止“权重均一化”（严格地讲，是为了瓦解权重的对称结构），必须随机生成初始值。</p><h5 id="梯度消失">梯度消失</h5><p>梯度消失（gradientvanishing），随着输出不断地靠近0（或者靠近1），它的导数的值逐渐接近0。因此，偏向0和1的数据分布会造成反向传播中梯度的值不断变小，最后消失。这个问题称为梯度消失。</p><h5 id="权重值的要求">权重值的要求</h5><p>神经网络各层的激活值的分布都要求有适当的广度。为什么呢？因为通过在各层间传递多样性的数据，神经网络可以进行高效的学习。反过来，如果传递的是有所偏向的数据，就会出现梯度消失或者“表现力受限”的问题，导致学习可能无法顺利进行。</p><h5 id="一些推荐的权重初始值">一些推荐的权重初始值</h5><h6 id="xavier初始值">Xavier初始值</h6><p><strong>Xavier初始值</strong>是XavierGlorot等人的论文中推荐的权重初始值，Xavier的论文中，为了使各层的激活值呈现出具有相同广度的分布，推导了合适的权重尺度。推导出的结论是，如果前一层的节点数为<spanclass="math inline">\(n\)</span>，则初始值使用标准差为<spanclass="math inline">\(\frac{1}{\sqrt n}\)</span>的分布。</p><p><strong>Xavier初始值</strong>是以激活函数是线性函数为前提而推导出来的。因为sigmoid函数和tanh函数左右对称，且中央附近可以视作线性函数，所以适合使用Xavier初始值。</p><h6 id="relu初始值">ReLu初始值</h6><p>当激活函数使用ReLU时，一般推荐使用ReLU专用的初始值，也就是KaimingHe等人推荐的初始值，也称为“He初始值”。当前一层的节点数为n时，He初始值使用标准差为<spanclass="math inline">\(\sqrt \frac{2}{n}\)</span>的高斯分布。</p><p><strong>总结一下</strong>，当激活函数使用ReLU时，权重初始值使用He初始值，当激活函数为sigmoid或tanh等S型曲线函数时，初始值使用Xavier初始值。这是目前的最佳实践。</p><h4 id="batch-normalization">Batch Normalization</h4><p><strong>BatchNorm</strong>，顾名思义，以进行学习时的mini-batch为单位，按mini-batch进行正规化。具体而言，就是进行使数据分布的均值为0、方差为1的正规化。用数学式表示的话，如下所示。<span class="math display">\[\displaylines{\mu_B \leftarrow \frac{1}{m} \displaystyle \sum_{i=1}^m{x_i}\\\sigma^2_B \leftarrow \frac{1}{m} \displaystyle\sum_{i=1}^m(x_i-\mu_B)^2\\\hat x_i \leftarrow \frac{x_i-\mu_B}{\sqrt {\sigma^2_B + \varepsilon}}}\]</span></p><p>Batch Norm的优点:</p><ol type="1"><li>可以使学习快速进行（可以增大学习率）。</li><li>不那么依赖初始值（对于初始值不用那么神经质）。</li><li>抑制过拟合（降低Dropout等的必要性）。</li></ol><h4 id="正则化">正则化</h4><p>机器学习的问题中，过拟合是一个很常见的问题。</p><h5 id="过拟合">过拟合</h5><p><strong>过拟合</strong>指的是只能拟合训练数据，但不能很好地拟合不包含在训练数据中的其他数据的状态。</p><p>发生过拟合的原因，主要有以下两个:</p><ol type="1"><li>模型拥有大量参数、表现力强。</li><li>训练数据少。</li></ol><h5 id="权重衰减">权重衰减</h5><p><strong>权值衰减</strong>（weightdecay）就是一种以减小权重参数的值为目的进行学习的方法。通过减小权重参数的值来抑制过拟合的发生，提高泛化能力。该方法通过在学习的过程中对大的权重进行惩罚，来抑制过拟合。</p><h5 id="l1范数">L1范数</h5><p>L1范数是各个元素的绝对值之和，即<spanclass="math inline">\(|w_1|+|w_2|+\cdots+|w_n|\)</span></p><h5 id="l2范数">L2范数</h5><p>L2范数相当于各个元素的平方和。用数学式表示的话，假设有权重<spanclass="math inline">\(W = (w_,w_2, ... ,w_n)\)</span>，则L2范数为<spanclass="math inline">\(\sqrt{w_1^2+w_2^2+\cdots+w_n^2}\)</span>。L2是比较常用的 范数。</p><h5 id="l范数">L∞范数</h5><p>L∞也称为Max范数，相当于各个元素的绝对值中最大的那一个。</p><h5 id="dropout">DropOut</h5><p>Dropout是一种在学习的过程中随机删除神经元的方法。训练时，随机选出隐藏层的神经元，然后将其删除。被删除的神经元不再进行信号的传递。</p><h4 id="超参数及最优化">超参数及最优化</h4><p><strong>超参数</strong>（hyper-parameter）是指，比如各层的神经元数量、batch大小、参数更新时的学习率或权值衰减等。如果这些超参数没有设置合适的值，模型的性能就会很差。</p><h5 id="超参数的最优化">超参数的最优化</h5><p>进行超参数的最优化时，逐渐缩小超参数的“好值”的存在范围非常重要。所谓逐渐缩小范围，是指一开始先大致设定一个范围，从这个范围中随机选出一个超参数（采样），用这个采样到的值进行识别精度的评估；然后，多次重复该操作，观察识别精度的结果，根据这个结果缩小超参数的“好值”的范围。通过重复这一操作，就可以逐渐确定超参数的合适范围。</p><h4 id="验证数据">验证数据</h4><p>验证数据（validationdata）用于调整超参数的数据。使用这个验证数据来评估超参数的好坏。</p><p>训练数据用于参数（权重和偏置）的学习，验证数据用于超参数的性能评估。为了确认泛化能力，要在最后使用（比较理想的是只用一次）测试数据。</p><h3 id="卷积神经网络">卷积神经网络</h3><p><strong>卷积神经网络</strong>（Convolutional Neural Network，CNN）中新增了 Convolution 层和 Pooling 层。CNN 的层的连接顺序是“Convolution -ReLU -（Pooling） ”</p><h4 id="卷积层">卷积层</h4><h5 id="特征图">特征图</h5><p>卷积层的输入输出数据称为<strong>特征图</strong>（featuremap）。其中，卷积层的输入数据称为<strong>输入特征图</strong>（inputfeature map）， 输 出数据称为<strong>输出特征图</strong>（output featuremap）。</p><h5 id="卷积运算">卷积运算</h5><p>卷积层进行的处理就是卷积运算。卷积运算相当于图像处理中的“滤波器运算”。</p><center><img src="cnn_calc.png" alt="卷积运算" style="zoom:33%;" /> <br/><br/>图： 卷积运算</center><h5 id="填充">填充</h5><p>在进行卷积层的处理之前，有时要向输入数据的周围填入固定的数据（比如0等），这称为<strong>填充</strong>（padding），使用填充主要是为了调整输出的大小。</p><h5 id="步幅">步幅</h5><p>应用滤波器的位置间隔称为<strong>步幅</strong>（stride）。增大步幅后，输出大小会变小。而增大填充后，输出大小会变大。</p><p>假设输入大小为(H, W)，滤波器大小为(FH, FW)，输出大小为(OH,OW)，填充为P，步幅为S。此时，输出大小可通过下列公式进行计算。 <spanclass="math display">\[\displaylines {OH = \frac{H+2P-FH}{S} + 1\\OW = \frac{W+2P-FW}{S} + 1}\]</span></p><h5 id="批处理">批处理</h5><p>神经网络的处理中进行了将输入数据打包的批处理。</p><center><img src="cnn_bat.png" alt="卷积运算的批处理" style="zoom:33%;" /><br/><br/> 图： 卷积运算的批处理</center><h4 id="池化层">池化层</h4><p>池化是缩小高、长方向上的空间的运算。</p><p>常用的池化方法有Max池化、Average池化等。</p><h5 id="max池化">Max池化</h5><p>Max池化是从目标区域中取出最大值。</p><h5 id="average池化">Average池化</h5><p>Average池化则是计算目标区域的平均值。</p><h5 id="池化层的特征">池化层的特征</h5><ol type="1"><li>没有要学习的参数池化层和卷积层不同，没有要学习的参数。池化只是从目标区域中取最大值（或者平均值），所以不存在要学习的参数。</li><li>通道数不发生变化经过池化运算，输入数据和输出数据的通道数不会发生变化。计算是按通道独立进行的。</li><li>对微小的位置变化具有鲁棒性（健壮）输入数据发生微小偏差时，池化仍会返回相同的结果。因此，池化对输入数据的微小偏差具有鲁棒性。</li></ol><h4 id="代表性的cnn网络结构">代表性的CNN网络结构</h4><h5 id="lenet">LeNet</h5><p>LeNet在1998年被提出，是进行手写数字识别的网络，它有连续的卷积层和池化层（正确地讲，是只“抽选元素”的子采样层），最后经全连接层输出结果。LeNet中使用sigmoid激活函数</p><h5 id="alexnet">AlexNet</h5><p>AlexNet叠有多个卷积层和池化层，最后经由全连接层输出结果。AlexNet的特点：</p><ol type="1"><li>激活函数使用ReLU。</li><li>使用进行局部正规化的LRN（Local Response Normalization）层 。</li><li>使用Dropout。</li></ol><h3 id="深度学习">深度学习</h3><h4 id="为什么要加深层">为什么要加深层?</h4><ol type="1"><li>层越深，识别性能也越高。</li><li>可以减少网络的参数数量。</li><li>叠加小型滤波器来加深网络的好处是可以减少参数的数量，扩大感受野（receptive field，给神经元施加变化的某个局部空间区域）。并且，通过叠加层，将ReLU等激活函数夹在卷积层的中间，进一步提高了网络的表现力。这是因为向网络添加了基于激活函数的“非线性”表现力，通过非线性函数的叠加，可以表现更加复杂的东西。</li><li>加深层的另一个好处就是使学习更加高效。</li></ol><h4 id="其他的网络结构">其他的网络结构</h4><h5 id="vgg">VGG</h5><p>VGG是由卷积层和池化层构成的基础的CNN。</p><h5 id="googlenet">GoogleNet</h5><p>GoogleNet的特征是，网络不仅在纵向上有深度，在横向上也有深度（广度）。GoogleNet在横向上有“宽度”，这称为“Inception结构”。</p><h5 id="resnet">ResNet</h5><p>ResNet是微软团队开发的网络。它的特征在于具有比以前的网络更深的结构。</p><p>《深度学习入门：基于Python的理论与实现》是一本非常好的入门书，本文的内容就来自于对这本书的整理。</p>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python知识点</title>
    <link href="/2024/07/16/python%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2024/07/16/python%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="python函数的参数">Python函数的参数</h3><hr /><p>python函数的主要参数类型有：默认参数、关键字参数（位置参数）、不定长参数。</p><h5 id="默认参数">默认参数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"> a , b , c = <span class="hljs-number">0</span> </span>):<br>    <span class="hljs-comment"># 打印参数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数a：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(a) , end = <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数b：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(b) , end = <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数c：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(c))<br>    <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment"># 调用 func 函数</span><br>func( <span class="hljs-string">&#x27;a&#x27;</span> , <span class="hljs-number">10</span> , <span class="hljs-number">12</span>)<br>func( <span class="hljs-string">&#x27;b&#x27;</span> , <span class="hljs-number">100</span> )<br></code></pre></td></tr></table></figure><p>输出：</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">&gt;参数<span class="hljs-selector-tag">a</span>：<span class="hljs-selector-tag">a</span> 参数<span class="hljs-selector-tag">b</span>：<span class="hljs-number">10</span> 参数c：<span class="hljs-number">12</span><br>&gt;参数<span class="hljs-selector-tag">a</span>：<span class="hljs-selector-tag">b</span> 参数<span class="hljs-selector-tag">b</span>：<span class="hljs-number">100</span> 参数c：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></blockquote><p>当设置了默认参数的时候，在调用函数的时候，不传该参数，就会使用默认值</p><p><strong>只有在形参表末尾的那些参数可以有默认参数值</strong>，deffunc(a, b=1) 是有效的，但是 def func(a=1, b) 是 无效 的。</p><p>如果想判断默认参数有没有值传递进来，可以这样设置参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br>_no_value =<span class="hljs-built_in">object</span>()<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"> a , b = _no_value </span>):<br>    <span class="hljs-keyword">if</span> b <span class="hljs-keyword">is</span> _no_value :<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;b 没有赋值&#x27;</span>)<br>    <span class="hljs-keyword">return</span>;<br>func(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>输出:</p><blockquote><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">&gt;<span class="hljs-keyword">b</span> 没有赋值<br></code></pre></td></tr></table></figure></blockquote><h5 id="关键字参数位置参数">关键字参数（位置参数）</h5><p>一般情况下，给函数传参的时候，是按照顺序传递参数的，如果不对应顺序，就会传错值。</p><p>不过在 Python中，可以通过参数名来给函数传递参数，而不用关心参数列表定义时的顺序，这被称之为关键字参数。</p><p>使用关键参数有两个优势 ：</p><ul><li>由于我们不必担心参数的顺序，使用函数变得更加简单了。</li><li>假设其他参数都有默认值，我们可以只给我们想要的那些参数赋值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"> a , b , c = <span class="hljs-number">0</span> </span>):<br>    <span class="hljs-comment"># 打印参数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数a：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(a) , end = <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数b：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(b) , end = <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数c：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(c))<br>    <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment"># 调用 func 函数</span><br>func( a=<span class="hljs-string">&#x27;a&#x27;</span> , b=<span class="hljs-number">10</span> , c=<span class="hljs-number">12</span>)<br>func( a=<span class="hljs-string">&#x27;b&#x27;</span> , c=<span class="hljs-number">100</span>, b=<span class="hljs-number">1000</span> )<br></code></pre></td></tr></table></figure><p>输出：</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">&gt;参数<span class="hljs-selector-tag">a</span>：<span class="hljs-selector-tag">a</span> 参数<span class="hljs-selector-tag">b</span>：<span class="hljs-number">10</span> 参数c：<span class="hljs-number">12</span><br>&gt;参数<span class="hljs-selector-tag">a</span>：<span class="hljs-selector-tag">b</span> 参数<span class="hljs-selector-tag">b</span>：<span class="hljs-number">1000</span> 参数c：<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure></blockquote><p>从输出结果看，在第二次调用的时候，即使用 func( a='b' , c=100, b=1000) 也可以把参数传递到函数执行体。</p><h5 id="不定长参数">不定长参数</h5><p>有些时候，在设计函数的时候，无法确定传入的参数个数。这种情况下，就可以使用不定长参数。</p><p>Python提供了一种元组的方式来接受没有直接定义的参数。这种方式在参数前边加星号<code>*</code> 。</p><p>如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"> a , b , c=<span class="hljs-number">0</span>, *args</span>):<br>    <span class="hljs-comment"># 打印参数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数a：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(a) , end = <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数b：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(b) , end = <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数c：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(c))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数args：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(args))<br>    <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment"># 调用 func 函数</span><br>func( <span class="hljs-string">&#x27;a&#x27;</span> , <span class="hljs-number">10</span> , <span class="hljs-number">12</span>, <span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-string">&quot;345&quot;</span>,<span class="hljs-number">789</span>)<br>func( a=<span class="hljs-string">&#x27;b&#x27;</span> , c=<span class="hljs-number">100</span>, b=<span class="hljs-number">1000</span> )<br></code></pre></td></tr></table></figure><p>输出:</p><blockquote><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less">&gt;参数<span class="hljs-selector-tag">a</span>：<span class="hljs-selector-tag">a</span> 参数<span class="hljs-selector-tag">b</span>：<span class="hljs-number">10</span> 参数<span class="hljs-selector-tag">c</span>：<span class="hljs-number">12</span><br>&gt;参数<span class="hljs-selector-tag">args</span>：(<span class="hljs-string">&#x27;123&#x27;</span>, <span class="hljs-string">&#x27;345&#x27;</span>, <span class="hljs-number">789</span>)<br>&gt;参数<span class="hljs-selector-tag">a</span>：<span class="hljs-selector-tag">b</span> 参数<span class="hljs-selector-tag">b</span>：<span class="hljs-number">1000</span> 参数<span class="hljs-selector-tag">c</span>：<span class="hljs-number">100</span><br>&gt;参数<span class="hljs-selector-tag">args</span>：()<br></code></pre></td></tr></table></figure></blockquote><p>如果需要传不定长的参数<code>*args</code>，那么就不要使用位置参数传递，否则会报错。如果需要通过位置参数的方式传递不定长参数，就需要用<code>**args</code>的方式。使用方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"> a , b , c=<span class="hljs-number">0</span>, **args</span>):<br>    <span class="hljs-comment"># 打印参数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数a：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(a) , end = <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数b：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(b) , end = <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数c：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(c))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数args：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(args))<br>    <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment"># 调用 func 函数</span><br>func( a=<span class="hljs-string">&#x27;a&#x27;</span> , b=<span class="hljs-number">10</span> , c=<span class="hljs-number">12</span>, args=(<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-string">&quot;345&quot;</span>,<span class="hljs-number">789</span>))<br>func( a=<span class="hljs-string">&#x27;b&#x27;</span> , c=<span class="hljs-number">100</span>, b=<span class="hljs-number">1000</span> )<br></code></pre></td></tr></table></figure><p>输出：</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">参数a：a 参数b：10 参数c：12</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">参数args：&#123;<span class="hljs-string">&#x27;args&#x27;</span>: (<span class="hljs-string">&#x27;123&#x27;</span>, <span class="hljs-string">&#x27;345&#x27;</span>, 789)&#125;</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">参数a：b 参数b：1000 参数c：100</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">参数args：&#123;&#125;</span><br></code></pre></td></tr></table></figure></blockquote><p>通过对比两个例子，可以知道，<code>*args</code>是可变参数，且args其实就是一个 tuple （元组），<code>**args</code>是关键字参数，且args 就是一个 dict （字典）</p><h5 id="只接受关键字参数">只接受关键字参数</h5><p>关键字参数使用简单，不容易出错，如果希望某些参数强制使用关键字参数传递，这时候该怎么办呢？</p><p>将强制关键字参数放到某个<code>*</code>参数或者单个<code>*</code>后面就能达到这种效果,比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"> a , *, b , c=<span class="hljs-number">0</span></span>):<br>    <span class="hljs-comment"># 打印参数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数a：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(a) , end = <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数b：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(b) , end = <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数c：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(c))<br>    <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment"># 调用 func 函数</span><br>func( a=<span class="hljs-string">&#x27;a&#x27;</span> , b=<span class="hljs-number">10</span> , c=<span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure><p>在这个代码中，函数的参数中，在参数<code>a</code>的后面加了<code>*</code>,那么参数<code>b</code>和参数<code>c</code>就要使用关键字参数。否则就会报错。</p><p>func( 'a' , 10 ) 或者 func( 'a' , b=10,100) 这样的传参调用就会报错，func( 'a' , b=10 ) 或者 func( a='a' , b=10,c=a00 )则没有问题。</p><p>原因就在于 *之后的参数必须用关键字参数传递，如果最后一个有默认值则可以不传递。</p><h3 id="类与对象">类与对象</h3><hr /><p>面向对象有两个基本的概念，分别是类和对象。面向对象的编程语言，也有三大特性，继承，多态和封装性。</p><h5 id="新式类与旧式类经典类">新式类与旧式类（经典类）</h5><p>Python2.x中，默认都是经典类，只有显式继承了object的才是新式类，即：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Person</span>(<span class="hljs-symbol">object</span>):<span class="hljs-symbol">pass</span>    新式类<br><span class="hljs-symbol">class</span> <span class="hljs-symbol">Person</span>():<span class="hljs-symbol">pass</span>    经典类<br></code></pre></td></tr></table></figure><p>在<ahref="https://so.csdn.net/so/search?q=Python&amp;spm=1001.2101.3001.7020">Python</a>3.x中取消了经典类，默认都是新式类，并且不必显式的继承object，也就是说：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Person</span>(<span class="hljs-symbol">object</span>):<span class="hljs-symbol">pass</span>    新式类<br><span class="hljs-symbol">class</span> <span class="hljs-symbol">Person</span>():<span class="hljs-symbol">pass</span>     新式类<br></code></pre></td></tr></table></figure><p><code>新式类</code>和<code>经典类（旧式类）</code>的<code>区别</code>的在于<code>子类多继承</code>的情况下，<code>经典类</code>多继承搜索顺序是<code>深度优先</code>，<code>新式类</code>多继承搜索顺序是<code>广度优先</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#这里基类Person显式的继承了object</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, I&#x27;m Person.&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, I&#x27;m Man.&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Woman</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, I&#x27;m Woman.&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span>(Man,Woman):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>child = Child()<br>child.say_hello()<br></code></pre></td></tr></table></figure><p>输出：</p><blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">&gt;Hello, I<span class="hljs-symbol">&#x27;m</span> Man.<br></code></pre></td></tr></table></figure></blockquote><p>如果注释掉 Man的say_hello方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#这里基类Person显式的继承了object</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, I&#x27;m Person.&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-comment"># def say_hello(self):</span><br>    <span class="hljs-comment">#     print(&quot;Hello, I&#x27;m Man.&quot;)</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Woman</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, I&#x27;m Woman.&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span>(Man,Woman):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>child = Child()<br>child.say_hello()<br><br></code></pre></td></tr></table></figure><p>输出:</p><blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">&gt;Hello, I<span class="hljs-symbol">&#x27;m</span> Woman.<br></code></pre></td></tr></table></figure></blockquote><p>child继承了Man和Woman两个类，新式类机制下，child先调用man的say_hello方法，如果man没有该方法，则调用Woman下的say_hello方法，是广度优先调用策略。如果是深度优先，child会优先调用man的say_hello方法，如果没有，然后会调用man的父类的方法。</p><h5 id="调用类的属性和方法">调用类的属性和方法</h5><p>类里面定义的变量是属性，类里面定义的函数是方法。</p><p>调用格式：类.变量 、 类.方法</p><h5 id="类方法">类方法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    a = <span class="hljs-number">1</span><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">funcA</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a=&quot;</span>,cls.a)<br>        <br>    <span class="hljs-comment">#def funcB():</span><br>    <span class="hljs-comment">#    print(&quot;a=&quot;,a) #无法调用类属性</span><br>        <br>obj = ClassA()<br>obj.funcA()<br>ClassA.funcA()<br></code></pre></td></tr></table></figure><p>类方法调用类属性，需要以下步骤：</p><ul><li>在方法上面，用 <code>@classmethod</code>声明该方法是类方法。只有声明了是类方法，才能使用类属性</li><li>类方法想要使用类属性，在第一个参数中，需要写上 <code>cls</code> ,cls 是 class的缩写，其实意思就是把这个类作为参数，传给自己，这样就可以使用类属性了。</li><li>类属性的使用方式就是 <code>cls.变量名</code></li></ul><p>无论是 <code>@classmethod</code> 还是 <code>cls</code>,都是不能省去的。</p><h5 id="增加和修改类的属性">增加和修改类的属性</h5><p>有两种方法可以修改和增加类的属性，在类的内部和类的外部</p><p>类的内外部部修改、添加属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    a = <span class="hljs-number">1</span><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a=&quot;</span>,cls.a)<br>        cls.a = <span class="hljs-number">3</span> <span class="hljs-comment">#内部修改属性</span><br>        cls.b = <span class="hljs-number">2</span> <span class="hljs-comment">#内部添加属性 </span><br>        <br>obj = ClassA()<br>obj.func()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;内部修改后 a =&quot;</span>, ClassA.a)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;内部添加 b =&quot;</span>, ClassA.b)<br><br>ClassA.a = <span class="hljs-number">4</span> <span class="hljs-comment">#外部修改属性</span><br>ClassA.c = <span class="hljs-number">5</span> <span class="hljs-comment">#外部添加属性</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;外部修改后 a =&quot;</span>, ClassA.a)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;外部添加 c =&quot;</span>, ClassA.c)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a=&quot;</span>,obj.a,<span class="hljs-string">&quot;b=&quot;</span>,obj.b,<span class="hljs-string">&quot;c=&quot;</span>,obj.c)<br></code></pre></td></tr></table></figure><p>输出:</p><blockquote><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&gt;a<span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>&gt;内部修改后 a <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>&gt;内部添加 b <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>&gt;外部修改后 a <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>&gt;外部添加 c <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br>&gt;a<span class="hljs-operator">=</span> <span class="hljs-number">4</span> b<span class="hljs-operator">=</span> <span class="hljs-number">2</span> c<span class="hljs-operator">=</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></blockquote><h5id="类属性与实例属性类方法与实例方法">类属性与实例属性、类方法与实例方法</h5><p>先说结论：</p><blockquote><p><strong>类属性改变了，实例属性会跟着改变。</strong><strong>实例属性改变了，类属性不会改变</strong>。</p><p><strong>类方法改变了，实例方法会跟着改变。</strong><strong>实例方法改变了，类方法不会改变(会报错)。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    a = <span class="hljs-number">1</span><br><br>    <span class="hljs-comment">#类方法</span><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a=&quot;</span>,cls.a)<br>    <span class="hljs-comment">#实例方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;func1 a=&quot;</span>, self.a)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func2</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;func2&quot;</span>)<br>        <br>obj = ClassA()<br>obj.func()<br>obj.func1()<br><span class="hljs-comment"># obj.func2() #报错</span><br><br>ClassA.func()<br><span class="hljs-comment"># ClassA.func1() #报错</span><br>ClassA.func2()<br></code></pre></td></tr></table></figure><p>类属性与实例属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    a = <span class="hljs-number">1</span><br><br>    <span class="hljs-comment">#类方法</span><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a=&quot;</span>,cls.a)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;func1 a=&quot;</span>, self.a)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func2</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;func2&quot;</span>)<br>        <br>obj = ClassA()<br>obj.func()<br>obj.func1()<br><span class="hljs-comment"># obj.func2() #报错</span><br><br>ClassA.func()<br><span class="hljs-comment"># ClassA.func1() #报错</span><br>ClassA.func2()<br><br>ClassA.a = <span class="hljs-number">3</span> <span class="hljs-comment">#修改类属性</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;类属性修改为：&quot;</span>,ClassA.a) <span class="hljs-comment">#实例属性由1 改为 3</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;实例属性修改为：&quot;</span>,obj.a) <span class="hljs-comment">#实例属性由1 改为 3</span><br>obj.a = <span class="hljs-number">4</span> <span class="hljs-comment"># 修改实例属性为4</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;实例属性修改为：&quot;</span>, obj.a)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;类属性：&quot;</span>, ClassA.a) <span class="hljs-comment">#修改实例属性，类属性不变</span><br></code></pre></td></tr></table></figure><p>输出</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">a= 1</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">func1 a= 1</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">a= 1</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">func2</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">类属性修改为： 3</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">实例属性修改为： 3</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">实例属性修改为： 4</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">类属性： 3</span><br></code></pre></td></tr></table></figure></blockquote><p>类方法与实例方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    a = <span class="hljs-number">1</span><br><br>    <span class="hljs-comment">#类方法</span><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a=&quot;</span>,cls.a)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;func1 a=&quot;</span>, self.a)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func3</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;func3&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func2</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;func2&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">newfunc</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这是新方法&quot;</span>)<br>        <br>obj = ClassA()<br>obj.func()<br>obj.func1()<br><span class="hljs-comment"># obj.func2() #报错</span><br><br>ClassA.func()<br><span class="hljs-comment"># ClassA.func1() #报错</span><br>ClassA.func2()<br><br>ClassA.func1 = newfunc <span class="hljs-comment">#修改类的方法</span><br>obj.func1() <span class="hljs-comment"># 实例方法改变</span><br><br>obj.func3 = newfunc<br>obj.func3()  <span class="hljs-comment">#会报错</span><br></code></pre></td></tr></table></figure><p>输出:</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">a= 1</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">func1 a= 1</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">a= 1</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">func2</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">这是新方法</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">---------------------------------------------------------------------------</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">TypeError                                 Traceback (most recent call last)</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">Cell In[101], line 34</span><br>    31 obj.func1() # 实例方法改变<br>    33 obj.func3 = newfunc<br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">---&gt; 34 obj.func3()  <span class="hljs-comment">#会报错</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">TypeError: newfunc() missing 1 required positional argument: <span class="hljs-string">&#x27;self&#x27;</span></span><br></code></pre></td></tr></table></figure></blockquote><h5 id="类中的函数">类中的函数</h5><p>构造函数（初始化函数），在创建实例的时候会自动调用<code>__init__(self)</code></p><p>析构函数:当销毁一个实例对象的时候，会自动调用<code>__del__(self)</code></p><h5 id="类的继承重写">类的继承、重写</h5><p>Python支持多继承，格式如下所示，如果是单独定义的一个类，也建议继承object，因为object是一切类的基类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>(Base1,Base2,Base3):<br>    &lt;statement-<span class="hljs-number">1</span>&gt;<br>    .<br>    .<br>    .<br>    &lt;statement-N&gt;<br></code></pre></td></tr></table></figure><p>类的重写</p><p>子类在继承父类的情况下，如果子类没有定义自己的构造函数<code>__init__</code>，也会调用父类的构造函数<code>__init__</code>，如果定义了构造函数<code>__init__</code>,就是重写了父类的构造函数。如果重写了父类的构造函数，还需要调用父类的构造函数，则通过<code>super()</code>方式调用。</p><p><strong>super() 在 python2、3中的区别</strong>：</p><p>Python3.x 和 Python2.x 的一个区别: Python 3 可以使用直接使用super().xxx 代替 super(Class, self).xxx :</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">python3 直接写成 ： super()<span class="hljs-selector-class">.__init__</span>()<br>python2 必须写成 ：super(本类名,self)<span class="hljs-selector-class">.__init__</span>()<br></code></pre></td></tr></table></figure><p>Python3.x中的重写例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):<br>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, x</span>):<br>         y = x+<span class="hljs-number">1</span><br>         <span class="hljs-built_in">print</span>(y)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, x</span>):  <span class="hljs-comment">#重写父类方法</span><br>        <span class="hljs-built_in">super</span>().add(x)  <span class="hljs-comment">#调用父类方法</span><br>b = B()<br>b.add(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 3</span><br></code></pre></td></tr></table></figure><p>python2.x中的重写例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):   <span class="hljs-comment"># Python2.x 记得继承 object</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, x</span>):<br>         y = x+<span class="hljs-number">1</span><br>         <span class="hljs-built_in">print</span>(y)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, x</span>): <span class="hljs-comment">#重写父类方法</span><br>        <span class="hljs-built_in">super</span>(B, self).add(x) <span class="hljs-comment">#调用父类方法</span><br>b = B()<br>b.add(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 3</span><br><br></code></pre></td></tr></table></figure><h5 id="类的多态">类的多态</h5><p>类的多态指对不同类型的变量进行相同的操作，它会根据对象（或类）类型的不同而表现出不同的行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">printUser</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello !&#x27;</span> + self.name)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserVip</span>(<span class="hljs-title class_ inherited__">User</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">printUser</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello ! 尊敬的Vip用户：&#x27;</span> + self.name)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserGeneral</span>(<span class="hljs-title class_ inherited__">User</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">printUser</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello ! 尊敬的用户：&#x27;</span> + self.name)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">printUserInfo</span>(<span class="hljs-params">user</span>):<br>    user.printUser()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    userVip = UserVip(<span class="hljs-string">&#x27;VIP&#x27;</span>)<br>    printUserInfo(userVip)<br>    userGeneral = UserGeneral(<span class="hljs-string">&#x27;普通用户&#x27;</span>)<br>    printUserInfo(userGeneral)<br><br></code></pre></td></tr></table></figure><p>输出</p><blockquote><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">&gt;Hello ! 尊敬的Vip用户：VIP<br>&gt;Hello ! 尊敬的用户：普通用户<br></code></pre></td></tr></table></figure></blockquote><p>从输出可以看到 根据对象的不同调用不同的实例方法。</p><h5 id="重载与重写">重载与重写</h5><p><strong>重写</strong>子类对父类的允许访问的方法的实现过程进行重新编写,返回值和形参都不能改变。</p><p><strong>优点：</strong>子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法。</p><p><strong>重载</strong>(overloading)是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p><p>*重载与重写的区别**</p><ol type="1"><li>方法重载是一个类中定义了多个方法名相同，而他们的参数的数量不同或数量相同而类型和次序不同，则称为方法的重载。</li><li>方法重写是在子类存在方法与父类的方法的名字相同，而且参数的个数与类型一样，返回值也一样的方法，就称为重写。</li><li>方法重载是一个类的多态性表现，而方法重写是子类与父类的一种多态性表现。</li></ol><h5 id="类的封装">类的封装</h5><p>创建一个类，实际上是将具有特定属性或功能的数据或方法，“打包”定义到一个模块中，供我们需要时调用它们。这个打包的行为，我们也称“类的封装”。</p><p>如何管理和使用被封装在类中的属性或者方法，就需用到类的访问控制。</p><h5 id="类的访问控制">类的访问控制</h5><p><strong>属性的访问控制</strong></p><p>在python中，一般情况下，会使用 <code>__private_attrs</code>两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时<code>self.__private_attrs</code>。</p><p>实际上， Python 中是没有提供私有属性等功能的。Python对属性的访问控制是靠程序员自觉的。</p><p><strong>方法的访问控制</strong></p><p>方法的访问控制也是跟属性是一样的，也是没有实质上的私有方法。一切都是靠程序员自觉遵守Python 的编程规范，具体规则也是跟属性一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, account</span>):<br>        self.name = name<br>        self._age = age<br>        self.__account = account <span class="hljs-comment">#私有属性</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">upgrade</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_buy_equipment</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__pk</span>(<span class="hljs-params">self</span>): <span class="hljs-comment"># 私有方法</span><br>        <span class="hljs-keyword">pass</span><br><br></code></pre></td></tr></table></figure><h5 id="类专有的方法">类专有的方法</h5><table><thead><tr class="header"><th>方法</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>__init__</code></td><td>构造函数，在生成对象时调用</td></tr><tr class="even"><td><code>__del__</code></td><td>析构函数，释放对象时使用</td></tr><tr class="odd"><td><code>__repr__</code></td><td>打印，转换</td></tr><tr class="even"><td><code>__setitem__</code></td><td>按照索引赋值</td></tr><tr class="odd"><td><code>__getitem__</code></td><td>按照索引获取值</td></tr><tr class="even"><td><code>__len__</code></td><td>获得长度</td></tr><tr class="odd"><td><code>__cmp__</code></td><td>比较运算</td></tr><tr class="even"><td><code>__call__</code></td><td>函数调用</td></tr><tr class="odd"><td><code>__add__</code></td><td>加运算</td></tr><tr class="even"><td><code>__sub__</code></td><td>减运算</td></tr><tr class="odd"><td><code>__mul__</code></td><td>乘运算</td></tr><tr class="even"><td><code>__div__</code></td><td>除运算</td></tr><tr class="odd"><td><code>__mod__</code></td><td>求余运算</td></tr><tr class="even"><td><code>__pow__</code></td><td>乘方</td></tr></tbody></table><p>需要获取类的相关信息，我们可以使用如下的方法：</p><ul><li><code>type(obj)</code>：来获取对象的相应类型；</li><li><code>isinstance(obj, type)</code>：判断对象是否为指定的 type类型的实例；</li><li><code>hasattr(obj, attr)</code>：判断对象是否具有指定属性/方法；</li><li><code>getattr(obj, attr[, default])</code> 获取属性/方法的值,要是没有对应的属性则返回 default 值（前提是设置了 default），否则会抛出AttributeError 异常；</li><li><code>setattr(obj, attr, value)</code>：设定该属性/方法的值，类似于obj.attr=value；</li><li><code>dir(obj)</code>：可以获取相应对象的所有属性和方法名的列表：</li></ul><h3 id="闭包与装饰器">闭包与装饰器</h3><h5 id="闭包">闭包</h5><p><strong>闭包</strong>是指一个函数可以记住其外部变量并可以访问这些变量。</p><p>举个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num</span>):<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + num<br>    <span class="hljs-keyword">return</span>  <span class="hljs-built_in">sum</span><br><br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">2</span>)) <span class="hljs-comment">#报错 UnboundLocalError: cannot access local variable &#x27;sum&#x27; where it is not associated with a value</span><br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">10</span>)) <br></code></pre></td></tr></table></figure><p>比如要做一个求和，第7行会报错。因为，在 Python中，如果一个函数使用了和全局变量相同的名字且改变了该变量的值，那么该变量就会变成局部变量，那么就会造成在函数中我们没有进行定义就引用了，所以会报该错误。</p><p>如果要引用全局变量，并在函数中对它进行修改，请使用global关键字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num</span>):<br>    <span class="hljs-keyword">global</span> <span class="hljs-built_in">sum</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + num<br>    <span class="hljs-keyword">return</span>  <span class="hljs-built_in">sum</span><br><br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><p>输出:</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">12</span><br></code></pre></td></tr></table></figure></blockquote><p>使用全局变量的缺点：不同模块，不同函数都可以自由的访问全局变量，可能会造成全局变量的不可预知性。</p><p>可是使用<strong>闭包</strong>来解决。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_num</span>(<span class="hljs-params"><span class="hljs-built_in">sum</span></span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num</span>):<br>        <span class="hljs-keyword">nonlocal</span> <span class="hljs-built_in">sum</span><br>        <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + num<br>        <span class="hljs-keyword">return</span>  <span class="hljs-built_in">sum</span><br>    <span class="hljs-keyword">return</span> add<br><br>func = add_num(<span class="hljs-built_in">sum</span>)<br><span class="hljs-built_in">print</span>(func.__closure__) <br><span class="hljs-built_in">print</span>(func(<span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>)<br><span class="hljs-built_in">print</span>(func(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>)<br></code></pre></td></tr></table></figure><p>输出</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">(&lt;cell at 0x7f8c1d5d9480: int object at 0x94f1e8&gt;,)</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">0</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">12</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">0</span><br></code></pre></td></tr></table></figure></blockquote><p>在这段代码中，add_sum中 嵌套了一个函数add,add通过nonlocal关键字访问外部变量(add_sum的参数)sum，而最外层的sum变量并没有受到影响（依旧为0）。</p><p>在这里可以把global和nonlocal做一个区分：</p><p>两个关键词都用于允许在一个局部作用域中使用外层的变量。</p><ul><li>global 表示将变量声明为全局变量</li><li>nonlocal表示将变量声明为外层变量（外层函数的局部变量，而且不能是全局变量）</li><li>在使用 nonlocal a 之前，必须保证外层的确已经定义过 a 了，但是在global a的时候，可以允许全局变量中还没有定义过a，可以留在后面定义。</li></ul><p>python 在访问一个变量时，先要去定位这个变量来源于哪里。</p><p>python引用变量的顺序如下：</p><ol type="1"><li>当前作用域局部变量</li><li>外层作用域变量</li><li>当前模块中的全局变量</li><li>python内置变量</li></ol><p>即优先从局部作用域中查找这个变量，如果没有的话，再去外层找，如果到了最后还没找到，则报错。</p><p>这种内部函数的局部作用域中可以访问外部函数局部作用域中变量的行为，我们称为：闭包。更加直接的表达方式就是，当某个函数被当成对象返回时，夹带了外部变量，就形成了一个闭包。所有函数都有一个<code>__closure__</code> 属性，如果函数是闭包的话，那么它返回的是一个由cell 组成的元组对象。cell 对象的 cell_contents属性就是存储在闭包中的变量。如上面 的代码print(func.<code>__closure__</code> ) ，则可以得到输出 (&lt;cell at0x7f8c1d5d9480: int object at 0x94f1e8&gt;,)</p><h5 id="装饰器">装饰器</h5><p><strong>装饰器</strong>是修改其他函数的功能的函数。装饰器的实现就可以通过闭包来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;简单函数&#x27;</span>)<br>func()<br></code></pre></td></tr></table></figure><p>给这个简单的函数加点东西，比如输出时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>, time.localtime(time.time())))  <span class="hljs-comment"># 输出时间</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;简单函数&#x27;</span>)<br>func()<br></code></pre></td></tr></table></figure><p>在原来的基础上修改可以达到要求，但是不符合开闭原则（对扩展开放,对修改封闭），那么可以修改为如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;简单函数&#x27;</span>)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">new_func</span>():<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;新函数&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_time</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-built_in">print</span>(time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>, time.localtime(time.time())))<br>    func()<br><br>add_time(func)<br>add_time(new_func)<br></code></pre></td></tr></table></figure><p>通过添加add_time(func)这个功能函数，可以为任意的函数添加输出时间的功能。</p><p>这种方式虽然可以满足要求，但是写法上不好判断是哪个函数装饰哪个函数，有没有更好的写法呢?是有的，这个写法和闭包的写法有点相似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment">#装饰函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_time</span>():<br>        <span class="hljs-built_in">print</span>(time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>, time.localtime(time.time())))<br>        func() <br>    <span class="hljs-keyword">return</span> add_time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;简单函数&#x27;</span>)<br><br>f = decorator(func) <span class="hljs-comment"># 返回的函数对象</span><br>f()  <span class="hljs-comment"># 使用返回的函数对象调用函数</span><br></code></pre></td></tr></table></figure><p>在这段代码中，把add_time作为装饰函数的内部函数，把待装饰的函数传入装饰函数，并返回一个装饰的函数对象，通过调用这个返回的函数对象，就可以实现以上代码的功能，这中写法更简洁。</p><p>通过代码，能知道装饰器函数一般做这三件事：</p><ol type="1"><li>接收一个函数作为参数</li><li>嵌套一个包装函数,包装函数会接收原函数的相同参数，并执行原函数，且还会执行附加功能</li><li>返回嵌套函数。</li></ol><p>当然，有了装饰器函数， Python 设计出了 <code>@</code> 语法糖，让定义装饰器，把装饰器调用原函数再把结果赋值为原函数的对象名的过程变得更加简单，方便，易操作，所以Python装饰器的核心可以说就是它的语法糖。使用了语法糖的装饰器用法，有点像java中的注解。把上面的代码改为使用<code>@</code>语法糖的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment">#装饰函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_time</span>():<br>        <span class="hljs-built_in">print</span>(time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>, time.localtime(time.time())))<br>        func() <br>    <span class="hljs-keyword">return</span> add_time<br><br><span class="hljs-meta">@decorator  </span><span class="hljs-comment">#将装饰函数加到待装饰的函数上面，就可以为待装饰函数增添新的功能。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;简单函数&#x27;</span>)<br><br>func()<br></code></pre></td></tr></table></figure><p>通过使用<code>@</code>语法糖，将装饰函数加到待装饰的函数上面，就可以为待装饰函数增添新的功能。而且调用方式也与正常的调用方式保持一致，不需要通过函数对象的方式调用了。</p><h6 id="python内置的装饰器">python内置的装饰器</h6><table><thead><tr class="header"><th>装饰器</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><span class="citation" data-cites="lru_cache">@lru_cache</span></td><td>使用缓存技巧加速</td></tr><tr class="even"><td><span class="citation"data-cites="total_ordering">@total_ordering</span></td><td>根据定义的方法为 Python 类生成缺少的比较方法。</td></tr><tr class="odd"><td><span class="citation"data-cites="contextmanager">@contextmanager</span></td><td>Python 有一个上下文管理器机制来帮助你正确地管理资源。</td></tr><tr class="even"><td><span class="citation" data-cites="property">@property</span></td><td>使用 <span class="citation" data-cites="property">@property</span>装饰器可以设置每个类属性的getter和setter方法。</td></tr><tr class="odd"><td><span class="citation"data-cites="cached_property">@cached_property</span></td><td>Python 3.8 为 functool 模块引入了一个新的强大装饰器——<spanclass="citation"data-cites="cached_property">@cached_property</span>。它可以将一个类的方法转换为一个属性，该属性的值计算一次，然后在实例的生命周期内作为普通属性缓存。</td></tr><tr class="even"><td><span class="citation"data-cites="classmethod">@classmethod</span></td><td>要定义一个类方法，我们需要使用@classmethod 装饰器。</td></tr><tr class="odd"><td><span class="citation"data-cites="staticmethod">@staticmethod</span></td><td>要定义一个静态方法，我们只需要使用@staticmethod 装饰器</td></tr><tr class="even"><td><span class="citation" data-cites="dataclass">@dataclass</span></td><td><span class="citation"data-cites="dataclass装饰器">@dataclass装饰器</span>（Python3.7引入）可以自动为一个类生成几个特殊的方法，如<strong>init</strong>、<strong>repr</strong>、<strong>eq</strong>、<strong>lt</strong>等。</td></tr><tr class="odd"><td><span class="citation"data-cites="atexit.register">@atexit.register</span></td><td>来自 atexit 模块的 <span class="citation"data-cites="register">@register</span> 装饰器可以让我们在 Python解释器退出时执行一个函数。</td></tr></tbody></table><p>具体请参考这里的<ahref="https://cloud.tencent.com/developer/article/2210650">示例</a></p><h3 id="进程与线程">进程与线程</h3><p>进程是操作系统进行资源分配的最小单元，线程是操作系统进行运算调度的最小单元。</p><p>进程一般由程序、数据集合和进程控制块三部分组成：</p><ul><li>程序用于描述进程要完成的功能，是控制进程执行的指令集</li><li>数据集合是程序在执行时所需要的数据和工作区</li><li>程序控制块，包含进程的描述信息和控制信息，是进程存在的唯一标志</li></ul><p><strong>区别</strong></p><ul><li><strong>本质区别</strong>：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</li><li><strong>从属关系不同</strong>:进程中包含了线程，线程属于进程。一个进程可以有很多线程，每条线程并行执行不同的任务。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</li><li><strong>开销不同</strong>：进程的创建、销毁和切换的开销都远大于线程。由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统内多个程序间并发执行的程度，从而显著提高系统资源的利用率和吞吐量。</li><li><strong>拥有资源不同</strong>：每个进程有自己的内存和资源，一个进程中的线程会共享这些内存和资源。进程是资源分配的基本单位。所有与该进程有关的资源，都被记录在进程控制块PCB中。以表示该进程拥有这些资源或正在使用它们。另外，进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。</li><li><strong>控制和影响能力不同</strong>：子进程无法影响父进程，而子线程可以影响父线程，如果主线程发生异常会影响其所在进程和子线程。与进程相对应，线程与资源分配无关，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。</li><li><strong>CPU利用率不同</strong>：进程的CPU利用率较低，因为上下文切换开销较大，而线程的CPU的利用率较高，上下文的切换速度快。在多核或多CPU，或支持Hyper-threading的CPU上使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I/O处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，从而提高了程序的执行效率。</li></ul><h5 id="python的多线程">Python的多线程</h5><p>线程的状态可以分为</p><ul><li>New 创建</li><li>Runnable 就绪。等待调度</li><li>Running 运行</li><li>Blocked 阻塞。阻塞可能在 Wait Locked Sleeping</li><li>Dead 消亡</li></ul><p>线程的类型可分为：</p><ul><li>主线程</li><li>子线程</li><li>守护线程（后台线程）</li><li>前台线程</li></ul><p>Python 提供两个模块进行多线程的操作，分别是 <code>thread</code> 和<code>threading</code></p><p>Thread是比较低级的模块，用于更底层的操作。因此，主要用threading多一些。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> threading<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubThread</span>(threading.Thread):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;thread &#123;&#125;, @number: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self.name, i))<br>            time.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Start main threading&quot;</span>)<br><br>    <span class="hljs-comment"># 创建三个线程</span><br>    threads = [SubThread() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]<br>    <span class="hljs-comment"># 启动三个线程</span><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>        t.start()<br>    <span class="hljs-comment"># 让新创建的线程执行 join,等待子线程执行</span><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>        t.join()<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;End Main threading&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure><h5 id="线程同步">线程同步</h5><p>多线程会造成数据不同步的问题，在这种情况下，就要使用锁机制。pythonThreading模块提供了Lock功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">lock = threading.Lock()<br>lock.acquire()<br>lock.release()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> threading<br><br>shared_resource_lock = threading.Lock()<br><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubThread</span>(threading.Thread):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, threadname, startnum, endnum</span>):<br>        threading.Thread.__init__(self)<br>        self._threadname = threadname<br>        self._startnum = startnum<br>        self._endnum = endnum<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">global</span> <span class="hljs-built_in">sum</span><br>        shared_resource_lock.acquire() <span class="hljs-comment">#加锁</span><br>        <span class="hljs-comment"># print(self._startnum, self._endnum)</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self._startnum, self._endnum+<span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># print(i)</span><br>            <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + i<br>            time.sleep(<span class="hljs-number">0.1</span>)<br>        <span class="hljs-built_in">print</span>(self._threadname,<span class="hljs-string">&quot;计算结果&quot;</span>,<span class="hljs-built_in">sum</span>)<br>        shared_resource_lock.release() <span class="hljs-comment"># 释放锁</span><br>    <br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Start main threading&quot;</span>)<br><br>    <span class="hljs-comment"># 创建三个线程</span><br>    threads = [SubThread(<span class="hljs-string">&quot;线程&quot;</span>+<span class="hljs-built_in">str</span>(i), i*<span class="hljs-number">20</span>+<span class="hljs-number">1</span>, (i+<span class="hljs-number">1</span>)*<span class="hljs-number">20</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)]<br>    <span class="hljs-comment"># 启动三个线程</span><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>        t.start()<br><br>   <span class="hljs-comment"># 一次让新创建的线程执行 join</span><br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>        t.join()<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;End Main threading&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure><p>输出:</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">Start main threading</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">线程0 计算结果 210</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">线程1 计算结果 820</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">线程2 计算结果 1830</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">线程3 计算结果 3240</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">线程4 计算结果 5050</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">End Main threading</span><br></code></pre></td></tr></table></figure></blockquote><p>这段代码展示了使用多线程从1到100的求和。5个线程，每个线程负责20个数，最后得到5050的求和结果。为了保证求和的顺利进行，全局变量<code>sum</code>是共享的，所以需要通过加锁保证计算的正确性。</p><h5 id="线程同步的其他方式">线程同步的其他方式</h5><h6 id="可重入锁">可重入锁</h6><p>支持在同一线程中多次请求同一资源，Python提供了可重入锁（RLock）。RLock 内部维护着一个 Lock 和一个 counter变量，counter 记录了 acquire 的次数，从而使得资源可以被多次require。直到一个线程所有的 acquire 都被release，其他的线程才能获得资源。</p><p>r_lock = threading.RLock()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    lock = threading.RLock() <span class="hljs-comment"># 可重入锁</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.total_items = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">self, n</span>):<br>        Box.lock.acquire()<br>        self.total_items += n<br>        Box.lock.release()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self</span>):<br>        Box.lock.acquire()<br>        self.execute(<span class="hljs-number">1</span>)<br>        Box.lock.release()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">self</span>):<br>        Box.lock.acquire()<br>        self.execute(-<span class="hljs-number">1</span>)<br>        Box.lock.release()<br><br><span class="hljs-comment">## These two functions run n in separate</span><br><span class="hljs-comment">## threads and call the Box&#x27;s methods</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">adder</span>(<span class="hljs-params">box, items</span>):<br>    <span class="hljs-keyword">while</span> items &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;adding 1 item in the box&quot;</span>)<br>        box.add()<br>        time.sleep(<span class="hljs-number">1</span>)<br>        items -= <span class="hljs-number">1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">remover</span>(<span class="hljs-params">box, items</span>):<br>    <span class="hljs-keyword">while</span> items &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;removing 1 item in the box&quot;</span>)<br>        box.remove()<br>        time.sleep(<span class="hljs-number">1</span>)<br>        items -= <span class="hljs-number">1</span><br><br><span class="hljs-comment">## the main program build some</span><br><span class="hljs-comment">## threads and make sure it works</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    items = <span class="hljs-number">5</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;putting %s items in the box &quot;</span> % items)<br>    box = Box()<br>    t1 = threading.Thread(target=adder, args=(box, items))<br>    t2 = threading.Thread(target=remover, args=(box, items))<br>    t1.start()<br>    t2.start()<br><br>    t1.join()<br>    t2.join()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s items still remain in the box &quot;</span> % box.total_items)<br></code></pre></td></tr></table></figure><h6 id="信号量">信号量</h6><p>使用 semaphore = threading.Semaphore(0) 定义信号量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-string">&quot;&quot;&quot;Using a Semaphore to synchronize threads&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> random<br><br><span class="hljs-comment"># The optional argument gives the initial value for the internal</span><br><span class="hljs-comment"># counter;</span><br><span class="hljs-comment"># it defaults to 1.</span><br><span class="hljs-comment"># If the value given is less than 0, ValueError is raised.</span><br>semaphore = threading.Semaphore(<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">consumer</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;consumer is waiting.&quot;</span>)<br>        <span class="hljs-comment"># Acquire a semaphore</span><br>        semaphore.acquire()<br>        <span class="hljs-comment"># The consumer have access to the shared resource</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Consumer notify : consumed item number %s &quot;</span> % item)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">producer</span>():<br>        <span class="hljs-keyword">global</span> item<br>        time.sleep(<span class="hljs-number">0.5</span>)<br>        <span class="hljs-comment"># create a random item</span><br>        item = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;producer notify : produced item number %s&quot;</span> % item)<br>         <span class="hljs-comment"># Release a semaphore, incrementing the internal counter by one.</span><br>        <span class="hljs-comment"># When it is zero on entry and another thread is waiting for it</span><br>        <span class="hljs-comment"># to become larger than zero again, wake up that thread.</span><br>        semaphore.release()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (<span class="hljs-number">0</span>,<span class="hljs-number">5</span>) :<br>                t1 = threading.Thread(target=producer)<br>                t2 = threading.Thread(target=consumer)<br>                t1.start()<br>                t2.start()<br>                t1.join()<br>                t2.join()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;program terminated&quot;</span>)<br></code></pre></td></tr></table></figure><h6 id="条件">条件</h6><p>condition = Condition()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread, Condition<br><span class="hljs-keyword">import</span> time<br><br>items = []<br>condition = Condition()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">consumer</span>(<span class="hljs-title class_ inherited__">Thread</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        Thread.__init__(self)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">consume</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">global</span> condition<br>        <span class="hljs-keyword">global</span> items<br>        condition.acquire()<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(items) == <span class="hljs-number">0</span>:<br>            condition.wait()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Consumer notify : no item to consume&quot;</span>)<br>        items.pop()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Consumer notify : consumed 1 item&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Consumer notify : items to consume are &quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(items)))<br><br>        condition.notify()<br>        condition.release()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>):<br>            time.sleep(<span class="hljs-number">2</span>)<br>            self.consume()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">producer</span>(<span class="hljs-title class_ inherited__">Thread</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        Thread.__init__(self)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">produce</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">global</span> condition<br>        <span class="hljs-keyword">global</span> items<br>        condition.acquire()<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(items) == <span class="hljs-number">10</span>:<br>            condition.wait()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Producer notify : items producted are &quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(items)))<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Producer notify : stop the production!!&quot;</span>)<br>        items.append(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Producer notify : total items producted &quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(items)))<br>        condition.notify()<br>        condition.release()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>):<br>            time.sleep(<span class="hljs-number">1</span>)<br>            self.produce()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    producer = producer()<br>    consumer = consumer()<br>    producer.start()<br>    consumer.start()<br>    producer.join()<br>    consumer.join()<br></code></pre></td></tr></table></figure><h6 id="事件">事件</h6><p>Python 还提供了 Event对象用于线程间通信，它是由线程设置的信号标志，如果信号标志位真，则其他线程等待直到信号接触。</p><p>Event对象实现了简单的线程通信机制，它提供了设置信号，清除信号，等待等用于实现线程间的通信。</p><ul><li>设置信号</li></ul><p>使用 Event 的 <code>set()</code> 方法可以设置 Event对象内部的信号标志为真。Event 对象提供了 <code>isSet()</code>方法来判断其内部信号标志的状态。当使用 event 对象的 <code>set()</code>方法后，<code>isSet()</code> 方法返回真</p><ul><li>清除信号</li></ul><p>使用 Event 对象的 <code>clear()</code> 方法可以清除 Event对象内部的信号标志，即将其设为假，当使用 Event 的 clear 方法后，isSet()方法返回假</p><ul><li>等待</li></ul><p>Event 对象 wait的方法只有在内部信号为真的时候才会很快的执行并完成返回。当 Event对象的内部信号标志位假时，则 wait 方法一直等待到其为真时才返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread, Event<br><span class="hljs-keyword">import</span> random<br>items = []<br>event = Event()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">consumer</span>(<span class="hljs-title class_ inherited__">Thread</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, items, event</span>):<br>        Thread.__init__(self)<br>        self.items = items<br>        self.event = event<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            time.sleep(<span class="hljs-number">2</span>)<br>            self.event.wait()<br>            item = self.items.pop()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Consumer notify : %d popped from list by %s&#x27;</span> % (item, self.name))<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">producer</span>(<span class="hljs-title class_ inherited__">Thread</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, items, event</span>):<br>        Thread.__init__(self)<br>        self.items = items<br>        self.event = event<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">global</span> item<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>            time.sleep(<span class="hljs-number">2</span>)<br>            item = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">256</span>)<br>            self.items.append(item)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Producer notify : item N° %d appended to list by %s&#x27;</span> % (item, self.name))<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Producer notify : event set by %s&#x27;</span> % self.name)<br>            self.event.<span class="hljs-built_in">set</span>()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Produce notify : event cleared by %s &#x27;</span>% self.name)<br>            self.event.clear()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    t1 = producer(items, event)<br>    t2 = consumer(items, event)<br>    t1.start()<br>    t2.start()<br>    t1.join()<br>    t2.join()<br></code></pre></td></tr></table></figure><h5 id="python的多进程">python的多进程</h5><p>Python 中的多线程其实并不是真正的多线程，如果想要充分地使用多核 CPU的资源，在 Python 中大部分情况需要使用多进程。</p><p>Python 提供了非常好用的多进程包multiprocessing，只需要定义一个函数，Python 会完成其他所有事情。</p><p>借助这个包，可以轻松完成从单进程到并发执行的转换。multiprocessing支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock 等组件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> multiprocessing<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">i</span>):<br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;called function in process: %s&#x27;</span> %i)<br>    <span class="hljs-keyword">return</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    Process_jobs = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        p = multiprocessing.Process(target=foo, args=(i,))<br>        Process_jobs.append(p)<br>        p.start()<br>        p.join()<br></code></pre></td></tr></table></figure><p>创建进程的类：<code>Process([group [, target [, name [, args [, kwargs]]]]])</code></p><ul><li>target 表示调用对象</li><li>args 表示调用对象的位置参数元组</li><li>kwargs表示调用对象的字典</li><li>name为别名</li><li>group实质上不使用</li></ul><h6 id="使用类的形式创建进程">使用类的形式创建进程</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-keyword">import</span> multiprocessing<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClockProcess</span>(multiprocessing.Process):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, interval</span>):<br>        multiprocessing.Process.__init__(self)<br>        self.interval = interval<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        n = <span class="hljs-number">5</span><br>        <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前时间: &#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(time.ctime()))<br>            time.sleep(self.interval)<br>            n -= <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    p = ClockProcess(<span class="hljs-number">3</span>)<br>    p.start()<br><br></code></pre></td></tr></table></figure><h6 id="进程池">进程池</h6><p>因为进程的创建和销毁都需要消耗资源，可以使用进程池的方法批量创建子进程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Pool<br><span class="hljs-keyword">import</span> os, time, random<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">long_time_task</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;进程的名称：&#123;0&#125; ；进程的PID: &#123;1&#125; &#x27;</span>.<span class="hljs-built_in">format</span>(name, os.getpid()))<br>    start = time.time()<br>    time.sleep(random.random() * <span class="hljs-number">3</span>)<br>    end = time.time()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;进程 &#123;0&#125; 运行了 &#123;1&#125; 秒&#x27;</span>.<span class="hljs-built_in">format</span>(name, (end - start)))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主进程的 PID：&#123;0&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(os.getpid()))<br>    p = Pool(<span class="hljs-number">4</span>)  <span class="hljs-comment"># 进程池</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>        p.apply_async(long_time_task, args=(i,))<br>    p.close()<br>    <span class="hljs-comment"># 等待所有子进程结束后在关闭主进程</span><br>    p.join()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;【End】&#x27;</span>)<br></code></pre></td></tr></table></figure><h6 id="后台进程">后台进程</h6><p>如果需要处理比较巨大的任务，又不需要人为干预，将其作为后台进程执行是个非常常用的编程模型。此进程又可以和其他进程并发执行。通过Python的multiprocessing模块的后台进程选项，我们可以让进程在后台运行。</p><p>为了在后台运行进程，我们设置 <code>daemon</code> 参数为<code>True</code></p><p><strong>注意</strong> :后台进程不允许创建子进程。否则，当后台进程跟随父进程退出的时候，子进程会变成孤儿进程。另外，它们并不是Unix的守护进程或服务（daemonsorservices），所以当非后台进程退出，它们会被终结。后台运行进程在主进程结束之后会自动结束。</p><p>更过关于python并行编程的内容请参考<ahref="https://python-parallel-programmning-cookbook.readthedocs.io/zh-cn/latest/chapter2/index.html">这里</a>,<ahref="https://github.com/walter201230/Python/tree/master">教程</a></p><h3 id="模块与包">模块与包</h3><h6 id="模块">模块</h6><p><strong>在 Python 中，一个 .py文件就称之为一个模块（Module）。</strong></p><p>模块的好处：</p><ul><li>提高了代码的可维护性</li><li>可以避免函数名和变量名冲突</li></ul><p>使用模块的方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> module1[, module2[,... moduleN]<br><br><span class="hljs-comment"># from 后的参数可以为包路径，也可以为模块名路径，并且可以精确指定 import 模块中各成员。</span><br><span class="hljs-keyword">from</span> modname <span class="hljs-keyword">import</span> name1[, name2[, ... nameN]]<br><br><span class="hljs-keyword">from</span> modname <span class="hljs-keyword">import</span> *<br></code></pre></td></tr></table></figure><p>主模块和非主模块</p><p>在 Python中，有主模块和非主模块之分，如果一个模块被直接使用，而没有被别人调用，我们称这个模块为主模块，如果一个模块被别人调用，我们称这个模块为非主模块。</p><p><code>__name__</code>属性值是一个变量，且这个变量是系统给出的。利用这个变量可以判断一个模块是否是主模块。这个属性不能决定他们是否是主模块，决定是否是主模块的条件只是这个模块有没有被人调用。</p><h6 id="包">包</h6><p>为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。</p><p>简单说包就是一个文件夹，这个文件夹包含一个 <code>__init__.py</code>文件，它可以是一个空文件。引入了包以后，只要顶层的包名不冲突，那么所有的模块都不会冲突。</p><p><code>__init__.py</code> 可以是空文件，也可以有Python代码，因为<code>__init__.py</code>本身就是一个模块，而它对应的模块名就是它的包名。</p><p>更多信息请参考<ahref="https://pythonhowto.readthedocs.io/zh-cn/latest/module.html">这里</a></p><h6 id="作用域">作用域</h6><p>在 Python 中，是通过 <code>_</code>前缀来实现的。正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，ni12，PI等；类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的<code>__name__</code> 就是特殊变量，还有 <code>__author__</code>也是特殊变量，用来标明作者。</p><p>注意，我们自己的变量一般不要用这种变量名；类似 <code>_xxx</code> 和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code> ，<code>__abc</code> 等；</p><p><strong>这里是说不应该，而不是不能。因为 Python种并没有一种方法可以完全限制访问 private函数或变量，但是，从编程习惯上不应该引用 private函数或变量。</strong></p>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>开发语言</category>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo文章中插入图片</title>
    <link href="/2024/07/14/hexo%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    <url>/2024/07/14/hexo%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h3 id="markdown添加图片">Markdown添加图片</h3><hr /><p>Markdown 添加图片的格式是:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">图片说明</span>](<span class="hljs-link">图片路径 http网络路径或者本地路径</span>)<br>![<span class="hljs-string">这是一张图片</span>](<span class="hljs-link">https://upload.wikimedia.org/wikipedia/commons/thumb/1/10/20090529_Great_Wall_8185.jpg/2560px-20090529_Great_Wall_8185.jpg</span>)<br></code></pre></td></tr></table></figure><p>插入的图片效果如下图：</p><figure><imgsrc="https://upload.wikimedia.org/wikipedia/commons/thumb/1/10/20090529_Great_Wall_8185.jpg/2560px-20090529_Great_Wall_8185.jpg"alt="这是一张图片" /><figcaption aria-hidden="true">这是一张图片</figcaption></figure><h3 id="hexo文章中的图片">Hexo文章中的图片</h3><hr /><p>在使用Hexo写文章时，有的图片在本地，在本地的markdown文件中可以查看，但是发布到网络后，就因为路径问题无法显示图片。</p><p>解决办法：</p><h5 id="修改配置文件">修改配置文件</h5><p>打开_config.yml配置文件，找到post_asset_folder配置项</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 修改前</span><br><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 修改后</span><br><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>修改post_asset_folder为true后，在使用新建文档时，会在文档同一目录下生成一个同名的文件夹，可以在该文件夹中存放图片，如下图所示。</p><p><img src="image_demo.png" /></p><p>如果是使用Typora编辑文档，为了可以在文档中显示图片，需要设置图片的目录。</p><h5 id="设置typora的图片根目录">设置Typora的图片根目录</h5><blockquote><p>格式（O） -&gt; 图像 -&gt; 设置图片根目录 -&gt;选择文章同名文件夹（即放置图片的文件夹）</p></blockquote><h3 id="总结">总结</h3><hr /><p>经过以上设置后，就可以实现既可以在本地文档中显示图片，发布到网络后也可以现实图片。</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>搭建pytorch环境说明</title>
    <link href="/2024/07/14/%E6%90%AD%E5%BB%BApytorch%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E/"/>
    <url>/2024/07/14/%E6%90%AD%E5%BB%BApytorch%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h3 id="pytorch版本选择">Pytorch版本选择</h3><hr /><p>Pytorch是当前应用最广泛的深度学习框架，在<ahref="https://pytorch.org/">Pytorch官方网站</a>可以找到对应的安装方式。</p><figure><img src="pytorch.png" alt="pytorch" /><figcaption aria-hidden="true">pytorch</figcaption></figure><h3 id="python及虚拟环境安装与设置">Python及虚拟环境安装与设置</h3><hr /><p>使用Pytorch离不开Python，在Pytorch的安装要求中有对python版本的要求，因此可以根据需要安装对应的python版本。</p><p>为了方便python环境中不同包版本的管理，可以用通过虚拟环境进行不同python版本的切换。</p><p>一般来说，有三种方法可以建立python的虚拟环境：virtualenv、Virtualenvwrapper、pipenv。这三种不同的安装使用方式可以参考<ahref="https://blog.csdn.net/sirobot/article/details/107067577">这里</a>.</p><p>这里使用Virtualenvwrapper。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">on Windows</span><br>pip install virtualenvwrapper-win<br><span class="hljs-meta prompt_"># </span><span class="language-bash">on macOS / Linux</span><br>pip install --user virtualenvwrapper #pip install virtualenvwrapper<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">then</span> make Bash load virtualenvwrapper automatically</span><br>echo &quot;source virtualenvwrapper.sh&quot; &gt;&gt; ~/.bashrc  # echo &quot;source 具体的virtualenvwrapper.sh路径&quot; &gt;&gt; ~/.bashrc<br>source ~/.bashrc<br></code></pre></td></tr></table></figure><p>—user 表示 Install to the Python user install directory for yourplatform. Typically ~/.local/, or %APPDATA%on Windows. (See the Pythondocumentation for site.USER_BASE for full details.) (pip install --userxxx 是将module库默认安装到（windows平台）%APPDATA%，（非windows平台）~/.local/ 。)</p><p>如果不用—user 参数, 会有默认的安装目录。</p><p>可以通过 find / -name virtualenvwrapper.sh 找到virtualenvwrapper.sh的目录。如/root/miniconda3/bin/virtualenvwrapper.sh</p><p>根据找到的路径 echo "source/root/miniconda3/bin/virtualenvwrapper.sh" &gt;&gt; ~/.bashrc。</p><p>如果使用pip 有报警提示:</p><blockquote><p>WARNING: Running pip as the 'root' user can result in brokenpermissions and conflicting behaviour with the system package manager.It is recommended to use a virtual environment instead</p></blockquote><p>可以通过添加 --root-user-action=ignore 来忽略。如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install --root-user-action=ignore virtualenvwrapper<br></code></pre></td></tr></table></figure><p>安装好虚拟环境管理工具后，就可以通过工具管理虚拟环境，在虚拟环境下使用不同版本的python或者模块进行工作。</p><h5 id="创建虚拟环境">创建虚拟环境</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">on macOS/Linux:</span><br>mkvirtualenv --python=python3.6 venv<br><span class="hljs-meta prompt_"># </span><span class="language-bash">on Windows</span><br>mkvirtualenv --python=python3 venv<br></code></pre></td></tr></table></figure><h5 id="激活环境">激活环境</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">workon #列出虚拟环境列表<br>workon [venv] #切换环境<br></code></pre></td></tr></table></figure><h5 id="退出环境">退出环境</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">deactivate<br></code></pre></td></tr></table></figure><p>删除环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rmvirtualenv venv<br></code></pre></td></tr></table></figure><h3 id="jupyter安装内核与使用">Jupyter安装内核与使用</h3><hr /><p>Jupyter Notebook是一个交互式笔记本，可以切换不同的内核。</p><p>为了使用虚拟环境下的内核，可以进行如下操作，更详细的请<ahref="https://blog.singee.me/2018/06/28/python/jupyter-kernel/">参考这里</a></p><h5 id="进入虚拟环境">进入虚拟环境</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">workon venv<br></code></pre></td></tr></table></figure><h5 id="查看虚拟是否安装ipykernel">查看虚拟是否安装ipykernel</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m ipykernel --version<br></code></pre></td></tr></table></figure><p>如果有版本输出说明已经安装了 ipykernel如果没有输出，需要安装ipykernel。</p><h5 id="安装ipykernel">安装ipykernel</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install ipykernel<br></code></pre></td></tr></table></figure><h5 id="添加内核">添加内核</h5><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> -<span class="hljs-keyword">m</span> ipykernel install --name <span class="hljs-keyword">python3</span>.<span class="hljs-number">12.3</span> --<span class="hljs-keyword">display</span>-name <span class="hljs-string">&quot;python3.12.3&quot;</span><br></code></pre></td></tr></table></figure><p>添加内核后，就可以使用列出内核命令或者打开jupyternotebook查看内核是否已经添加。</p><h5 id="删除内核">删除内核</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">jupyter</span> kernelspec remove python3.<span class="hljs-number">12</span>.<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h5 id="列出内核">列出内核</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jupyter kernelspec list<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机技术</category>
      
      <category>深度学习</category>
      
      <category>pytorch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo搭建blog教程</title>
    <link href="/2024/07/11/hexo%E6%90%AD%E5%BB%BAblog%E6%95%99%E7%A8%8B/"/>
    <url>/2024/07/11/hexo%E6%90%AD%E5%BB%BAblog%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="hexo">Hexo</h3><hr /><p>Hexo 是一个快速、简洁且高效的博客框架。 Hexo 使用 <ahref="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="hexo文档">Hexo文档</h3><hr /><p><a href="https://hexo.io/zh-cn/docs/">Hexo文档</a></p><p>Hexo文档基本解决大部分写作的问题。</p><h3 id="在github上使用hexo建立blog">在github上使用hexo建立blog</h3><hr /><p>使用Hexo在github上建立blog，请参考<ahref="https://blog.csdn.net/wufengfeng130/article/details/131251961">这里</a></p><blockquote><p>注意：</p><p>如果使用命令行在上传github提示 hexo Support for passwordauthentication was removed on August 13, 2021. Please use a personalaccess token instead.</p><p>请使用 SSHkey在github仓库中部署文件。具体的ssh key 请在github-&gt;settings-&gt;SSH and GPG keys中设置。</p><p>关于ssh key的生成方法，参考<ahref="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent?platform=mac">github文档</a></p></blockquote><h3 id="hexo设置多级目录">Hexo设置多级目录</h3><hr /><p>如果想把文章放在多级目录下，</p><p>请在文件头部添加：</p><blockquote><p>categories: [教程, hexo]</p></blockquote><p>[]内的多级目录使用逗号（英文逗号）分割，前面的是父目录，后面的是子目录。</p><h3 id="hexo写作">Hexo写作</h3><p>在命令行执行如下命令，在可以生成一个要完成的写作文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new post &quot;hexo搭建blog教程&quot;<br></code></pre></td></tr></table></figure><p>生成的文件路径是 本地blog目录下的 source/_posts下面,在该目录下会有一个对应的"hexo搭建blog教程.md"文件，使用文本编辑器进行写作即可。</p><h3 id="hexo发布到github">Hexo发布到github</h3><p>在命令行执行如下命令，即可将文章发布到网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo d -g<br></code></pre></td></tr></table></figure><p>hexo d -g = hero deploy generate.</p><p>具体的hexo命令 请参考<ahref="https://hexo.io/zh-cn/docs/commands">这里</a></p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>markdown输入拼音声调</title>
    <link href="/2024/06/27/markdown%E8%BE%93%E5%85%A5%E6%8B%BC%E9%9F%B3%E5%A3%B0%E8%B0%83/"/>
    <url>/2024/06/27/markdown%E8%BE%93%E5%85%A5%E6%8B%BC%E9%9F%B3%E5%A3%B0%E8%B0%83/</url>
    
    <content type="html"><![CDATA[<p>使用markdown写作，有时会遇到对中文注音的情况。通过查询资料，在此记录下来。</p><table><thead><tr class="header"><th>声调</th><th>格式</th><th>效果</th></tr></thead><tbody><tr class="odd"><td>一声（阴平）</td><td>&amp;<strong>a</strong>macr;</td><td>ā</td></tr><tr class="even"><td>二声（阳平）</td><td>&amp;<strong>a</strong>acute;</td><td>á</td></tr><tr class="odd"><td>三声（上声）上 (shǎng)声</td><td>&amp;<strong>e</strong>caron;ǎ不能使用这个方式，可以使用搜狗拼音输入</td><td>ě</td></tr><tr class="even"><td>四声（去声）</td><td>&amp;<strong>a</strong>grave;</td><td>à</td></tr><tr class="odd"><td>u音</td><td>&amp;<strong>u</strong>uml;</td><td>ü</td></tr></tbody></table><p>用法： 替换<code>&amp;</code>后的第一个字母即可。 注：有的字母替换后显示会不正常，自己尝试下即可。</p><p><ahref="https://dev.w3.org/html5/html-author/charref">特殊字符网址</a></p><p><ahref="https://www.w3.org/TR/WD-math-970710/fnewtable17.html">特殊字符网址2</a></p>]]></content>
    
    
    <categories>
      
      <category>工具技巧</category>
      
      <category>奇技淫巧</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>咏荆轲</title>
    <link href="/2024/06/24/%E5%92%8F%E8%8D%86%E8%BD%B2/"/>
    <url>/2024/06/24/%E5%92%8F%E8%8D%86%E8%BD%B2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>咏荆轲</p><p>唐 柳宗元</p><p>燕秦不两立，太子已为虞。</p><p>千金奉短计，匕首荆卿趋。</p><p>穷年徇所欲，兵势且见屠。</p><p>微言激幽愤，怒目辞燕都。</p><p>朔风动易水，挥爵前长驱。</p><p>函首致宿怨，献田开版图。</p><p>炯然耀电光，掌握罔正夫。</p><p>造端何其锐，临事竟趑（zī）趄(jū)。</p><p>长虹吐白日，仓卒反受诛。</p><p>按剑赫凭怒，风雷助号呼。</p><p>慈父断子首，狂走无容躯。</p><p>夷城芟（shān）七族，台观皆焚污。</p><p>始期忧患弭，卒动灾祸枢。</p><p>秦皇本诈力，事与桓公殊。</p><p>奈何效曹子，实谓勇且愚。</p><p>世传故多谬，太史征无且（jū）。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>人文社科</category>
      
      <category>唐诗</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>田家即事</title>
    <link href="/2024/06/23/%E7%94%B0%E5%AE%B6%E5%8D%B3%E4%BA%8B/"/>
    <url>/2024/06/23/%E7%94%B0%E5%AE%B6%E5%8D%B3%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>田家即事</p><p>唐 储光羲</p><p>蒲叶日已长，杏花日已滋。</p><p>老农要（yào）看此，贵不违天时。</p><p>迎晨起饭牛，双驾耕东菑（zī）。</p><p>蚯蚓土中出，田乌随我飞。</p><p>群合乱啄噪，嗷嗷如道饥。</p><p>我心多恻隐，顾此两伤悲。</p><p>拨食与田乌，日暮空筐归。</p><p>亲戚更相诮（qìao），我心终不移。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>人文社科</category>
      
      <category>唐诗</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>测试</title>
    <link href="/2024/06/17/%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/06/17/%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>这是一个测试页面.</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/06/14/hello-world/"/>
    <url>/2024/06/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
